---
phase: 05-metal-foundation-ground-plane
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - AirplaneTracker3D/AirplaneTracker3DApp.swift
  - AirplaneTracker3D/ContentView.swift
  - AirplaneTracker3D/Rendering/MetalView.swift
  - AirplaneTracker3D/Rendering/Renderer.swift
  - AirplaneTracker3D/Rendering/Shaders.metal
  - AirplaneTracker3D/Rendering/ShaderTypes.h
  - AirplaneTracker3D/Camera/OrbitCamera.swift
  - AirplaneTracker3D.xcodeproj/project.pbxproj
autonomous: false

must_haves:
  truths:
    - "User sees a macOS window with a Metal-rendered 3D scene (clear color visible, rendering at 60fps)"
    - "User can orbit the camera by rotating with two fingers on the trackpad"
    - "User can zoom with trackpad pinch gesture"
    - "User can pan with two-finger drag"
    - "User can reset camera to default position with a keyboard shortcut"
    - "User can enable auto-rotate and camera orbits smoothly around center"
    - "Rendering uses 4x MSAA anti-aliasing for smooth edges"
  artifacts:
    - path: "AirplaneTracker3D/AirplaneTracker3DApp.swift"
      provides: "SwiftUI app entry point"
      contains: "@main"
    - path: "AirplaneTracker3D/Rendering/MetalView.swift"
      provides: "NSViewRepresentable wrapping MTKView with gesture recognizers"
      min_lines: 80
    - path: "AirplaneTracker3D/Rendering/Renderer.swift"
      provides: "MTKViewDelegate with triple buffering, pipeline state, per-frame draw"
      min_lines: 150
    - path: "AirplaneTracker3D/Rendering/Shaders.metal"
      provides: "Vertex and fragment shaders for basic geometry"
      contains: "vertex_main"
    - path: "AirplaneTracker3D/Rendering/ShaderTypes.h"
      provides: "Shared CPU/GPU type definitions (uniforms struct)"
      contains: "Uniforms"
    - path: "AirplaneTracker3D/Camera/OrbitCamera.swift"
      provides: "Orbital camera with projection and view matrices"
      exports: ["OrbitCamera"]
  key_links:
    - from: "AirplaneTracker3D/ContentView.swift"
      to: "AirplaneTracker3D/Rendering/MetalView.swift"
      via: "MetalView() in SwiftUI body"
      pattern: "MetalView"
    - from: "AirplaneTracker3D/Rendering/MetalView.swift"
      to: "AirplaneTracker3D/Rendering/Renderer.swift"
      via: "Coordinator holds Renderer, acts as MTKViewDelegate"
      pattern: "Renderer"
    - from: "AirplaneTracker3D/Rendering/Renderer.swift"
      to: "AirplaneTracker3D/Camera/OrbitCamera.swift"
      via: "Renderer reads camera matrices for uniform buffer"
      pattern: "camera\\.viewMatrix|camera\\.projectionMatrix"
    - from: "AirplaneTracker3D/Rendering/Renderer.swift"
      to: "AirplaneTracker3D/Rendering/Shaders.metal"
      via: "Pipeline state references vertex_main and fragment_main"
      pattern: "vertex_main|fragment_main"
---

<objective>
Create the Xcode project from scratch, establish the Metal rendering pipeline with triple buffering and 4x MSAA, bridge MTKView into SwiftUI via NSViewRepresentable, and implement a fully interactive orbital camera with trackpad gestures (orbit, zoom, pan), reset, and auto-rotate.

Purpose: This is the rendering foundation for the entire native macOS app. Every subsequent phase builds on this Metal renderer and camera system.
Output: A running macOS app that shows a 3D Metal scene with full trackpad camera controls at 60fps.
</objective>

<execution_context>
@/Users/mit/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mit/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Xcode project, SwiftUI shell, and triple-buffered Metal renderer</name>
  <files>
    AirplaneTracker3D/AirplaneTracker3DApp.swift
    AirplaneTracker3D/ContentView.swift
    AirplaneTracker3D/Rendering/MetalView.swift
    AirplaneTracker3D/Rendering/Renderer.swift
    AirplaneTracker3D/Rendering/Shaders.metal
    AirplaneTracker3D/Rendering/ShaderTypes.h
    AirplaneTracker3D.xcodeproj/project.pbxproj
  </files>
  <action>
    Create a new Xcode project for a macOS SwiftUI app named "AirplaneTracker3D" inside the repository root. Use `swift package init` or manually create the Xcode project structure. The project MUST target macOS 14.0 (Sonoma) minimum deployment. Use Swift 6.2.

    **AirplaneTracker3DApp.swift:**
    - @main App struct with a single WindowGroup
    - Window title "Airplane Tracker 3D"
    - Default window size 1280x800 via .defaultSize()

    **ContentView.swift:**
    - Contains MetalView() filling the entire window
    - No SwiftUI state that would trigger MetalView recreation (critical pitfall from research)

    **MetalView.swift (NSViewRepresentable):**
    - Wraps MTKView via NSViewRepresentable (NOT SwiftUI View directly)
    - Coordinator class that conforms to MTKViewDelegate
    - Coordinator holds a strong reference to Renderer
    - Coordinator forwards mtkView(_:drawableSizeWillChange:) and draw(in:) to Renderer
    - In makeNSView: create MTKView with MTLCreateSystemDefaultDevice(), set preferredFramesPerSecond = 60, colorPixelFormat = .bgra8Unorm, depthStencilPixelFormat = .depth32Float
    - Configure 4x MSAA: set mtkView.sampleCount = 4 (REND-10)
    - Set mtkView.delegate = context.coordinator
    - IMPORTANT: MTKView must have ZERO dependency on SwiftUI @State to prevent recreation

    **Renderer.swift:**
    - Holds all Metal state: MTLDevice, MTLCommandQueue, MTLRenderPipelineState, MTLDepthStencilState
    - Triple buffering: DispatchSemaphore(value: 3), array of 3 MTLBuffer for uniform data (ring buffer pattern)
    - currentBufferIndex cycles 0,1,2 each frame
    - init(metalView:) creates device, command queue, loads shader library, creates pipeline state and depth stencil state
    - Pipeline descriptor MUST set sampleCount = 4 to match MTKView MSAA config
    - Pipeline descriptor MUST set rasterSampleCount = 4
    - Create a simple grid/ground plane vertex buffer (a flat quad at Y=0 from -500 to +500 in X and Z) to prove rendering works. Use 2 triangles with position + color attributes. Color it a dark gray (#333333) so it is visible.
    - draw(in:) method:
      1. semaphore.wait() at start
      2. Get current uniform buffer (ring index)
      3. Update uniforms (view + projection matrices from camera)
      4. Create command buffer, get render pass descriptor from view
      5. Set clear color to sky blue (0.529, 0.808, 0.922, 1.0) for a pleasant default
      6. Create render command encoder
      7. Set pipeline state, depth stencil state, vertex buffer, uniform buffer
      8. Draw the ground quad
      9. End encoding, present drawable, commit
      10. semaphore.signal() in command buffer completion handler
    - CRITICAL: Wrap the entire draw body in autoreleasepool {} to prevent Metal object leaks
    - Create ALL pipeline states once in init, NEVER per-frame

    **Shaders.metal:**
    - Include ShaderTypes.h for shared Uniforms struct
    - vertex_main: Takes vertex position + color, multiplies by model-view-projection matrix from uniforms, passes color to fragment
    - fragment_main: Returns interpolated color
    - Vertex input struct: float3 position, float4 color
    - VertexOut struct: float4 position [[position]], float4 color

    **ShaderTypes.h:**
    - C header (bridgeable to both Swift and Metal)
    - Uniforms struct containing: simd_float4x4 modelMatrix, simd_float4x4 viewMatrix, simd_float4x4 projectionMatrix
    - Buffer index constants: BufferIndexUniforms = 0, BufferIndexVertices = 1

    IMPORTANT METAL COORDINATE SYSTEM NOTES (from research pitfalls):
    - Metal NDC depth range is [0, +1] (NOT [-1, +1] like OpenGL/WebGL)
    - Metal uses clockwise front-face winding by default
    - Build projection matrix from scratch using Metal conventions, do NOT copy OpenGL formulas
  </action>
  <verify>
    1. The Xcode project builds without errors: `xcodebuild -project AirplaneTracker3D.xcodeproj -scheme AirplaneTracker3D -configuration Debug build`
    2. The app launches and shows a window with a sky blue background and a dark gray ground quad
  </verify>
  <done>
    macOS app window renders a sky blue Metal scene with a visible dark gray ground plane at 60fps using triple buffering and 4x MSAA. No frame drops, no Metal validation errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement orbital camera with trackpad gestures, reset, and auto-rotate</name>
  <files>
    AirplaneTracker3D/Camera/OrbitCamera.swift
    AirplaneTracker3D/Rendering/MetalView.swift
    AirplaneTracker3D/Rendering/Renderer.swift
  </files>
  <action>
    **OrbitCamera.swift:**
    - Create OrbitCamera class (or struct) with these properties:
      - target: SIMD3<Float> (look-at point, default origin 0,0,0)
      - distance: Float (distance from target, default 200, range 10...1000)
      - azimuth: Float (horizontal angle in radians, default 0)
      - elevation: Float (vertical angle in radians, default 0.5, clamped to 0.05...Float.pi/2 - 0.05 to prevent gimbal lock)
      - fov: Float (field of view in radians, default 45 degrees)
      - nearPlane: Float = 0.1
      - farPlane: Float = 5000.0
    - Computed property `position: SIMD3<Float>` using spherical-to-cartesian:
      - x = target.x + distance * cos(elevation) * sin(azimuth)
      - y = target.y + distance * sin(elevation)
      - z = target.z + distance * cos(elevation) * cos(azimuth)
    - Computed property `viewMatrix: simd_float4x4` using a look-at function:
      - Build from position, target, up=(0,1,0)
      - Implement simd_lookAt manually (simd library does not provide one)
    - Computed property `projectionMatrix: simd_float4x4` using perspective projection:
      - MUST use Metal NDC depth [0, +1] convention
      - perspective(fovY:aspectRatio:nearZ:farZ:) with Metal-correct depth mapping
      - Takes aspect ratio as parameter (updated when drawable size changes)
    - var aspectRatio: Float = 1.0 (updated by renderer on resize)
    - Method `orbit(deltaAzimuth:deltaElevation:)` -- adds deltas to azimuth/elevation with clamping
    - Method `zoom(delta:)` -- multiplies distance by (1 - delta * 0.01), clamped to range
    - Method `pan(deltaX:deltaY:)` -- moves target in camera-local right/up directions, scaled by distance
    - Method `reset()` -- restores default values (azimuth=0, elevation=0.5, distance=200, target=origin)
    - Auto-rotate: var isAutoRotating: Bool = false, var autoRotateSpeed: Float = 0.005
    - Method `update(deltaTime:)` -- if isAutoRotating, increment azimuth by autoRotateSpeed * deltaTime

    **MetalView.swift updates:**
    - Add NSMagnificationGestureRecognizer for pinch zoom (CAM-02)
    - Add NSRotationGestureRecognizer for two-finger rotate orbit (CAM-01)
    - Add NSPanGestureRecognizer for two-finger drag pan (CAM-03)
    - Configure pan gesture: buttonMask = 0 (trackpad), numberOfTouchesRequired = 2
    - Gesture handlers call methods on Renderer's camera:
      - Rotation gesture: camera.orbit(deltaAzimuth: -rotation, deltaElevation: 0) -- negate for natural direction
      - Magnification: camera.zoom(delta: Float(magnification) * 5.0)
      - Pan: camera.pan(deltaX: Float(translation.x) * 0.5, deltaY: Float(translation.y) * 0.5)
    - Override scrollWheel(with:) on the MTKView subclass (or use a custom NSView subclass) for scroll-to-orbit as alternative to rotation gesture:
      - deltaX -> azimuth, deltaY -> elevation (scaled by 0.005)
    - Add keyDown handler for camera reset: press 'r' key calls camera.reset() (CAM-04)
    - Add keyDown handler for auto-rotate toggle: press 'a' key toggles camera.isAutoRotating (CAM-05)
    - IMPORTANT: To receive key events, the MTKView needs to be first responder. Override acceptsFirstResponder to return true. Call window?.makeFirstResponder(self) in viewDidMoveToWindow.

    **Renderer.swift updates:**
    - Add camera: OrbitCamera property, initialized in init
    - In draw(in:), before encoding:
      - Call camera.update(deltaTime:) for auto-rotate (compute deltaTime from CACurrentMediaTime)
      - Update camera.aspectRatio from drawable size
      - Build Uniforms from camera.viewMatrix and camera.projectionMatrix
      - Set modelMatrix to identity (ground quad is at world origin)
    - In mtkView(_:drawableSizeWillChange:), update camera.aspectRatio

    Sensitivity tuning for gestures:
    - Orbit: ~0.005 radians per point of scroll delta feels natural
    - Zoom: multiply magnification gesture value by ~5.0 for responsive feel
    - Pan: scale by distance * 0.002 so pan speed increases when zoomed out
  </action>
  <verify>
    1. Build succeeds: `xcodebuild -project AirplaneTracker3D.xcodeproj -scheme AirplaneTracker3D -configuration Debug build`
    2. Launch app, verify ground quad visible from default camera angle (elevated, looking at origin)
    3. Two-finger rotate on trackpad orbits the camera around the ground plane
    4. Pinch gesture zooms in and out
    5. Two-finger drag pans the view
    6. Press 'r' to reset camera to default position
    7. Press 'a' to start auto-rotate, camera orbits smoothly
  </verify>
  <done>
    Camera orbits, zooms, and pans with trackpad gestures at 60fps. 'r' resets to default view, 'a' toggles auto-rotate. Elevation is clamped to prevent flipping. All gestures feel responsive and natural.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify Metal rendering and camera controls</name>
  <files>None (verification only)</files>
  <action>
    Human verifies the Metal rendering pipeline and camera controls built in Tasks 1-2. Launch the app and test all interactions described in the verification steps below.
  </action>
  <verify>
    1. The app window opens showing a sky blue background with a dark gray ground plane visible from an elevated angle
    2. Two-finger rotate on trackpad orbits the camera smoothly at 60fps
    3. Pinch to zoom in/out with limits (no zoom through ground or to infinity)
    4. Two-finger drag pans the view left/right/up/down
    5. Press 'r' to reset camera to default elevated angle
    6. Press 'a' to toggle auto-rotate -- camera orbits smoothly around center
    7. Press 'a' again to stop auto-rotate
    8. No flickering, tearing, or frame drops during any interaction
  </verify>
  <done>
    User confirms: Metal scene renders correctly, all 5 camera controls (orbit, zoom, pan, reset, auto-rotate) work at 60fps with no visual artifacts.
  </done>
</task>

</tasks>

<verification>
- App builds with `xcodebuild` and launches without Metal validation errors
- 60fps rendering confirmed (no frame drops during camera movement)
- Triple buffering active (semaphore with value 3, ring buffer cycling)
- 4x MSAA active (set on both MTKView.sampleCount and pipeline descriptor)
- All 5 camera requirements functional: orbit (CAM-01), zoom (CAM-02), pan (CAM-03), reset (CAM-04), auto-rotate (CAM-05)
- REND-10 (MSAA) implemented
</verification>

<success_criteria>
- macOS window opens with Metal-rendered 3D scene
- Ground plane visible at Y=0 from default camera position
- Trackpad orbit, zoom, and pan all work at 60fps
- Camera reset and auto-rotate functional via keyboard
- No Metal validation errors, no memory leaks from missing autoreleasepool
- Triple buffering prevents CPU/GPU sync stalls
</success_criteria>

<output>
After completion, create `.planning/phases/05-metal-foundation-ground-plane/05-01-SUMMARY.md`
</output>
