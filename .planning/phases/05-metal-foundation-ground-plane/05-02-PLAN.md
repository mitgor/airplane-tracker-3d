---
phase: 05-metal-foundation-ground-plane
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - AirplaneTracker3D/Map/MapTileManager.swift
  - AirplaneTracker3D/Map/TileCoordinate.swift
  - AirplaneTracker3D/Map/MapCoordinateSystem.swift
  - AirplaneTracker3D/Rendering/Renderer.swift
  - AirplaneTracker3D/Rendering/Shaders.metal
  - AirplaneTracker3D/Rendering/ShaderTypes.h
autonomous: false

must_haves:
  truths:
    - "User sees map tiles rendered on a 3D ground plane that matches real-world geography at configured center coordinates"
    - "Map tiles load asynchronously without blocking the render loop -- tiles appear progressively as they load"
    - "User can orbit/zoom/pan and new tiles load for the visible region"
    - "Tile zoom level changes based on camera distance (zoom levels 6-12)"
    - "Previously loaded tiles are cached and reappear instantly when revisiting a region"
  artifacts:
    - path: "AirplaneTracker3D/Map/MapTileManager.swift"
      provides: "Async tile fetching, LRU cache, Metal texture creation"
      min_lines: 150
    - path: "AirplaneTracker3D/Map/TileCoordinate.swift"
      provides: "Slippy map tile coordinate math (lat/lon to tile x/y)"
      min_lines: 30
    - path: "AirplaneTracker3D/Map/MapCoordinateSystem.swift"
      provides: "Geographic to world-space coordinate conversion"
      min_lines: 40
  key_links:
    - from: "AirplaneTracker3D/Rendering/Renderer.swift"
      to: "AirplaneTracker3D/Map/MapTileManager.swift"
      via: "Renderer calls tileManager to get visible tiles and their textures"
      pattern: "tileManager|MapTileManager"
    - from: "AirplaneTracker3D/Map/MapTileManager.swift"
      to: "URLSession"
      via: "Async tile download from OSM tile servers"
      pattern: "URLSession.*data|tile\\.openstreetmap"
    - from: "AirplaneTracker3D/Map/MapTileManager.swift"
      to: "MTLTexture"
      via: "Downloaded PNG converted to Metal texture via MTKTextureLoader"
      pattern: "MTKTextureLoader|newTexture"
    - from: "AirplaneTracker3D/Rendering/Shaders.metal"
      to: "texture2d"
      via: "Fragment shader samples tile texture"
      pattern: "texture2d|sample"
---

<objective>
Implement the map tile ground plane with async tile loading, geographic coordinate system, and texture-mapped tile rendering. The user will see real OpenStreetMap tiles rendered on a 3D ground plane that updates as they navigate with the camera.

Purpose: This turns the blank ground plane into a real-world map, establishing the geographic coordinate system that all future rendering (aircraft, airports, terrain) will use.
Output: A navigable 3D map with live OSM tiles loading asynchronously as the camera moves.
</objective>

<execution_context>
@/Users/mit/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mit/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/05-metal-foundation-ground-plane/05-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Coordinate system, tile math, and async tile manager with LRU cache</name>
  <files>
    AirplaneTracker3D/Map/MapCoordinateSystem.swift
    AirplaneTracker3D/Map/TileCoordinate.swift
    AirplaneTracker3D/Map/MapTileManager.swift
  </files>
  <action>
    **MapCoordinateSystem.swift:**
    - Define the coordinate mapping from geographic (lat/lon) to Metal world-space (X, Y, Z)
    - Center coordinates: configurable, default to a good location (e.g., lat=47.6, lon=-122.3 for Seattle area, or whatever the user had in the web version)
    - Use Mercator projection for tile alignment:
      - lonToX(lon:) -> Float: Maps longitude to world X. Center lon maps to X=0.
      - latToZ(lat:) -> Float: Maps latitude to world Z using Mercator formula. Center lat maps to Z=0.
      - xToLon(x:) -> Double, zToLat(z:) -> Double: Inverse transforms
    - Scale factor: Choose a worldScale constant so that the visible ground covers a reasonable area at default zoom. Typical: 1 world unit = some fraction of a degree. The scale should make tiles approximately 50-100 world units per tile at mid zoom levels.
    - Ground plane is at Y = 0 in world space.
    - Static/singleton pattern since coordinate system is global.

    **TileCoordinate.swift:**
    - Struct TileCoordinate: Hashable with x: Int, y: Int, zoom: Int
    - Static method tileFor(lat:lon:zoom:) -> TileCoordinate using standard slippy map math:
      - n = 2^zoom
      - x = floor((lon + 180) / 360 * n)
      - y = floor((1 - ln(tan(lat_rad) + 1/cos(lat_rad)) / pi) / 2 * n)
    - Static method tileBounds(tile:) -> (minLat, maxLat, minLon, maxLon) -- inverse of tileFor, gives geographic bounds of a tile
    - Static method visibleTiles(centerLat:centerLon:zoom:radius:) -> [TileCoordinate]:
      - Compute center tile, then expand by radius tiles in each direction
      - Return grid of tiles covering the visible area
      - Clamp y to valid range [0, 2^zoom - 1], wrap x modulo 2^zoom

    **MapTileManager.swift:**
    - Class MapTileManager
    - Properties:
      - device: MTLDevice
      - textureLoader: MTKTextureLoader
      - cache: [TileCoordinate: MTLTexture] (LRU cache)
      - cacheOrder: [TileCoordinate] (for LRU eviction)
      - maxCacheSize: Int = 300
      - pendingRequests: Set<TileCoordinate> (prevent duplicate downloads)
      - urlSession: URLSession (configured with appropriate cache policy and timeout)
    - init(device:) -- create MTKTextureLoader and URLSession
    - Method `tileURL(for tile:) -> URL`:
      - Use OpenStreetMap tile server: "https://a.tile.openstreetmap.org/{z}/{x}/{y}.png"
      - Rotate between a/b/c subdomains based on tile.x % 3 for load balancing
    - Method `texture(for tile:) -> MTLTexture?`:
      - If cached, move to end of cacheOrder (LRU update), return texture
      - If not cached and not pending, start async download
      - Return nil (caller renders placeholder color)
    - Method `fetchTile(_ tile:) async`:
      - Add to pendingRequests
      - Download PNG data via URLSession.shared.data(from: url)
      - Convert to MTLTexture via MTKTextureLoader.newTexture(data:options:)
        - Options: [.textureUsage: MTLTextureUsage.shaderRead, .textureStorageMode: MTLStorageMode.private, .SRGB: false]
      - Store in cache, remove from pendingRequests
      - If cache exceeds maxCacheSize, evict oldest entries from cacheOrder
      - Catch errors silently (log to console, tile stays nil)
    - Method `zoomLevel(forCameraDistance distance:) -> Int`:
      - Map camera distance to tile zoom level 6-12
      - Closer camera = higher zoom number = more detail
      - Approximate mapping: distance > 800 -> zoom 6, distance < 20 -> zoom 12
      - Use log2 interpolation for smooth transitions
    - Use @MainActor or dispatch to main for cache mutations if needed for thread safety, OR use an actor for the tile manager.

    IMPORTANT: The URLSession requests MUST include a proper User-Agent header (e.g., "AirplaneTracker3D/1.0") per OSM tile usage policy. Do NOT use the default URLSession user agent.
  </action>
  <verify>
    1. Build succeeds: `xcodebuild -project AirplaneTracker3D.xcodeproj -scheme AirplaneTracker3D -configuration Debug build`
    2. Unit-testable: TileCoordinate.tileFor(lat: 47.6, lon: -122.3, zoom: 10) returns a valid tile coordinate
    3. MapCoordinateSystem round-trips: lonToX then xToLon returns original value (within floating point tolerance)
  </verify>
  <done>
    MapCoordinateSystem converts between geographic and world-space coordinates. TileCoordinate computes slippy map tile positions. MapTileManager fetches tiles asynchronously via URLSession, creates Metal textures, and caches up to 300 tiles with LRU eviction.
  </done>
</task>

<task type="auto">
  <name>Task 2: Render textured tile quads on the ground plane with dynamic loading</name>
  <files>
    AirplaneTracker3D/Rendering/Renderer.swift
    AirplaneTracker3D/Rendering/Shaders.metal
    AirplaneTracker3D/Rendering/ShaderTypes.h
  </files>
  <action>
    **ShaderTypes.h updates:**
    - Add a second vertex input struct for textured geometry: float3 position, float2 texCoord
    - Add a VertexOutTextured struct: float4 position [[position]], float2 texCoord
    - Add buffer index constant for model matrix if using per-tile draw calls

    **Shaders.metal updates:**
    - Add vertex_textured: Takes position + texCoord, applies MVP transform, outputs position + texCoord
    - Add fragment_textured: Samples texture2d<float> at interpolated texCoord, returns sampled color
    - Add fragment_placeholder: Returns a solid medium-gray color (0.4, 0.4, 0.4, 1.0) for tiles still loading
    - Keep existing vertex_main and fragment_main for non-textured geometry (used by the colored ground quad from plan 01, which will be replaced by tiles)

    **Renderer.swift updates:**
    - Add property: tileManager: MapTileManager (initialized in init)
    - Add property: texturedPipelineState: MTLRenderPipelineState (created in init, uses vertex_textured + fragment_textured, sampleCount=4)
    - Add property: placeholderPipelineState: MTLRenderPipelineState (uses vertex_textured + fragment_placeholder, sampleCount=4)
    - Create a reusable tile quad vertex buffer in init:
      - A unit quad (0,0)-(1,0)-(1,1)-(0,1) at Y=0 with proper texture coordinates
      - 2 triangles, 6 vertices, each with position (float3) + texCoord (float2)
      - Texture coords: (0,0), (1,0), (1,1) and (0,0), (1,1), (0,1) -- flip V if needed for Metal's texture coordinate convention
    - In draw(in:):
      1. Determine current zoom level from camera distance: tileManager.zoomLevel(forCameraDistance: camera.distance)
      2. Compute visible tiles: TileCoordinate.visibleTiles(centerLat:centerLon:zoom:radius:) -- use MapCoordinateSystem to get center lat/lon, radius ~5-8 tiles
      3. For each visible tile:
         a. Get tile bounds (lat/lon) from TileCoordinate.tileBounds()
         b. Convert bounds to world-space X/Z using MapCoordinateSystem
         c. Build a per-tile model matrix that scales and translates the unit quad to the tile's world-space position and size
         d. Check if texture exists: tileManager.texture(for: tile)
         e. If texture exists: use texturedPipelineState, bind texture to fragment shader
         f. If texture is nil (still loading): use placeholderPipelineState (renders gray)
         g. Set vertex buffer (shared tile quad), set uniform buffer with per-tile model matrix
         h. Draw 6 vertices (2 triangles)
      4. Remove the old single ground quad draw call from plan 01 (replaced by tile grid)
    - Handle zoom level changes: When zoom changes, request new tiles. Old zoom tiles can remain visible as placeholders until new ones load (graceful transition).
    - Tile draw order: Draw back-to-front relative to camera for correct transparency (though tiles are opaque, this prevents z-fighting). Alternatively, rely on depth buffer since all tiles are at Y=0 -- use a tiny Y offset based on zoom to prevent z-fighting between zoom levels.

    Performance considerations:
    - Do NOT create new vertex buffers per frame. Reuse the single unit quad buffer.
    - Do NOT create new pipeline states per frame. Both textured and placeholder states created once in init.
    - Limit visible tile count to prevent excessive draw calls. At zoom 6, ~16 tiles visible. At zoom 12, limit radius to show ~64-100 tiles max.
    - Tile fetches are async and non-blocking. The render loop never waits for a tile to download.

    Winding order: Metal default is clockwise front-face. Ensure the quad vertices wind clockwise when viewed from above (positive Y direction). If tiles appear invisible, check winding or set cullMode to .none temporarily for debugging.
  </action>
  <verify>
    1. Build succeeds: `xcodebuild -project AirplaneTracker3D.xcodeproj -scheme AirplaneTracker3D -configuration Debug build`
    2. Launch app -- map tiles should begin loading and appearing on the ground plane
    3. Gray placeholder tiles appear immediately, then fill in with real map imagery
    4. Orbit/zoom/pan causes new tiles to load for newly visible regions
    5. Zooming in shows higher detail tiles (zoom level increases)
    6. Zooming out shows lower detail tiles (zoom level decreases)
    7. No frame drops during tile loading (async, non-blocking)
    8. Previously visited tiles reappear instantly from cache
  </verify>
  <done>
    Map tiles from OpenStreetMap render as textured quads on the ground plane at Y=0. Tiles load asynchronously without blocking rendering. Zoom level adapts to camera distance (levels 6-12). LRU cache holds 300 tiles. Gray placeholders shown for loading tiles. Geographic positions match real-world coordinates.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify map tile ground plane and full navigation</name>
  <files>None (verification only)</files>
  <action>
    Human verifies the map tile ground plane and full navigation built in Tasks 1-2. Launch the app and test all interactions described in the verification steps below.
  </action>
  <verify>
    1. Launch the app -- real map tiles load on the ground plane
    2. Tiles appear progressively (gray placeholders filling in with map imagery)
    3. The map shows real geographic features at the configured center coordinates
    4. Orbit the camera -- map tiles stay fixed on the ground as you rotate
    5. Zoom in -- higher detail tiles load (street names readable at high zoom)
    6. Zoom out -- lower detail tiles load (wider area visible)
    7. Pan the view -- new tiles load for newly visible areas
    8. Return to previously viewed area -- tiles appear instantly from cache
    9. Smooth 60fps throughout all navigation -- tile loading never causes stuttering
    10. Press 'a' for auto-rotate -- map orbits smoothly with tiles visible
  </verify>
  <done>
    User confirms: Map tiles render correctly on ground plane, async loading works without frame drops, zoom levels adapt to camera distance, cache prevents re-downloads, and all camera controls work with the tile map.
  </done>
</task>

</tasks>

<verification>
- All Phase 5 requirements covered:
  - REND-07: Map tile ground plane with async loading at zoom levels 6-12
  - REND-10: 4x MSAA (implemented in plan 01, carried forward)
  - CAM-01 through CAM-05: All camera controls (implemented in plan 01, functional with tile map)
- Map tiles correspond to real-world geography
- Tiles load without blocking the render loop
- Camera controls work identically to plan 01 but now with map visible
- LRU cache prevents unbounded memory growth (300 tile limit)
</verification>

<success_criteria>
- OpenStreetMap tiles visible on ground plane at correct geographic positions
- Async loading: gray placeholders transition to real tiles without frame drops
- Zoom levels 6-12 working based on camera distance
- 300-tile LRU cache functional
- All camera controls from plan 01 work with the tile map
- 60fps maintained during tile loading and navigation
</success_criteria>

<output>
After completion, create `.planning/phases/05-metal-foundation-ground-plane/05-02-SUMMARY.md`
</output>
