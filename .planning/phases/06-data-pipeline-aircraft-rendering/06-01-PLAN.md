---
phase: 06-data-pipeline-aircraft-rendering
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - AirplaneTracker3D/Models/AircraftModel.swift
  - AirplaneTracker3D/Models/AircraftCategory.swift
  - AirplaneTracker3D/DataLayer/FlightDataActor.swift
  - AirplaneTracker3D/DataLayer/DataNormalizer.swift
  - AirplaneTracker3D.xcodeproj/project.pbxproj
autonomous: true

must_haves:
  truths:
    - "App polls airplanes.live API at 5-second intervals and receives aircraft data"
    - "When airplanes.live fails, app silently falls back to adsb.lol with no interruption"
    - "App polls local dump1090 at 1-second intervals when in local mode"
    - "User can switch between local and global data modes"
    - "Aircraft data from all sources is normalized to a common AircraftModel format"
    - "Each aircraft has a category classification (jet, widebody, helicopter, small, military, regional)"
    - "Aircraft positions interpolate smoothly between data updates at 60fps render rate"
    - "Stale aircraft that stop appearing in API responses are removed after timeout"
  artifacts:
    - path: "AirplaneTracker3D/Models/AircraftModel.swift"
      provides: "Normalized aircraft data model, Codable API response types, AltitudeValue enum"
      contains: "struct AircraftModel"
    - path: "AirplaneTracker3D/Models/AircraftCategory.swift"
      provides: "6 aircraft category enum with classify() method using dbFlags, ADS-B category, type code, and callsign heuristics"
      contains: "enum AircraftCategory"
    - path: "AirplaneTracker3D/DataLayer/FlightDataActor.swift"
      provides: "Actor-based polling loop with provider fallback, time-windowed interpolation buffer, stale aircraft removal, AsyncStream output"
      contains: "actor FlightDataActor"
    - path: "AirplaneTracker3D/DataLayer/DataNormalizer.swift"
      provides: "Static normalizers for V2 API and dump1090 response formats"
      contains: "enum DataNormalizer"
  key_links:
    - from: "AirplaneTracker3D/DataLayer/FlightDataActor.swift"
      to: "URLSession.shared.data(from:)"
      via: "async/await HTTP polling"
      pattern: "URLSession\\.shared\\.data"
    - from: "AirplaneTracker3D/DataLayer/FlightDataActor.swift"
      to: "AirplaneTracker3D/DataLayer/DataNormalizer.swift"
      via: "normalizeV2() and normalizeDump1090() calls after fetch"
      pattern: "DataNormalizer\\.normalize"
    - from: "AirplaneTracker3D/DataLayer/FlightDataActor.swift"
      to: "AirplaneTracker3D/Models/AircraftCategory.swift"
      via: "classify() called during buffer update to assign category"
      pattern: "AircraftCategory\\.classify"
    - from: "AirplaneTracker3D/DataLayer/FlightDataActor.swift"
      to: "AirplaneTracker3D/Map/MapCoordinateSystem.swift"
      via: "worldPosition(lat:lon:) for interpolated world-space conversion"
      pattern: "MapCoordinateSystem\\.shared\\.worldPosition"
---

<objective>
Build the flight data pipeline: an actor-based network polling system with provider fallback, data normalization, aircraft category classification, and time-windowed interpolation buffer that outputs smooth per-frame aircraft states.

Purpose: This is the data backbone for aircraft rendering. Without smooth interpolated positions arriving each frame, aircraft would teleport between API updates (1-5 second gaps). The actor pattern ensures thread-safe data access while AsyncStream provides clean integration with the rendering loop.

Output: 4 new Swift files (AircraftModel, AircraftCategory, FlightDataActor, DataNormalizer) plus Xcode project updates. The FlightDataActor produces an AsyncStream of interpolated aircraft states ready for the rendering pipeline in plan 06-02.
</objective>

<execution_context>
@/Users/mit/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mit/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-data-pipeline-aircraft-rendering/06-RESEARCH.md
@AirplaneTracker3D/Map/MapCoordinateSystem.swift
@AirplaneTracker3D/Rendering/ShaderTypes.h
@AirplaneTracker3D.xcodeproj/project.pbxproj
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create data models, Codable API types, and aircraft category classification</name>
  <files>
    AirplaneTracker3D/Models/AircraftModel.swift
    AirplaneTracker3D/Models/AircraftCategory.swift
    AirplaneTracker3D/DataLayer/DataNormalizer.swift
    AirplaneTracker3D.xcodeproj/project.pbxproj
  </files>
  <action>
Create a `Models/` group and `DataLayer/` group in the Xcode project. Create three files:

**AircraftModel.swift** -- Contains:
1. `AltitudeValue` enum (Codable) that handles both Int and "ground" string from ADS-B APIs. Custom `init(from:)` tries Int first, then String "ground", else defaults to .feet(0). Has `asFeet: Float` computed property.
2. `ADSBV2Response` struct (Codable): fields `ac: [ADSBV2Aircraft]?`, `msg: String?`, `now: Double?`, `total: Int?`, `ctime: Double?`, `ptime: Double?`.
3. `ADSBV2Aircraft` struct (Codable): all fields from research (hex, flight, r, t, desc, lat, lon, alt_baro as AltitudeValue?, alt_geom as Int?, gs, track, baro_rate, geom_rate, squawk, category, emergency, nav_heading, true_heading, mag_heading, ias, tas, mach, seen, seen_pos, messages, rssi, dbFlags) -- all optional.
4. `Dump1090Response` struct (Codable): `now: Double?`, `messages: Int?`, `aircraft: [Dump1090Aircraft]?`.
5. `Dump1090Aircraft` struct (Codable): hex, flight, lat, lon, altitude as AltitudeValue?, speed, track, vert_rate, squawk, seen, messages, rssi -- all optional.
6. `AircraftModel` struct (Sendable): normalized fields -- hex: String, callsign: String, lat: Double, lon: Double, altitude: Float, track: Float, groundSpeed: Float, verticalRate: Float, squawk: String, category: String (ADS-B A0-D7), registration: String, typeCode: String, dbFlags: Int.
7. `InterpolatedAircraftState` struct (Sendable): position: SIMD3<Float> (world XZ + altitude Y), heading: Float (radians), groundSpeed: Float, verticalRate: Float, altitude: Float (feet, for color mapping), category: AircraftCategory, hex: String, callsign: String.

**AircraftCategory.swift** -- Contains:
1. `AircraftCategory` enum: cases jet, widebody, helicopter, small, military, regional. Conforms to CaseIterable, Sendable.
2. `static func classify(_ aircraft: AircraftModel) -> AircraftCategory` method implementing the 4-priority classification from research:
   - Priority 1: dbFlags & 1 != 0 -> military
   - Priority 2: ADS-B category field (A1->small, A2->small, A3->regional, A4->jet, A5->widebody, A6->widebody, A7->helicopter, B1/B2->small)
   - Priority 3: ICAO type code lookup (heliTypes, wideTypes, milTypes arrays from research)
   - Priority 4: Callsign + flight parameter heuristics from research (altitude/speed thresholds)

**DataNormalizer.swift** -- Contains:
1. `enum DataNormalizer` with two static methods:
   - `static func normalizeV2(_ response: ADSBV2Response) -> [AircraftModel]` -- compactMaps ac array, requires hex/lat/lon non-nil, maps all fields. Trims whitespace from callsign.
   - `static func normalizeDump1090(_ response: Dump1090Response) -> [AircraftModel]` -- same pattern, maps older field names (speed->groundSpeed, vert_rate->verticalRate, altitude->alt_baro). Sets category/registration/typeCode/dbFlags to empty/zero since dump1090 lacks these.

Add all 3 files to the Xcode project's `project.pbxproj` under a new `Models` and `DataLayer` group in the main target. Follow the existing pattern for file references and build phases (look at how Map/ group files were added in 05-02).
  </action>
  <verify>
Run `xcodebuild build -project AirplaneTracker3D.xcodeproj -scheme AirplaneTracker3D -configuration Debug -destination 'platform=macOS' 2>&1 | tail -5` -- must show BUILD SUCCEEDED with no errors. Verify all 3 new files compile and their types are accessible (no unresolved symbol errors).
  </verify>
  <done>
AircraftModel.swift, AircraftCategory.swift, and DataNormalizer.swift exist and compile. AltitudeValue correctly decodes both Int and "ground" string. AircraftCategory.classify() covers all 6 categories with 4-priority chain. DataNormalizer handles both V2 and dump1090 response formats.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create FlightDataActor with polling, fallback, interpolation buffer, and stale removal</name>
  <files>
    AirplaneTracker3D/DataLayer/FlightDataActor.swift
    AirplaneTracker3D.xcodeproj/project.pbxproj
  </files>
  <action>
Create `FlightDataActor.swift` implementing a Swift actor that manages the entire data pipeline:

**Actor state:**
- `enum DataMode { case local, global }` -- polling mode
- `struct Provider` with name: String, buildURL closure: (Double, Double, Int) -> URL, failCount: Int
- `providers` array initialized with airplanes.live (URL: `https://api.airplanes.live/v2/point/{lat}/{lon}/{radius}`) and adsb.lol (URL: `https://api.adsb.lol/v2/point/{lat}/{lon}/{radius}`)
- `dataBuffer: [String: [(timestamp: CFTimeInterval, data: AircraftModel)]]` -- per-aircraft time-windowed ring buffer
- `lastSeen: [String: CFTimeInterval]` -- tracks when each aircraft was last in an API response
- `currentMode: DataMode` -- current polling mode
- Constants: `interpolationDelay: CFTimeInterval = 2.0`, `localBufferWindow: CFTimeInterval = 5.0`, `globalBufferWindow: CFTimeInterval = 15.0`

**Public API:**
1. `func startPolling(mode: DataMode, center: (lat: Double, lon: Double)) -> AsyncStream<[String: AircraftModel]>` -- Creates an AsyncStream that:
   - Sets currentMode
   - Spawns a Task that loops: fetch -> updateBuffer -> yield latest -> sleep (1s local, 5s global)
   - continuation.onTermination cancels the task
   - Returns the stream

2. `func interpolatedStates(at renderTime: CFTimeInterval) -> [InterpolatedAircraftState]` -- Called each render frame by the renderer:
   - targetTime = renderTime - interpolationDelay
   - For each aircraft in dataBuffer: find surrounding data points (before/after targetTime), compute lerp factor t, interpolate lat/lon/altitude/heading using lerp and lerpAngle
   - Convert interpolated lat/lon to world-space via MapCoordinateSystem.shared.worldPosition(lat:lon:)
   - Convert altitude to world Y: `altitude * 0.001` (base scale, tunable)
   - Convert heading to radians
   - Classify category via AircraftCategory.classify()
   - Return array of InterpolatedAircraftState

3. `func switchMode(to mode: DataMode)` -- Allows mode switching (clears buffer, resets providers)

**Private methods:**
- `fetchWithFallback(mode:center:)` async -> [AircraftModel] -- For local: fetch dump1090 URL, decode Dump1090Response, normalize. For global: iterate providers, try each, decode ADSBV2Response, normalize, reset failCount on success, increment on failure, continue to next. Return empty array if all fail. Use `URLSession.shared.data(from:)`.
- `fetchLocal()` async -> [AircraftModel] -- Fetches from `http://localhost:8080/data/aircraft.json`, decodes as Dump1090Response.
- `updateBuffer(_ aircraft: [AircraftModel])` -- Timestamps each aircraft with CACurrentMediaTime(), appends to dataBuffer, updates lastSeen, trims old entries beyond buffer window, removes stale aircraft (not seen for > appropriate threshold: local 4s, global pollingInterval + delay + 2s = 9s).
- `latestAircraft() -> [String: AircraftModel]` -- Returns most recent entry per hex from dataBuffer.
- `lerp(_ a: Float, _ b: Float, _ t: Float) -> Float`
- `lerpAngle(_ a: Float, _ b: Float, _ t: Float) -> Float` -- Handles 360-degree wraparound per research pattern (normalize diff to [-180, 180]).

**Important implementation notes:**
- All URLSession calls use `try? await` with error handling that silently continues (no user-facing errors for network failures).
- The interpolation MUST happen in `interpolatedStates(at:)` which runs on the actor, NOT in the render loop directly. The renderer calls this actor method (via async) each frame. Use nonisolated if needed for render-thread performance, OR have the renderer cache the latest states.
- Actually, per research anti-pattern note: interpolation timing needs render-frame time. Best approach: the actor stores the raw buffer, and expose a `nonisolated func` or make InterpolatedAircraftState computation happen on the caller's thread by providing a thread-safe snapshot. Practical approach: have the actor provide a `getSnapshot() -> BufferSnapshot` (Sendable struct with the buffer data), and do interpolation on the render thread. OR: just call the actor method from a Task in the render loop and cache results. Use the simplest correct approach: store latest interpolated states in a `@MainActor var aircraftStates: [InterpolatedAircraftState] = []` property that gets updated by the polling loop, with interpolation happening inside the actor's yield cycle.

Simplest correct architecture:
- FlightDataActor's polling loop calls `interpolatedStates(at: CACurrentMediaTime())` before yielding
- The AsyncStream yields `[InterpolatedAircraftState]` directly (not raw AircraftModel)
- A `@MainActor` property on a lightweight `FlightDataManager` class (or on the Renderer directly) stores the latest states for the render loop to read synchronously

Actually, for smooth 60fps interpolation between polling intervals, we need interpolation at render frequency, not polling frequency. So:
- The actor stores the raw dataBuffer
- Expose `func getBufferSnapshot() -> [String: [(timestamp: CFTimeInterval, data: AircraftModel)]]` to get a Sendable copy
- The renderer (or an intermediary) calls this periodically (e.g., each poll) and runs interpolation each frame on its own thread using the snapshot + current frame time
- OR: Make the buffer data accessible via a `nonisolated` read by using `Mutex` or `OSAllocatedUnfairLock` for the buffer instead of actor isolation for the hot path

Best practical approach for this phase: Use a shared `@MainActor` class `FlightDataManager` that:
1. Owns the FlightDataActor
2. Consumes the AsyncStream on main actor
3. Stores the latest raw buffer snapshot (updated each poll)
4. Has a `func interpolatedStates(at: CFTimeInterval) -> [InterpolatedAircraftState]` that the Renderer calls each frame synchronously (this is fine since Renderer.draw runs on main thread via MTKViewDelegate)

Create this `FlightDataManager` class in the same file:
```swift
@MainActor
final class FlightDataManager {
    let actor: FlightDataActor
    private(set) var currentStates: [InterpolatedAircraftState] = []
    private var bufferSnapshot: [String: [(timestamp: CFTimeInterval, data: AircraftModel)]] = [:]
    private var pollingTask: Task<Void, Never>?

    init() { actor = FlightDataActor() }

    func startPolling(mode: FlightDataActor.DataMode, center: (lat: Double, lon: Double)) { ... }
    func stopPolling() { pollingTask?.cancel() }

    // Called by Renderer each frame in draw(in:)
    func interpolatedStates(at renderTime: CFTimeInterval) -> [InterpolatedAircraftState] {
        // Interpolate from bufferSnapshot using renderTime
        // This runs on main thread, which is fine for draw(in:)
    }
}
```

The polling loop Task iterates the AsyncStream, and each yield updates bufferSnapshot. The interpolation math (lerp, lerpAngle, coordinate conversion) lives here for render-frequency access.

Add FlightDataActor.swift to the Xcode project under the DataLayer group.
  </action>
  <verify>
Run `xcodebuild build -project AirplaneTracker3D.xcodeproj -scheme AirplaneTracker3D -configuration Debug -destination 'platform=macOS' 2>&1 | tail -5` -- must show BUILD SUCCEEDED. Verify FlightDataActor compiles with actor isolation, FlightDataManager compiles with @MainActor, AsyncStream type-checks, all Sendable conformances are correct with no concurrency warnings.
  </verify>
  <done>
FlightDataActor polls APIs with provider fallback (airplanes.live -> adsb.lol for global, dump1090 for local). FlightDataManager provides synchronous `interpolatedStates(at:)` for the render loop using time-windowed buffer with 2-second interpolation delay. Stale aircraft removed after appropriate timeout. Mode switching supported. lerpAngle handles 360-degree wraparound. All types are Sendable-correct.
  </done>
</task>

</tasks>

<verification>
1. `xcodebuild build` succeeds with no errors or concurrency warnings
2. All 4 new files exist in their respective directories (Models/, DataLayer/)
3. AltitudeValue correctly handles: `{"alt_baro": 35000}` (Int) and `{"alt_baro": "ground"}` (String)
4. AircraftCategory.classify() returns correct category for: military flag set, A7 category (helicopter), B738 type code (jet), slow low N-number (small)
5. DataNormalizer.normalizeV2() returns empty array for response with nil `ac` field
6. DataNormalizer.normalizeDump1090() maps `speed` to `groundSpeed` and `vert_rate` to `verticalRate`
7. FlightDataActor compiles as an actor with proper isolation
8. FlightDataManager provides synchronous interpolatedStates(at:) callable from MTKViewDelegate draw(in:)
</verification>

<success_criteria>
- BUILD SUCCEEDED with zero errors
- 4 new Swift files compile and are linked into the app target
- Data pipeline architecture is complete: poll -> normalize -> buffer -> interpolate -> render-ready states
- All Sendable/actor isolation is correct with no Swift concurrency warnings
</success_criteria>

<output>
After completion, create `.planning/phases/06-data-pipeline-aircraft-rendering/06-01-SUMMARY.md`
</output>
