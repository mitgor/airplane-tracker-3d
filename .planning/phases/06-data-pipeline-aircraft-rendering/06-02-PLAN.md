---
phase: 06-data-pipeline-aircraft-rendering
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - AirplaneTracker3D/Rendering/ShaderTypes.h
  - AirplaneTracker3D/Rendering/AircraftMeshLibrary.swift
  - AirplaneTracker3D/Rendering/AircraftInstanceManager.swift
  - AirplaneTracker3D/Rendering/AircraftShaders.metal
  - AirplaneTracker3D/Rendering/GlowShaders.metal
  - AirplaneTracker3D/Rendering/Renderer.swift
  - AirplaneTracker3D/ContentView.swift
  - AirplaneTracker3D.xcodeproj/project.pbxproj
autonomous: true

must_haves:
  truths:
    - "User sees 3D aircraft models on the map at correct geographic positions matching API data"
    - "User sees 6 distinct aircraft shapes: jet (cylinder fuselage + swept wings + 2 engines), widebody (larger + 4 engines), helicopter (sphere cabin + rotor blades), small prop (smaller fuselage + front propeller), military (delta wing + twin tails), regional (smaller jet)"
    - "User sees aircraft move smoothly at 60fps between API data updates with no teleporting"
    - "User sees aircraft colored by altitude gradient: green (low) -> yellow -> orange -> pink (high)"
    - "User sees glow sprites on aircraft with subtle pulsing animation"
    - "User sees blinking position lights (white strobe + red beacon) on each aircraft"
    - "User sees helicopter rotors and prop plane propellers spinning"
    - "Rendering maintains 60fps with 200+ aircraft via instanced draw calls (6 body + 2 spinning parts = 8 draw calls max)"
  artifacts:
    - path: "AirplaneTracker3D/Rendering/AircraftMeshLibrary.swift"
      provides: "Procedural vertex/index buffers for 6 aircraft categories plus separate rotor and propeller meshes"
      contains: "class AircraftMeshLibrary"
    - path: "AirplaneTracker3D/Rendering/AircraftInstanceManager.swift"
      provides: "Triple-buffered per-instance data buffers, per-frame update from InterpolatedAircraftState, category sorting, altitude coloring, animation timing"
      contains: "class AircraftInstanceManager"
    - path: "AirplaneTracker3D/Rendering/AircraftShaders.metal"
      provides: "aircraft_vertex (instanced with instance_id) and aircraft_fragment (directional lighting + position light blink + beacon) shaders"
      contains: "vertex AircraftVertexOut aircraft_vertex"
    - path: "AirplaneTracker3D/Rendering/GlowShaders.metal"
      provides: "glow_vertex (billboard quad) and glow_fragment (radial gradient with pulsing opacity) shaders"
      contains: "vertex GlowVertexOut glow_vertex"
    - path: "AirplaneTracker3D/Rendering/ShaderTypes.h"
      provides: "AircraftInstanceData struct (96 bytes), GlowInstanceData struct, AircraftVertex struct, extended BufferIndex enum"
      contains: "AircraftInstanceData"
    - path: "AirplaneTracker3D/Rendering/Renderer.swift"
      provides: "Aircraft and glow pipeline states, encodeAircraft() and encodeGlow() methods, FlightDataManager integration in draw loop"
      contains: "encodeAircraft"
  key_links:
    - from: "AirplaneTracker3D/Rendering/Renderer.swift"
      to: "AirplaneTracker3D/DataLayer/FlightDataActor.swift"
      via: "FlightDataManager.interpolatedStates(at:) called each frame in draw(in:)"
      pattern: "flightDataManager\\.interpolatedStates"
    - from: "AirplaneTracker3D/Rendering/AircraftInstanceManager.swift"
      to: "AirplaneTracker3D/Rendering/AircraftMeshLibrary.swift"
      via: "meshLibrary.mesh(for: category) to get vertex/index buffers per draw call"
      pattern: "meshLibrary\\.mesh"
    - from: "AirplaneTracker3D/Rendering/AircraftShaders.metal"
      to: "AirplaneTracker3D/Rendering/ShaderTypes.h"
      via: "AircraftInstanceData struct accessed via instances[instanceID]"
      pattern: "instances\\[instanceID\\]"
    - from: "AirplaneTracker3D/Rendering/Renderer.swift"
      to: "AirplaneTracker3D/Rendering/AircraftInstanceManager.swift"
      via: "instanceManager.update() then instanceManager.encode() each frame"
      pattern: "instanceManager\\."
    - from: "AirplaneTracker3D/ContentView.swift"
      to: "AirplaneTracker3D/DataLayer/FlightDataActor.swift"
      via: "FlightDataManager initialized and polling started on appear"
      pattern: "flightDataManager\\.startPolling"
---

<objective>
Build the Metal instanced rendering pipeline for aircraft: procedural 3D geometry for 6 categories, per-instance GPU buffers with altitude coloring and animation data, aircraft body + glow sprite + spinning parts shaders, and integration with the FlightDataManager from plan 06-01 so live aircraft appear on the map with smooth movement.

Purpose: This transforms raw flight data into visible 3D aircraft on the map. Instanced rendering (6-8 draw calls total regardless of aircraft count) is critical for 60fps with 200+ aircraft. The visual effects (altitude color, glow, blinking lights, spinning rotors) make aircraft visually distinct and alive.

Output: 4 new rendering files (AircraftMeshLibrary, AircraftInstanceManager, AircraftShaders.metal, GlowShaders.metal), modified ShaderTypes.h, modified Renderer.swift, modified ContentView.swift, plus Xcode project updates. The app will show live aircraft on the map.
</objective>

<execution_context>
@/Users/mit/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mit/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-data-pipeline-aircraft-rendering/06-RESEARCH.md
@.planning/phases/06-data-pipeline-aircraft-rendering/06-01-SUMMARY.md
@AirplaneTracker3D/Rendering/Renderer.swift
@AirplaneTracker3D/Rendering/ShaderTypes.h
@AirplaneTracker3D/Rendering/Shaders.metal
@AirplaneTracker3D/Map/MapCoordinateSystem.swift
@AirplaneTracker3D.xcodeproj/project.pbxproj
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend ShaderTypes.h, create procedural aircraft meshes, and write aircraft + glow shaders</name>
  <files>
    AirplaneTracker3D/Rendering/ShaderTypes.h
    AirplaneTracker3D/Rendering/AircraftMeshLibrary.swift
    AirplaneTracker3D/Rendering/AircraftShaders.metal
    AirplaneTracker3D/Rendering/GlowShaders.metal
    AirplaneTracker3D.xcodeproj/project.pbxproj
  </files>
  <action>
**ShaderTypes.h** -- Extend the existing file with new types. Keep all existing types. Add:

1. `AircraftVertex` struct: position (simd_float3), normal (simd_float3). This is the vertex format for aircraft meshes.

2. `AircraftInstanceData` struct (96 bytes total, GPU-aligned):
   - modelMatrix: simd_float4x4 (64 bytes) -- position + heading rotation
   - color: simd_float4 (16 bytes) -- altitude-based RGBA
   - lightPhase: float (4 bytes) -- position light animation phase
   - glowIntensity: float (4 bytes) -- glow sprite pulse value (0.15-0.45 range)
   - rotorAngle: float (4 bytes) -- rotor/propeller rotation angle (radians)
   - flags: uint32_t (4 bytes) -- bitfield (bit 0 = selected)

3. `GlowInstanceData` struct:
   - position: simd_float3 (+ padding to 16 bytes)
   - color: simd_float4
   - size: float
   - opacity: float
   - padding to align to 48 bytes

4. Extend `BufferIndex` enum with new entries:
   - BufferIndexInstances = 3 (per-instance aircraft data)
   - BufferIndexGlowInstances = 4 (per-instance glow data)

**AircraftMeshLibrary.swift** -- Create procedural geometry for all 6 categories:

Structure:
```swift
struct AircraftMesh {
    let vertexBuffer: MTLBuffer
    let indexBuffer: MTLBuffer
    let vertexCount: Int
    let indexCount: Int
}

class AircraftMeshLibrary {
    private var bodyMeshes: [AircraftCategory: AircraftMesh] = [:]
    private(set) var rotorMesh: AircraftMesh?      // helicopter main + tail rotors
    private(set) var propellerMesh: AircraftMesh?   // small prop propeller

    init(device: MTLDevice) { ... }
    func mesh(for category: AircraftCategory) -> AircraftMesh { ... }
}
```

Geometry generation helpers (private methods):
- `appendCylinder(vertices:indices:radius:height:segments:offset:)` -- generates cylinder around Y axis, default 8 segments
- `appendCone(vertices:indices:radius:height:segments:offset:)` -- cone pointing along Z axis
- `appendBox(vertices:indices:size:offset:)` -- box centered at offset
- `appendSphere(vertices:indices:radius:segments:offset:)` -- UV sphere, 8 segments
- Each helper appends to vertices/indices arrays and computes normals per-face

Category mesh specs from research (all dimensions in world units, centered at origin, nose pointing +Z):
- **Jet**: Cylinder fuselage (r=0.4, h=4), Cone nose (r=0.4, h=1.2, offset z+2.6), Box wings (5x0.15x1.5), Box vertical tail (0.15x1.2x1, offset y+0.6 z-1.5), Box h-stab (2x0.1x0.6, offset y+0.6 z-1.8), 2x Cylinder engines (r=0.25, h=0.8, offset x+-1.5 y-0.3 z+0.5)
- **Widebody**: Same structure as jet but larger -- fuselage r=0.7 h=5.5, cone r=0.7 h=1.5, wings 8x0.2x2.2, 4 engines at x+-2.5 and x+-1.2
- **Helicopter**: Sphere cabin (r=0.6), Cylinder tail boom (r=0.15, h=2.5, offset z-1.5), Box skids (2 at x+-0.5 y-0.5). Rotors are SEPARATE mesh.
- **Small**: Cylinder fuselage (r=0.25, h=2.5), Cone nose (r=0.3, h=0.6), Box wings (4x0.08x0.8), Box tail. Propeller is SEPARATE mesh.
- **Military**: Box fuselage (0.6x0.4x4.5), Cone nose (r=0.35, h=1.2), Triangle delta wings (create as thin box with angled vertices, span 6, chord 3), 2x angled Box tails
- **Regional**: Same as jet but 0.8x scale

Separate meshes:
- **rotorMesh**: 2 long thin boxes (6x0.05x0.2) crossed at 90 degrees for main rotor + 1 small box (0.05x1.2x0.15) for tail rotor offset to match helicopter tail boom
- **propellerMesh**: 1 thin box (0.08x1.2x0.08) at the nose position

After generating vertices/indices for each, create MTLBuffers via `device.makeBuffer(bytes:length:options:.storageModeShared)`.

**AircraftShaders.metal** -- New file with:

1. `aircraft_vertex` function:
   - Inputs: AircraftVertex via stage_in, Uniforms buffer, AircraftInstanceData* buffer, instance_id
   - Transform vertex position by instance modelMatrix
   - Transform normal by modelMatrix (xyz, w=0)
   - Output: position (projected), worldNormal, worldPosition, color, lightPhase, flags

2. `aircraft_fragment` function:
   - Simple directional lighting: lightDir = normalize(0.5, 1.0, 0.5), diffuse = max(dot(normal, lightDir), 0), ambient = 0.3, lighting = ambient + diffuse * 0.7
   - White strobe: step(0.7, sin(lightPhase)) * 0.2
   - Red beacon: step(0.5, sin(lightPhase * 0.6)) * 0.15
   - Selection highlight: if flags & 1, mix with gold (1.0, 0.8, 0.0) at 0.3
   - Output float4(litColor, 1.0)

**GlowShaders.metal** -- New file with:

1. `glow_vertex` function:
   - Billboard quad using 6 vertices (2 triangles) generated from vertexID
   - Extract camera right/up from viewMatrix columns
   - World position = instance center + camRight * corner.x * size + camUp * corner.y * size
   - Output projected position, texCoord (0-1 UV), color, opacity

2. `glow_fragment` function:
   - Sample glow texture at texCoord
   - Multiply texture alpha by instance opacity
   - Output float4(color.rgb * texAlpha, texAlpha) for additive blending

Also create a 64x64 glow texture generation function in AircraftMeshLibrary (or a helper):
- `static func createGlowTexture(device: MTLDevice) -> MTLTexture` -- radial gradient: bright center (alpha=1 at dist<0.3), falloff (alpha fades 0.3-0.7), transparent edge (alpha~0 at dist>1.0). White RGB, variable alpha.

Add all new files to Xcode project pbxproj.
  </action>
  <verify>
Run `xcodebuild build -project AirplaneTracker3D.xcodeproj -scheme AirplaneTracker3D -configuration Debug -destination 'platform=macOS' 2>&1 | tail -5` -- must show BUILD SUCCEEDED. Metal shader compilation must succeed (no MSL errors). Verify AircraftMeshLibrary initializes and creates buffers for all 6 categories.
  </verify>
  <done>
ShaderTypes.h extended with AircraftInstanceData (96 bytes), GlowInstanceData, AircraftVertex, new buffer indices. AircraftMeshLibrary generates procedural geometry for 6 categories plus separate rotor and propeller meshes. AircraftShaders.metal compiles with instanced vertex/fragment pair including lighting and position light animation. GlowShaders.metal compiles with billboard vertex and radial glow fragment. Glow texture generated programmatically.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create instance manager, integrate rendering pipeline with data manager, wire into Renderer draw loop</name>
  <files>
    AirplaneTracker3D/Rendering/AircraftInstanceManager.swift
    AirplaneTracker3D/Rendering/Renderer.swift
    AirplaneTracker3D/ContentView.swift
    AirplaneTracker3D.xcodeproj/project.pbxproj
  </files>
  <action>
**AircraftInstanceManager.swift** -- Manages per-instance GPU buffers and populates them each frame:

```swift
class AircraftInstanceManager {
    private let device: MTLDevice
    private let meshLibrary: AircraftMeshLibrary

    // Triple-buffered instance buffers (matches Renderer's triple buffering)
    private var instanceBuffers: [MTLBuffer]    // AircraftInstanceData
    private var glowBuffers: [MTLBuffer]        // GlowInstanceData
    private var spinBuffers: [MTLBuffer]        // AircraftInstanceData for spinning parts

    // Per-frame state
    struct CategoryRange { var offset: Int; var count: Int }
    private(set) var categoryRanges: [AircraftCategory: CategoryRange] = [:]
    private(set) var totalAircraftCount: Int = 0
    private(set) var helicopterCount: Int = 0
    private(set) var propCount: Int = 0

    // Animation state (persistent across frames)
    private var lightPhases: [String: Float] = [:]  // per-aircraft hex -> phase

    let maxInstances = 1024  // pre-allocated capacity

    init(device: MTLDevice, meshLibrary: AircraftMeshLibrary) { ... }
}
```

Key methods:
1. `func update(states: [InterpolatedAircraftState], bufferIndex: Int, deltaTime: Float, time: Float)`:
   - Sort states by category for instanced batching
   - Compute categoryRanges (offset + count per category)
   - For each aircraft, populate AircraftInstanceData in instanceBuffers[bufferIndex]:
     - modelMatrix: translate to position, rotate around Y by heading
     - color: altitudeColor(altitude) using the green->yellow->orange->pink gradient from research
     - lightPhase: advance per-aircraft lightPhase by deltaTime * 5.0 (store in lightPhases dict by hex)
     - glowIntensity: 0.3 + 0.15 * sin(lightPhase * 0.5)
     - rotorAngle: for helicopters, advance by deltaTime * 0.7 * 2 * .pi; for small props, similar
     - flags: 0 (selection not yet implemented)
   - For each aircraft, populate GlowInstanceData in glowBuffers[bufferIndex]:
     - position: same as aircraft world position + small Y offset
     - color: same altitude color
     - size: 7.0 + 1.5 * sin(lightPhase * 0.3)
     - opacity: glowIntensity value
   - For helicopters: populate spinBuffers with rotor model matrix (aircraft position + rotorAngle rotation around Y axis)
   - For small props: populate spinBuffers with propeller model matrix (aircraft position + nose offset + rotorAngle rotation around Z axis)
   - Track helicopter/prop counts for draw calls

2. `altitudeColor(_ altitude: Float) -> SIMD4<Float>` -- from research: green <5000, green->yellow 5000-15000, yellow->orange 15000-30000, pink >30000

3. Buffer accessors: `func instanceBuffer(at index: Int) -> MTLBuffer`, `func glowBuffer(at index: Int) -> MTLBuffer`, `func spinBuffer(at index: Int) -> MTLBuffer`

**Renderer.swift** -- Modify the existing renderer to add aircraft rendering:

New properties:
- `let aircraftPipeline: MTLRenderPipelineState` -- for aircraft body rendering
- `let glowPipeline: MTLRenderPipelineState` -- for glow sprites (additive blend)
- `let spinPipeline: MTLRenderPipelineState` -- same as aircraftPipeline but for spinning parts
- `let glowDepthStencilState: MTLDepthStencilState` -- depth read but no write for additive glow
- `let meshLibrary: AircraftMeshLibrary`
- `let instanceManager: AircraftInstanceManager`
- `let glowTexture: MTLTexture`
- `var flightDataManager: FlightDataManager?` -- set externally after init

In init(metalView:), add pipeline creation:
- Aircraft pipeline: vertex function "aircraft_vertex", fragment function "aircraft_fragment"
  - Vertex descriptor: attribute 0 = float3 position, attribute 1 = float3 normal
  - Layout for BufferIndexVertices: stride = MemoryLayout<AircraftVertex>.stride (from the C struct, 32 bytes with padding), stepFunction .perVertex
  - Layout for BufferIndexInstances: stride = 96 (AircraftInstanceData), stepFunction .perInstance, stepRate 1
  - Standard depth, MSAA sample count, opaque blending
- Glow pipeline: vertex function "glow_vertex", fragment function "glow_fragment"
  - No vertex descriptor needed (vertices generated from vertexID)
  - Additive blending: isBlendingEnabled=true, rgbBlendOp=.add, sourceRGB=.sourceAlpha, destRGB=.one, sourceAlpha=.sourceAlpha, destAlpha=.one
  - Depth read but no write (glowDepthStencilState: depthCompare .lessEqual, isDepthWriteEnabled false)
  - MSAA sample count matching metalView
- Spin pipeline: same as aircraft pipeline (reuse vertex/fragment functions)
- Create glowTexture via AircraftMeshLibrary.createGlowTexture()

In draw(in:), AFTER tile rendering and BEFORE encoder.endEncoding():
1. Get interpolated states: `let states = flightDataManager?.interpolatedStates(at: CACurrentMediaTime()) ?? []`
2. Update instance manager: `instanceManager.update(states: states, bufferIndex: currentBufferIndex, deltaTime: deltaTime, time: Float(now))`
3. Encode aircraft bodies (encodeAircraft method):
   - Set aircraftPipeline
   - Set uniforms buffer at index 0
   - For each category with count > 0:
     - Set category mesh vertexBuffer at BufferIndexVertices
     - Set instanceBuffer at BufferIndexInstances with offset = categoryRange.offset * stride
     - drawIndexedPrimitives(type: .triangle, indexCount, indexType: .uint16, indexBuffer, offset: 0, instanceCount: range.count)
4. Encode spinning parts (encodeSpinningParts method):
   - Set spinPipeline (same shader)
   - Draw rotor mesh instanced with helicopter count
   - Draw propeller mesh instanced with prop count
5. Encode glow sprites (encodeGlow method):
   - Set glowPipeline
   - Set glowDepthStencilState
   - Set uniforms buffer
   - Set glowBuffer at BufferIndexGlowInstances
   - Set glowTexture at fragment texture index 0
   - drawPrimitives(type: .triangle, vertexStart: 0, vertexCount: 6, instanceCount: totalAircraftCount)
   - Restore original depthStencilState after glow pass

**ContentView.swift** -- Modify to initialize FlightDataManager and wire to Renderer:
- Add `@State private var flightDataManager = FlightDataManager()` (or use @StateObject if needed)
- In the MetalView's onAppear (or via a Coordinator callback), set `renderer.flightDataManager = flightDataManager`
- Call `flightDataManager.startPolling(mode: .global, center: (lat: 47.6, lon: -122.3))` on appear
- The center coordinates should match MapCoordinateSystem.shared.centerLat/centerLon

Note: The MetalView NSViewRepresentable pattern means the Renderer is created in the Coordinator. Access the coordinator to set the flightDataManager. One approach: pass flightDataManager as a binding or parameter to MetalView, and set it on the Renderer in makeNSView or updateNSView.

Add AircraftInstanceManager.swift to Xcode project.
  </action>
  <verify>
1. Run `xcodebuild build -project AirplaneTracker3D.xcodeproj -scheme AirplaneTracker3D -configuration Debug -destination 'platform=macOS' 2>&1 | tail -5` -- must show BUILD SUCCEEDED.
2. Run the built app briefly to verify it launches without crashing: `timeout 10 open -a "$(find ~/Library/Developer/Xcode/DerivedData -name 'AirplaneTracker3D.app' -maxdepth 4 2>/dev/null | head -1)" 2>/dev/null || echo "App launch check skipped"` -- no crash on startup.
3. Verify the render loop integrates data polling: grep for "flightDataManager" in Renderer.swift and "interpolatedStates" call in draw(in:).
  </verify>
  <done>
AircraftInstanceManager populates triple-buffered instance data from InterpolatedAircraftState array with altitude coloring, animation phases, and spinning part transforms. Renderer has 3 new pipeline states (aircraft, glow with additive blend, spin), encodes instanced draw calls per category (6 body + 2 spinning = 8 max), and reads FlightDataManager's interpolated states each frame. ContentView initializes FlightDataManager with global polling mode targeting Seattle center coordinates. App builds, launches, and begins polling ADS-B APIs to render aircraft on the map.
  </done>
</task>

</tasks>

<verification>
1. `xcodebuild build` succeeds with no errors
2. App launches and shows map tiles (existing Phase 5 functionality preserved)
3. After 5 seconds, aircraft begin appearing on the map at correct geographic positions
4. Aircraft are colored by altitude (green low, pink high)
5. Aircraft move smoothly between data updates (no teleporting)
6. Position lights blink and glow sprites pulse subtly
7. Different aircraft categories show distinct geometry (jet vs helicopter vs small prop)
8. Frame rate stays at 60fps with aircraft visible (check via Xcode GPU profiler or visual smoothness)
</verification>

<success_criteria>
- BUILD SUCCEEDED with zero errors
- 5 new files + 3 modified files all compile and link
- Live aircraft from airplanes.live API appear on the Metal map within 5 seconds of launch
- Aircraft positions match real-world geography (aircraft over Seattle visible near map center)
- Smooth 60fps interpolated movement between 5-second API polling intervals
- 6 distinct aircraft model shapes rendered via instanced draw calls
- Altitude color gradient, glow sprites, and blinking position lights all visible
- Helicopter rotors and prop plane propellers spin
</success_criteria>

<output>
After completion, create `.planning/phases/06-data-pipeline-aircraft-rendering/06-02-SUMMARY.md`
</output>
