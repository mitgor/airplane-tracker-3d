---
phase: 07-trails-labels-selection
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - AirplaneTracker3D/Rendering/ShaderTypes.h
  - AirplaneTracker3D/Rendering/TrailShaders.metal
  - AirplaneTracker3D/Rendering/TrailManager.swift
  - AirplaneTracker3D/Rendering/Renderer.swift
  - AirplaneTracker3D.xcodeproj/project.pbxproj
autonomous: true

must_haves:
  truths:
    - "User sees flight trails behind each moving aircraft as colored polylines"
    - "Trail color reflects altitude gradient (green low, yellow mid, orange/pink high) matching aircraft body color"
    - "Trails have visible width greater than 1px rendered via screen-space triangle strip extrusion"
    - "Trail length is bounded to a configurable maximum (default 500 points, range 50-4000)"
  artifacts:
    - path: "AirplaneTracker3D/Rendering/TrailShaders.metal"
      provides: "Screen-space polyline extrusion vertex shader and trail fragment shader"
      contains: "trail_vertex"
    - path: "AirplaneTracker3D/Rendering/TrailManager.swift"
      provides: "Per-aircraft ring buffers, GPU vertex buffer management, altitude color mapping"
      min_lines: 100
    - path: "AirplaneTracker3D/Rendering/ShaderTypes.h"
      provides: "TrailVertex struct with position, color, prevPosition, nextPosition, direction"
      contains: "TrailVertex"
    - path: "AirplaneTracker3D/Rendering/Renderer.swift"
      provides: "Trail pipeline state, encodeTrails method, trail rendering in draw loop"
      contains: "encodeTrails"
  key_links:
    - from: "AirplaneTracker3D/Rendering/Renderer.swift"
      to: "TrailManager"
      via: "trailManager.update() called each frame with interpolated states"
      pattern: "trailManager\\.update"
    - from: "AirplaneTracker3D/Rendering/TrailManager.swift"
      to: "InterpolatedAircraftState"
      via: "Consumes positions and altitudes from interpolated states each frame"
      pattern: "InterpolatedAircraftState"
    - from: "AirplaneTracker3D/Rendering/TrailShaders.metal"
      to: "ShaderTypes.h"
      via: "Uses TrailVertex struct for vertex data layout"
      pattern: "TrailVertex"
---

<objective>
Implement GPU-rendered flight trails behind each aircraft using screen-space polyline extrusion with per-vertex altitude color gradient.

Purpose: Trails let users trace flight paths visually, providing spatial context and movement history. This is the core visual feature of flight tracking.
Output: TrailManager.swift, TrailShaders.metal, updated ShaderTypes.h and Renderer.swift with trail rendering pipeline.
</objective>

<execution_context>
@/Users/mit/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mit/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-trails-labels-selection/07-RESEARCH.md

@AirplaneTracker3D/Rendering/Renderer.swift
@AirplaneTracker3D/Rendering/ShaderTypes.h
@AirplaneTracker3D/Rendering/GlowShaders.metal
@AirplaneTracker3D/Rendering/AircraftInstanceManager.swift
@AirplaneTracker3D/Models/AircraftModel.swift
@AirplaneTracker3D/DataLayer/FlightDataActor.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Trail data structures, ring buffer manager, and GPU buffer management</name>
  <files>
    AirplaneTracker3D/Rendering/ShaderTypes.h
    AirplaneTracker3D/Rendering/TrailManager.swift
  </files>
  <action>
**ShaderTypes.h additions:**

Add a new buffer index `BufferIndexTrailVertices = 5` to the BufferIndex enum.

Add the TrailVertex struct (must be C-compatible, GPU-aligned):
```c
typedef struct {
    simd_float3 position;       // World position (12 bytes)
    float direction;            // +1 or -1 (which side of the strip) (4 bytes)
    simd_float4 color;          // Altitude-based color per-vertex (16 bytes)
    simd_float3 prevPosition;   // Previous point for direction calc (12 bytes)
    float _pad0;                // Padding (4 bytes)
    simd_float3 nextPosition;   // Next point for direction calc (12 bytes)
    float _pad1;                // Padding (4 bytes)
} TrailVertex;
// Total: 64 bytes, naturally aligned
```

**TrailManager.swift:**

Create a new class `TrailManager` that manages per-aircraft trail point ring buffers and produces GPU vertex data.

Key structures:
- `TrailPoint`: position (SIMD3<Float>), altitude (Float) -- stored per point
- `TrailRingBuffer`: fixed-capacity array of TrailPoints per aircraft, append-only with trim to maxLength
- `TrailManager`: holds `[String: TrailRingBuffer]` keyed by hex, plus triple-buffered MTLBuffers for GPU data

Properties:
- `maxTrailLength: Int = 500` (configurable, range 50-4000)
- `lineWidth: Float = 3.0` (configurable)
- `trailBuffers: [MTLBuffer]` -- triple-buffered, one per frame-in-flight
- `trailVertexCounts: [Int]` -- how many vertices written per frame buffer
- Private `trails: [String: TrailRingBuffer]` dictionary

Init: Takes `device: MTLDevice`. Pre-allocate each trail buffer to hold `maxAircraft(1024) * maxTrailLength * 2 * MemoryLayout<TrailVertex>.stride` bytes. Label them "Trail Vertex Buffer N".

`update(states:bufferIndex:)` method:
1. For each InterpolatedAircraftState, append its position + altitude to the ring buffer for that hex. Skip if position is essentially the same as the last point (distance < 0.1 world units) to avoid degenerate zero-length segments.
2. Remove trail ring buffers for aircraft no longer in the states array (stale cleanup, but only if missing for 3+ consecutive calls -- use a `missCount: [String: Int]` dictionary).
3. Flatten all trail ring buffers into the GPU vertex buffer at `bufferIndex`:
   - For each aircraft trail with >= 2 points, generate 2 TrailVertex entries per point (direction = +1 and -1).
   - For each point, set prevPosition to the point before it (or itself for the first point), nextPosition to the point after (or itself for the last point).
   - Color each vertex using the same altitude color gradient as AircraftInstanceManager.altitudeColor() -- replicate that function here or extract it to a shared utility. Green(low) -> Yellow -> Orange -> Pink(high).
   - Track total vertex count written to `trailVertexCounts[bufferIndex]`.

`trailBuffer(at:) -> MTLBuffer` accessor.
`trailVertexCount(at:) -> Int` accessor.

Important: The trail is drawn as a triangle strip. The vertex ordering is: for point i, emit vertex at direction=+1 then direction=-1. This creates the strip topology. Between aircraft trails, insert a degenerate triangle (repeat last vertex of previous trail and first vertex of next trail) to break the strip.

Altitude color gradient function (same as AircraftInstanceManager):
- altitude < 5000: green RGBA(0.2, 0.8, 0.2, 1.0)
- 5000-15000: green to yellow
- 15000-30000: yellow to orange
- 30000+: orange to pink
- Alpha should fade from 1.0 (newest) to 0.3 (oldest) along the trail length for a fading tail effect.
  </action>
  <verify>
Build succeeds with `xcodebuild build -project AirplaneTracker3D.xcodeproj -scheme AirplaneTracker3D -destination 'platform=macOS' 2>&1 | tail -5`. ShaderTypes.h TrailVertex is 64 bytes (check with `MemoryLayout<TrailVertex>.stride` in code). TrailManager allocates buffers without crash.
  </verify>
  <done>TrailManager.swift exists with ring buffer management, GPU buffer triple-buffering, altitude color gradient, and degenerate strip breaks. ShaderTypes.h has TrailVertex struct and BufferIndexTrailVertices enum value. Build succeeds.</done>
</task>

<task type="auto">
  <name>Task 2: Trail Metal shaders, pipeline state, and Renderer integration</name>
  <files>
    AirplaneTracker3D/Rendering/TrailShaders.metal
    AirplaneTracker3D/Rendering/Renderer.swift
    AirplaneTracker3D.xcodeproj/project.pbxproj
  </files>
  <action>
**TrailShaders.metal:**

Create the trail vertex and fragment shaders. Include ShaderTypes.h.

Vertex output struct `TrailVertexOut`:
- `float4 position [[position]]`
- `float4 color`

Vertex shader `trail_vertex`:
- Inputs: `uint vertexID [[vertex_id]]`, `constant TrailVertex *vertices [[buffer(BufferIndexTrailVertices)]]`, `constant Uniforms &uniforms [[buffer(BufferIndexUniforms)]]`, `constant float &lineWidth [[buffer(BufferIndexModelMatrix)]]` (reuse buffer index 2 for the float lineWidth -- it's a single float, not a matrix, for this pass), `constant float2 &resolution [[buffer(BufferIndexInstances)]]` (reuse buffer index 3 for resolution).
- Actually, to avoid confusion, use explicit integer indices: buffer(0) for uniforms, buffer(1) for trail vertices, buffer(2) for lineWidth float, buffer(3) for resolution float2. The BufferIndex enum values are for Swift-side binding, and the trail pass can use its own index assignment. But for consistency, bind uniforms at BufferIndexUniforms (0), trail vertices at BufferIndexTrailVertices (5), lineWidth at BufferIndexModelMatrix (2), resolution at BufferIndexInstances (3). This is fine since the trail pass has its own encoder state and these indices don't conflict.
- Algorithm:
  1. Read TrailVertex at vertexID
  2. Project position, prevPosition, nextPosition to clip space using `uniforms.projectionMatrix * uniforms.viewMatrix * float4(pos, 1.0)`
  3. Convert to NDC: `clip.xy / clip.w`
  4. Compute direction in NDC: `normalize(ndcNext - ndcPrev)` (handle prev==current or next==current by using current->next or prev->current respectively)
  5. Compute perpendicular normal: `float2(-dir.y, dir.x)`
  6. Offset clip position: `clipCurrent.xy += normal * vertex.direction * lineWidth / resolution * clipCurrent.w`
  7. Pass through color to fragment

Fragment shader `trail_fragment`:
- Simply returns the interpolated color. No texture sampling needed.

**Renderer.swift modifications:**

Add properties:
- `let trailManager: TrailManager`
- `let trailPipeline: MTLRenderPipelineState`
- `private let lineWidthBuffer: MTLBuffer` (holds a single Float)
- `private let resolutionBuffer: MTLBuffer` (holds SIMD2<Float>)

In init:
- Create `trailManager = TrailManager(device: device)`
- Create trail pipeline state: no vertex descriptor needed (reading raw buffer by vertexID). Set vertex function to "trail_vertex", fragment to "trail_fragment". Enable alpha blending (source alpha, one minus source alpha) on color attachment 0 since trails have fading alpha. Set depth attachment format, sample count, rasterSampleCount to match metalView.
- Create lineWidthBuffer: `device.makeBuffer(length: MemoryLayout<Float>.stride, options: .storageModeShared)`, write 3.0 as default.
- Create resolutionBuffer: `device.makeBuffer(length: MemoryLayout<SIMD2<Float>>.stride, options: .storageModeShared)`.

Add `encodeTrails(encoder:uniformBuffer:drawableSize:)` method:
1. Guard `trailManager.trailVertexCount(at: currentBufferIndex) > 0`
2. Set pipeline state to trailPipeline
3. Set depth stencil to glowDepthStencilState (depth-read, no-write -- trails are semi-transparent)
4. Bind uniformBuffer at BufferIndexUniforms
5. Bind trailManager.trailBuffer(at: currentBufferIndex) at BufferIndexTrailVertices (index 5)
6. Update lineWidthBuffer with trailManager.lineWidth, bind at index 2
7. Update resolutionBuffer with drawableSize as SIMD2<Float>, bind at index 3
8. drawPrimitives type: .triangleStrip, vertexStart: 0, vertexCount: trailManager.trailVertexCount(at: currentBufferIndex)
9. Restore depthStencilState after encoding

In draw(in:) method, after the `instanceManager.update(states:...)` call and BEFORE encodeAircraft:
- Call `trailManager.update(states: states, bufferIndex: currentBufferIndex)`
- After encodeSpinningParts (and before encodeGlow), call `encodeTrails(encoder: encoder, uniformBuffer: uniformBuffer, drawableSize: drawableSize)`

Render order becomes: tiles -> aircraft bodies -> spinning parts -> trails -> glow sprites. Trails render after aircraft bodies so they appear behind/under the aircraft mesh, and before glow so glow blends on top.

**Xcode project:**
Add TrailShaders.metal and TrailManager.swift to the Xcode project's AirplaneTracker3D target. Use the `ruby` or `sed` approach from prior phases to insert file references and build phase entries into project.pbxproj. The files go in the Rendering group.
  </action>
  <verify>
Build succeeds with `xcodebuild build -project AirplaneTracker3D.xcodeproj -scheme AirplaneTracker3D -destination 'platform=macOS' 2>&1 | tail -5`. Run the app and verify trails appear behind moving aircraft as colored polylines with visible width. Verify trails fade from opaque (newest) to semi-transparent (oldest).
  </verify>
  <done>Trail rendering pipeline is complete: TrailShaders.metal compiles, Renderer creates trail pipeline state and calls encodeTrails each frame, trails appear behind aircraft with altitude-based color gradient and configurable width. Both new files are registered in the Xcode project.</done>
</task>

</tasks>

<verification>
- App builds without errors or warnings related to trail code
- Trails render as visible-width colored polylines behind moving aircraft
- Trail colors match altitude gradient (green at ground level, progressing through yellow/orange/pink at high altitude)
- Trails do not flicker, have no visual artifacts from degenerate segments
- Frame rate remains at 60fps with 200+ aircraft and 500-point trails
- Trail length does not grow beyond maxTrailLength
</verification>

<success_criteria>
Flight trails render behind each aircraft with per-vertex altitude color gradient. Trails have configurable width (default 3px screen-space) and configurable length (default 500 points, max 4000). Trail rendering uses screen-space polyline extrusion in the vertex shader with triangle strip topology. Trail buffers are triple-buffered matching the existing scheme.
</success_criteria>

<output>
After completion, create `.planning/phases/07-trails-labels-selection/07-01-SUMMARY.md`
</output>
