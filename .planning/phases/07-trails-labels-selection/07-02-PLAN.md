---
phase: 07-trails-labels-selection
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - AirplaneTracker3D/Rendering/ShaderTypes.h
  - AirplaneTracker3D/Rendering/LabelShaders.metal
  - AirplaneTracker3D/Rendering/AltitudeLineShaders.metal
  - AirplaneTracker3D/Rendering/LabelManager.swift
  - AirplaneTracker3D/Rendering/SelectionManager.swift
  - AirplaneTracker3D/Rendering/Renderer.swift
  - AirplaneTracker3D/Rendering/MetalView.swift
  - AirplaneTracker3D/DataLayer/EnrichmentService.swift
  - AirplaneTracker3D/Views/AircraftDetailPanel.swift
  - AirplaneTracker3D/Camera/OrbitCamera.swift
  - AirplaneTracker3D/ContentView.swift
  - AirplaneTracker3D/Models/AircraftModel.swift
  - AirplaneTracker3D.xcodeproj/project.pbxproj
autonomous: true

must_haves:
  truths:
    - "User sees billboard text labels above each aircraft showing callsign and altitude"
    - "Labels fade or hide at distance (LOD) so close aircraft are labeled, distant ones are not"
    - "User sees dashed altitude reference lines from each aircraft down to the ground plane"
    - "User can click an aircraft to select it and see a detail panel slide in from the right"
    - "Detail panel shows callsign, altitude, speed, heading, squawk, position, plus enrichment data (registration, type, operator, route)"
    - "User can follow a selected aircraft and the camera smoothly tracks it"
  artifacts:
    - path: "AirplaneTracker3D/Rendering/LabelShaders.metal"
      provides: "Billboard label vertex/fragment shaders sampling text texture atlas"
      contains: "label_vertex"
    - path: "AirplaneTracker3D/Rendering/AltitudeLineShaders.metal"
      provides: "Dashed vertical line vertex/fragment shaders"
      contains: "altline_vertex"
    - path: "AirplaneTracker3D/Rendering/LabelManager.swift"
      provides: "CoreText label rasterization to texture atlas, billboard instance buffer management"
      min_lines: 100
    - path: "AirplaneTracker3D/Rendering/SelectionManager.swift"
      provides: "Ray-sphere picking, selection state, follow mode coordination"
      min_lines: 50
    - path: "AirplaneTracker3D/DataLayer/EnrichmentService.swift"
      provides: "hexdb.io and adsbdb.com API integration with caching"
      min_lines: 60
    - path: "AirplaneTracker3D/Views/AircraftDetailPanel.swift"
      provides: "SwiftUI detail panel for selected aircraft"
      min_lines: 50
    - path: "AirplaneTracker3D/Camera/OrbitCamera.swift"
      provides: "Follow target property with smooth lerp tracking"
      contains: "followTarget"
  key_links:
    - from: "AirplaneTracker3D/Rendering/MetalView.swift"
      to: "SelectionManager"
      via: "mouseDown sends click coordinates to SelectionManager for ray-sphere test"
      pattern: "mouseDown|handleClick"
    - from: "AirplaneTracker3D/Rendering/SelectionManager.swift"
      to: "AirplaneTracker3D/ContentView.swift"
      via: "Selection result propagated to ContentView via callback/binding to show detail panel"
      pattern: "onAircraftSelected|selectedAircraft"
    - from: "AirplaneTracker3D/Views/AircraftDetailPanel.swift"
      to: "EnrichmentService"
      via: "Panel triggers async enrichment fetch on selection"
      pattern: "EnrichmentService|fetchAircraftInfo"
    - from: "AirplaneTracker3D/Camera/OrbitCamera.swift"
      to: "InterpolatedAircraftState"
      via: "followTarget updated each frame from selected aircraft position"
      pattern: "followTarget"
    - from: "AirplaneTracker3D/Rendering/Renderer.swift"
      to: "LabelManager"
      via: "encodeLabels called each frame after trails and before glow"
      pattern: "encodeLabels|encodeLabelBillboards"
---

<objective>
Implement billboard text labels, dashed altitude reference lines, aircraft selection with detail panel and enrichment, and follow-camera mode.

Purpose: Labels let users identify aircraft at a glance. Altitude lines provide vertical context. Selection and the detail panel let users explore specific flights. Follow mode provides cinematic camera tracking.
Output: LabelManager, LabelShaders.metal, AltitudeLineShaders.metal, SelectionManager, EnrichmentService, AircraftDetailPanel, updated OrbitCamera/MetalView/ContentView/Renderer.
</objective>

<execution_context>
@/Users/mit/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mit/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-trails-labels-selection/07-RESEARCH.md
@.planning/phases/07-trails-labels-selection/07-01-SUMMARY.md

@AirplaneTracker3D/Rendering/Renderer.swift
@AirplaneTracker3D/Rendering/ShaderTypes.h
@AirplaneTracker3D/Rendering/GlowShaders.metal
@AirplaneTracker3D/Rendering/AircraftInstanceManager.swift
@AirplaneTracker3D/Rendering/MetalView.swift
@AirplaneTracker3D/Camera/OrbitCamera.swift
@AirplaneTracker3D/ContentView.swift
@AirplaneTracker3D/Models/AircraftModel.swift
@AirplaneTracker3D/DataLayer/FlightDataActor.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Billboard labels with LOD, dashed altitude lines, and their Metal shaders and Renderer integration</name>
  <files>
    AirplaneTracker3D/Rendering/ShaderTypes.h
    AirplaneTracker3D/Rendering/LabelShaders.metal
    AirplaneTracker3D/Rendering/AltitudeLineShaders.metal
    AirplaneTracker3D/Rendering/LabelManager.swift
    AirplaneTracker3D/Rendering/Renderer.swift
    AirplaneTracker3D.xcodeproj/project.pbxproj
  </files>
  <action>
**ShaderTypes.h additions:**

Add to the BufferIndex enum: `BufferIndexLabelInstances = 6`, `BufferIndexAltLineVertices = 7`.

Add LabelInstanceData struct:
```c
typedef struct {
    simd_float3 position;    // 12 bytes: world position (above aircraft)
    float size;              // 4 bytes: billboard size
    simd_float2 atlasUV;    // 8 bytes: UV offset into atlas (top-left corner of this label's slot)
    simd_float2 atlasSize;  // 8 bytes: UV size of this label's slot in atlas
    float opacity;           // 4 bytes: distance-based fade (LOD)
    float _pad0;             // 4 bytes: padding
    float _pad1;             // 4 bytes: padding
    float _pad2;             // 4 bytes: padding
} LabelInstanceData;
// Total: 48 bytes
```

Add AltLineVertex struct:
```c
typedef struct {
    simd_float3 position;    // 12 bytes: world position
    float worldY;            // 4 bytes: Y value for dash pattern
} AltLineVertex;
// Total: 16 bytes
```

**LabelManager.swift:**

Create class `LabelManager` that manages a texture atlas of label bitmaps and produces label instance data for billboard rendering.

Properties:
- `textureAtlas: MTLTexture?` -- single large texture (2048x2048, RGBA8) subdivided into slots (256x64 each = 32 columns x 32 rows = 1024 slots)
- `labelBuffers: [MTLBuffer]` -- triple-buffered LabelInstanceData buffers
- `altLineBuffers: [MTLBuffer]` -- triple-buffered AltLineVertex buffers
- `labelCount: [Int]` -- per-frame-buffer label count
- `altLineVertexCount: [Int]` -- per-frame-buffer alt line vertex count
- Private `labelCache: [String: (text: String, slot: Int)]` -- maps hex to cached label text and atlas slot
- Private `slotAllocator: [Bool]` -- tracks which atlas slots are in use (1024 slots)
- Private `cgContext: CGContext?` -- reusable CGContext for label rasterization (256x64 pixels)
- `maxLabelDistance: Float = 300.0` -- beyond this distance, labels fully hidden
- `fadeLabelDistance: Float = 150.0` -- start fading at this distance

Init(device:):
- Create the 2048x2048 RGBA8 texture atlas
- Allocate triple-buffered instance buffers (1024 * LabelInstanceData stride)
- Allocate triple-buffered alt line buffers (1024 * 2 * AltLineVertex stride -- 2 vertices per aircraft: top and ground)
- Create the reusable 256x64 CGContext

`rasterizeLabel(text:slot:)` method:
1. Clear the CGContext to transparent (RGBA 0,0,0,0)
2. Add a semi-transparent dark background rounded rect for readability: fill with RGBA(0, 0, 0, 0.6)
3. Draw text using NSAttributedString + CTLine with white bold 18pt system font
4. Calculate the atlas region for the given slot: column = slot % 32, row = slot / 32, region = (col*256, row*64, 256, 64)
5. Upload the CGContext pixel data to the atlas MTLTexture at the computed region via `texture.replace(region:...)`

`update(states:bufferIndex:cameraPosition:)` method:
1. For each aircraft state:
   a. Compute distance from cameraPosition to state.position
   b. If distance > maxLabelDistance, skip this aircraft (no label, no altitude line)
   c. Compute opacity: if distance < fadeLabelDistance, opacity = 1.0; else linearly fade to 0.0 at maxLabelDistance
   d. Build label text: "\(state.callsign.isEmpty ? state.hex : state.callsign)\n\(Int(state.altitude))ft"
   e. Check if label text changed from cache -- if changed or new, allocate a slot and rasterize
   f. Write LabelInstanceData: position = state.position + SIMD3<Float>(0, 4.0, 0) (above aircraft), size = 8.0, atlasUV/atlasSize from slot, opacity
2. Write alt line vertices for each visible aircraft: two AltLineVertex entries per aircraft:
   - Vertex 0: position = state.position (aircraft), worldY = state.position.y
   - Vertex 1: position = (state.position.x, 0, state.position.z) (ground), worldY = 0
3. Clean up stale labels: if a hex is no longer in states, free its atlas slot after a few frames
4. Update labelCount[bufferIndex] and altLineVertexCount[bufferIndex]

Buffer accessors: `labelBuffer(at:)`, `altLineBuffer(at:)`, `labelVertexCount(at:)`, `altLineVertexCount(at:)`.

**LabelShaders.metal:**

Based directly on GlowShaders.metal billboard pattern.

Vertex output `LabelVertexOut`: position, texCoord, opacity.

Vertex shader `label_vertex`:
- Inputs: vertexID, instanceID, uniforms (buffer 0), LabelInstanceData instances (buffer BufferIndexLabelInstances)
- Generate 6 vertices per billboard (2 triangles) from vertexID, same as glow_vertex
- Extract camera right/up from view matrix
- Compute world position = instance.position + camRight * corner.x * instance.size + camUp * corner.y * instance.size * 0.25 (labels are wider than tall, aspect ratio ~4:1)
- Map texCoord: `instance.atlasUV + (corner * 0.5 + 0.5) * instance.atlasSize`
- Pass through opacity

Fragment shader `label_fragment`:
- Sample atlas texture at texCoord
- Multiply alpha by instance opacity for distance fade
- Discard if alpha < 0.01 to avoid transparent fragments affecting depth
- Return premultiplied alpha result for blending

**AltitudeLineShaders.metal:**

Vertex shader `altline_vertex`:
- Inputs: vertexID, AltLineVertex vertices (buffer BufferIndexAltLineVertices), uniforms
- Transform position by VP matrix
- Pass worldY to fragment

Fragment shader `altline_fragment`:
- Dashed pattern: `float pattern = fmod(abs(in.worldY), 2.0) / 2.0; if (pattern > 0.5) discard_fragment();`
- Color: semi-transparent gray RGBA(0.5, 0.5, 0.5, 0.3)

**Renderer.swift modifications:**

Add properties:
- `let labelManager: LabelManager`
- `let labelPipeline: MTLRenderPipelineState`
- `let altLinePipeline: MTLRenderPipelineState`

In init:
- Create labelManager
- Create label pipeline: no vertex descriptor, alpha blending (sourceAlpha, oneMinusSourceAlpha), depth format, sampleCount
- Create altitude line pipeline: no vertex descriptor, alpha blending (sourceAlpha, oneMinusSourceAlpha), depth format, sampleCount

Add `encodeAltitudeLines(encoder:uniformBuffer:)`:
1. Guard altLineVertexCount > 0
2. Set altLinePipeline, set depth stencil to depthStencilState (altitude lines write depth, since they're thin and opaque-ish)
3. Bind uniforms at 0, altLineBuffer at BufferIndexAltLineVertices
4. drawPrimitives type: .line, vertexStart: 0, vertexCount (altitude lines are simple 1px Metal lines -- they're thin reference lines, not thick trails, so .line primitive is fine here)

Add `encodeLabels(encoder:uniformBuffer:)`:
1. Guard labelCount > 0
2. Set labelPipeline, set glowDepthStencilState (depth-read, no-write -- same as glow)
3. Bind uniforms, labelBuffer at BufferIndexLabelInstances
4. Set fragment texture to labelManager.textureAtlas at index 0
5. drawPrimitives type: .triangle, vertexStart: 0, vertexCount: 6, instanceCount: labelCount

In draw(in:):
- After trailManager.update (from plan 07-01), also call: `labelManager.update(states: states, bufferIndex: currentBufferIndex, cameraPosition: camera.position)`
- Render order: tiles -> altitude lines -> aircraft bodies -> spinning parts -> trails -> labels -> glow sprites
- Encode altitude lines right after tiles (before aircraft bodies), labels after trails (before glow)

**Xcode project:**
Add LabelShaders.metal, AltitudeLineShaders.metal, and LabelManager.swift to the Xcode project in the Rendering group.
  </action>
  <verify>
Build succeeds with `xcodebuild build -project AirplaneTracker3D.xcodeproj -scheme AirplaneTracker3D -destination 'platform=macOS' 2>&1 | tail -5`. Labels appear above aircraft showing callsign/altitude. Labels fade with distance. Dashed lines extend from aircraft to ground.
  </verify>
  <done>Billboard labels render above each aircraft with callsign and altitude text, fading at distance. Dashed altitude reference lines render from each aircraft to ground. Label texture atlas is efficient (one texture, one draw call for all labels). All new shader files and LabelManager are in the Xcode project.</done>
</task>

<task type="auto">
  <name>Task 2: Ray-cast selection, SwiftUI detail panel, enrichment service, and follow camera</name>
  <files>
    AirplaneTracker3D/Rendering/SelectionManager.swift
    AirplaneTracker3D/DataLayer/EnrichmentService.swift
    AirplaneTracker3D/Views/AircraftDetailPanel.swift
    AirplaneTracker3D/Models/AircraftModel.swift
    AirplaneTracker3D/Camera/OrbitCamera.swift
    AirplaneTracker3D/Rendering/MetalView.swift
    AirplaneTracker3D/Rendering/AircraftInstanceManager.swift
    AirplaneTracker3D/ContentView.swift
    AirplaneTracker3D/Rendering/Renderer.swift
    AirplaneTracker3D.xcodeproj/project.pbxproj
  </files>
  <action>
**AircraftModel.swift additions:**

Add a `SelectedAircraftInfo` struct for passing selection data to SwiftUI:
```swift
struct SelectedAircraftInfo: Identifiable {
    let id: String  // hex
    let hex: String
    let callsign: String
    let altitude: Float  // feet
    let groundSpeed: Float  // knots
    let heading: Float  // degrees
    let verticalRate: Float  // ft/min
    let squawk: String
    let lat: Double
    let lon: Double
    let position: SIMD3<Float>  // world-space for follow camera
    // Enrichment data (populated asynchronously)
    var registration: String?
    var aircraftType: String?
    var operator_: String?
    var origin: String?
    var destination: String?
}
```

Extend InterpolatedAircraftState to carry squawk, lat, lon (needed for detail panel):
```swift
// Add to InterpolatedAircraftState:
var squawk: String
var lat: Double
var lon: Double
```

Update FlightDataManager.interpolatedStates(at:) to populate squawk, lat, lon from the buffer data. The `classifySource` (AircraftModel `a.data`) already has `.squawk`, `.lat`, `.lon` -- just pass them through to InterpolatedAircraftState.

**SelectionManager.swift:**

Create class `SelectionManager`:

Properties:
- `selectedHex: String?` -- currently selected aircraft hex (nil = nothing selected)
- `isFollowing: Bool = false` -- whether camera follows selected aircraft

`handleClick(screenPoint:viewSize:viewMatrix:projMatrix:states:) -> SelectedAircraftInfo?`:
1. Convert screen point to ray using screen-to-ray unprojection (Metal NDC z: 0=near, 1=far):
   - NDC x = (screenPoint.x / viewSize.width) * 2 - 1
   - NDC y = 1 - (screenPoint.y / viewSize.height) * 2 (flip Y)
   - Compute inverse VP matrix
   - Unproject near point (ndcX, ndcY, 0, 1) and far point (ndcX, ndcY, 1, 1)
   - Perspective divide, ray direction = normalize(far - near)
2. For each InterpolatedAircraftState, test ray-sphere intersection with center=position, radius=3.0 world units
3. Select the closest hit (smallest positive t value)
4. If hit: set selectedHex, build and return SelectedAircraftInfo from the state
5. If no hit: clear selectedHex, return nil (deselect)

`selectedPosition(from states:) -> SIMD3<Float>?`:
- If selectedHex is set, find the matching state and return its position
- Used by follow camera each frame

Ray-sphere intersection:
```swift
func raySphereIntersect(origin: SIMD3<Float>, dir: SIMD3<Float>,
                         center: SIMD3<Float>, radius: Float) -> Float? {
    let oc = origin - center
    let b = simd_dot(oc, dir)
    let c = simd_dot(oc, oc) - radius * radius
    let discriminant = b * b - c
    guard discriminant >= 0 else { return nil }
    let t = -b - sqrt(discriminant)
    return t > 0 ? t : nil
}
```

**EnrichmentService.swift:**

Create `actor EnrichmentService` with cached lookups for two APIs:

Private caches: `aircraftCache: [String: AircraftEnrichment?]`, `routeCache: [String: RouteEnrichment?]`.

Codable response types:
- `HexDBResponse`: Registration, Manufacturer, ICAOTypeCode, Type, RegisteredOwners (all String?)
- `ADSBDBResponse`: nested response.flightroute with airline.name, origin.name/iata_code/icao_code, destination.name/iata_code/icao_code

Result types:
- `AircraftEnrichment`: registration, manufacturer, type, icaoTypeCode, owner (all String)
- `RouteEnrichment`: airline, originName, originCode, destinationName, destinationCode (all String)

`fetchAircraftInfo(hex:) async -> AircraftEnrichment?`:
1. Check cache, return if exists (even nil = cached negative)
2. URL: `https://hexdb.io/api/v1/aircraft/\(hex)`
3. URLSession with 3-second timeout configuration
4. Decode HexDBResponse, map to AircraftEnrichment
5. Cache result (or nil on failure), return

`fetchRouteInfo(callsign:) async -> RouteEnrichment?`:
1. Check cache, return if exists
2. Clean callsign: trim whitespace, uppercase, skip if empty
3. URL: `https://api.adsbdb.com/v0/callsign/\(clean)`
4. URLSession with 3-second timeout
5. Decode ADSBDBResponse, map to RouteEnrichment
6. Cache result, return

**AircraftDetailPanel.swift:**

Create directory `AirplaneTracker3D/Views/` if it doesn't exist.

SwiftUI view `AircraftDetailPanel`:

Properties:
- `let aircraft: SelectedAircraftInfo`
- `let enrichmentService: EnrichmentService`
- `let onFollow: () -> Void` -- callback for follow button
- `let onClose: () -> Void` -- callback for close/deselect
- `@State private var enrichedAircraft: AircraftEnrichment?`
- `@State private var routeInfo: RouteEnrichment?`
- `@State private var isLoadingEnrichment = true`

Body: VStack with right-aligned panel content:
1. Header: callsign (large bold) + close button (X)
2. Section "Flight Data": altitude (formatted with comma thousands separator + "ft"), speed ("XXX kts"), heading ("XXX deg"), vertical rate ("+/-XXX ft/min"), squawk
3. Section "Position": lat/lon formatted to 4 decimal places
4. Section "Aircraft" (shown when enrichment loaded): registration, type, operator
5. Section "Route" (shown when route loaded): origin -> destination (IATA codes + names)
6. "Follow" button at bottom that calls onFollow
7. Loading spinner while enrichment is loading

Background: dark semi-transparent panel (Color.black.opacity(0.85)) with rounded corners, white text.

On appear (`.task`): fetch both enrichments concurrently:
```swift
async let acInfo = enrichmentService.fetchAircraftInfo(hex: aircraft.hex)
async let rtInfo = enrichmentService.fetchRouteInfo(callsign: aircraft.callsign)
enrichedAircraft = await acInfo
routeInfo = await rtInfo
isLoadingEnrichment = false
```

**OrbitCamera.swift modifications:**

Add:
- `var followTarget: SIMD3<Float>? = nil` -- when set, camera smoothly tracks this point
- `let followSmoothness: Float = 0.08` -- exponential decay factor

In `update(deltaTime:)`, before the auto-rotate block, add:
```swift
if let ft = followTarget {
    let lerpFactor = 1.0 - pow(1.0 - followSmoothness, deltaTime * 60.0)
    target = target + (ft - target) * lerpFactor
}
```
This frame-rate-independent lerp smoothly moves the camera target toward the followed aircraft.

**MetalView.swift modifications:**

Add a click handler to MetalMTKView. Add a callback property to MetalView:
- `var onAircraftSelected: ((SelectedAircraftInfo?) -> Void)?`

Pass it through Coordinator:
- Coordinator gets `var onAircraftSelected: ((SelectedAircraftInfo?) -> Void)?`

In MetalMTKView, override `mouseDown(with:)`:
1. Get click location in view coordinates: `let point = convert(event.locationInWindow, from: nil)`
2. Get view size: `bounds.size`
3. Call `coordinator?.handleClick(at: point, in: bounds.size)`

In Coordinator, add:
```swift
func handleClick(at point: CGPoint, in viewSize: CGSize) {
    guard let renderer = renderer else { return }
    let states = renderer.flightDataManager?.interpolatedStates(at: CACurrentMediaTime()) ?? []
    let result = renderer.selectionManager.handleClick(
        screenPoint: point, viewSize: viewSize,
        viewMatrix: renderer.camera.viewMatrix,
        projMatrix: renderer.camera.projectionMatrix,
        states: states
    )
    onAircraftSelected?(result)
}
```

Also propagate `onAircraftSelected` from MetalView to Coordinator in makeNSView.

**AircraftInstanceManager.swift modifications:**

In the `update(states:bufferIndex:deltaTime:time:)` method, accept an optional `selectedHex: String?` parameter. When populating instance data, set `flags = 1` (bit 0 = selected) for the aircraft matching selectedHex. The gold highlight is already implemented in AircraftShaders.metal.

**Renderer.swift modifications:**

Add properties:
- `let selectionManager = SelectionManager()`

Expose selectionManager publicly (it's accessed by Coordinator for click handling).

In draw(in:), after computing states:
- Get the selected aircraft position for follow camera: `if let pos = selectionManager.selectedPosition(from: states) { camera.followTarget = selectionManager.isFollowing ? pos : nil }`
- Pass selectedHex to instanceManager.update: `instanceManager.update(states: states, bufferIndex: currentBufferIndex, deltaTime: deltaTime, time: Float(now), selectedHex: selectionManager.selectedHex)`

**ContentView.swift modifications:**

Replace the simple MetalView with a ZStack overlay pattern:

```swift
struct ContentView: View {
    @State private var flightDataManager = FlightDataManager()
    @State private var selectedAircraft: SelectedAircraftInfo? = nil
    private let enrichmentService = EnrichmentService()

    var body: some View {
        ZStack(alignment: .trailing) {
            MetalView(
                flightDataManager: flightDataManager,
                onAircraftSelected: { info in
                    withAnimation(.easeInOut(duration: 0.25)) {
                        selectedAircraft = info
                    }
                }
            )
            .ignoresSafeArea()

            if let aircraft = selectedAircraft {
                AircraftDetailPanel(
                    aircraft: aircraft,
                    enrichmentService: enrichmentService,
                    onFollow: {
                        // Toggle follow mode via renderer
                        // This needs a way to communicate back -- use a notification or shared state
                    },
                    onClose: {
                        withAnimation(.easeInOut(duration: 0.25)) {
                            selectedAircraft = nil
                        }
                    }
                )
                .frame(width: 280)
                .padding()
                .transition(.move(edge: .trailing))
            }
        }
        .onAppear {
            let center = (lat: MapCoordinateSystem.shared.centerLat,
                          lon: MapCoordinateSystem.shared.centerLon)
            flightDataManager.startPolling(mode: .global, center: center)
        }
    }
}
```

For the follow button communication: add `@State private var isFollowing = false` to ContentView, pass it to MetalView as a binding or callback. MetalView's Coordinator can set `renderer.selectionManager.isFollowing` accordingly. On follow toggle: `isFollowing.toggle()`, and set `renderer.camera.followTarget` / `renderer.selectionManager.isFollowing`. On deselect (close panel or click empty space): clear follow mode.

**Xcode project:**
Add SelectionManager.swift, EnrichmentService.swift, and AircraftDetailPanel.swift to the Xcode project. SelectionManager goes in Rendering group, EnrichmentService in DataLayer group, AircraftDetailPanel in a new Views group.
  </action>
  <verify>
Build succeeds. Click on an aircraft -- gold highlight appears, detail panel slides in from right showing flight data. Enrichment data loads asynchronously (registration, type, route). Click empty space -- deselects, panel closes. Click "Follow" -- camera smoothly tracks the selected aircraft. Labels show callsign/altitude above aircraft, fading at distance. Dashed altitude lines visible.
  </verify>
  <done>
Aircraft selection works via ray-sphere click picking with gold highlight. SwiftUI detail panel shows callsign, altitude, speed, heading, squawk, lat/lon, plus enrichment data from hexdb.io (registration, type, operator) and adsbdb.com (route origin/destination). Follow mode smoothly tracks selected aircraft. Click empty space deselects. Panel animates in/out.
  </done>
</task>

</tasks>

<verification>
- Labels render above all visible aircraft showing callsign and altitude
- Labels fade and disappear at distance (LOD works correctly)
- Dashed altitude lines extend from aircraft down to ground plane Y=0
- Clicking an aircraft selects it (gold highlight) and opens the detail panel
- Clicking empty space deselects and closes the panel
- Detail panel shows all required fields: callsign, altitude, speed, heading, squawk, position
- Enrichment data loads asynchronously: registration, type, operator, route
- Follow button causes camera to smoothly track the selected aircraft
- Clicking while following stops follow mode or switches to new aircraft
- No enrichment API errors (cached results, 3s timeout, silent failure)
- Frame rate remains 60fps with labels and altitude lines rendering
</verification>

<success_criteria>
Billboard labels render above aircraft with callsign/altitude and distance-based LOD. Dashed altitude reference lines extend from each aircraft to ground. Click-to-select works with gold highlight and SwiftUI detail panel showing all flight data plus async enrichment from hexdb.io and adsbdb.com. Follow camera smoothly tracks selected aircraft. All interaction is responsive and does not impact render performance.
</success_criteria>

<output>
After completion, create `.planning/phases/07-trails-labels-selection/07-02-SUMMARY.md`
</output>
