---
phase: 08-terrain-themes
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - AirplaneTracker3D/Rendering/ShaderTypes.h
  - AirplaneTracker3D/Rendering/TerrainTileManager.swift
  - AirplaneTracker3D/Rendering/TerrainShaders.metal
  - AirplaneTracker3D/Rendering/Renderer.swift
autonomous: true

must_haves:
  truths:
    - "User sees terrain elevation with visible mountains, valleys, and coastlines matching real-world geography"
    - "Terrain meshes tile seamlessly with no visible gaps or seams between adjacent tiles"
    - "Terrain loads asynchronously without blocking the 60fps render loop"
  artifacts:
    - path: "AirplaneTracker3D/Rendering/TerrainTileManager.swift"
      provides: "Terrain tile fetching, Terrarium PNG decoding, subdivided mesh generation"
      contains: "class TerrainTileManager"
    - path: "AirplaneTracker3D/Rendering/TerrainShaders.metal"
      provides: "Terrain vertex/fragment shaders with lighting"
      contains: "vertex.*terrain_vertex"
    - path: "AirplaneTracker3D/Rendering/ShaderTypes.h"
      provides: "TerrainVertex struct shared between CPU and GPU"
      contains: "TerrainVertex"
    - path: "AirplaneTracker3D/Rendering/Renderer.swift"
      provides: "Terrain pipeline state and draw calls integrated into render loop"
      contains: "terrainTileManager"
  key_links:
    - from: "AirplaneTracker3D/Rendering/TerrainTileManager.swift"
      to: "s3.amazonaws.com/elevation-tiles-prod/terrarium"
      via: "URLSession async fetch"
      pattern: "elevation-tiles-prod.*terrarium"
    - from: "AirplaneTracker3D/Rendering/TerrainTileManager.swift"
      to: "AirplaneTracker3D/Rendering/Renderer.swift"
      via: "terrainMesh(for:) returns vertex+index buffers"
      pattern: "terrainMesh.*TileCoordinate"
    - from: "AirplaneTracker3D/Rendering/Renderer.swift"
      to: "AirplaneTracker3D/Rendering/TerrainShaders.metal"
      via: "terrainPipeline using terrain_vertex/terrain_fragment"
      pattern: "terrain_vertex"
---

<objective>
Build the terrain elevation system -- a TerrainTileManager that fetches AWS Terrarium PNG tiles, decodes elevation data, generates subdivided 32x32 meshes with vertex displacement, and integrates terrain rendering into the existing Metal render loop as a replacement for flat tile quads.

Purpose: Terrain gives the 3D world geographic depth -- mountains, valleys, and coastlines become visible, making the flight visualization feel grounded in real geography.
Output: TerrainTileManager.swift, TerrainShaders.metal, updated ShaderTypes.h and Renderer.swift
</objective>

<execution_context>
@/Users/mit/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mit/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-terrain-themes/08-RESEARCH.md

@AirplaneTracker3D/Rendering/Renderer.swift
@AirplaneTracker3D/Rendering/ShaderTypes.h
@AirplaneTracker3D/Rendering/Shaders.metal
@AirplaneTracker3D/Map/MapTileManager.swift
@AirplaneTracker3D/Map/TileCoordinate.swift
@AirplaneTracker3D/Map/MapCoordinateSystem.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: TerrainTileManager with Terrarium decoding and mesh generation</name>
  <files>
    AirplaneTracker3D/Rendering/ShaderTypes.h
    AirplaneTracker3D/Rendering/TerrainTileManager.swift
  </files>
  <action>
1. Add TerrainVertex struct to ShaderTypes.h (must match Metal shader expectations):
   ```c
   typedef struct {
       simd_float3 position;   // XYZ with Y = displaced elevation
       simd_float2 texCoord;   // UV for map tile texture sampling
       simd_float3 normal;     // Computed surface normal for lighting
   } TerrainVertex;
   ```
   This struct must come after the existing types and before `#endif`. The existing TexturedVertex is still used for flat tiles. TerrainVertex adds a normal for terrain lighting.

2. Create TerrainTileManager.swift modeled on MapTileManager.swift (same async fetch + LRU cache pattern, serial DispatchQueue for thread safety):

   **Properties:**
   - `device: MTLDevice`
   - LRU cache: `[TileCoordinate: TerrainMeshData]` with max 150 entries (terrain meshes are larger than textures)
   - `pendingRequests: Set<TileCoordinate>` to prevent duplicate fetches
   - URLSession with same config as MapTileManager (User-Agent, cache sizes)
   - Serial `cacheQueue` for thread-safe cache access
   - `let terrainScaleFactor: Float = 0.005` (slightly lower than web app's 0.008 to keep mountains below cruising altitude -- at 0.005, Everest ~8849m = 44.2 units, cruising aircraft at 35000ft/10668m * 0.001 = 10.7 units... actually 0.005 makes terrain too tall. Use 0.003 -- Everest = 26.5 units, still visually prominent but below cruise. ACTUALLY, the web app uses 0.008 with dynamic scaling. Use 0.005 as a balanced starting point.)

   **TerrainMeshData struct** (returned from cache):
   ```swift
   struct TerrainMeshData {
       let vertexBuffer: MTLBuffer
       let indexBuffer: MTLBuffer
       let indexCount: Int
   }
   ```

   **Core methods:**

   a) `terrainMesh(for tile: TileCoordinate) -> TerrainMeshData?`
      - Same pattern as MapTileManager.texture(for:) -- return cached mesh or start async fetch, return nil while loading
      - LRU cache update on hit

   b) `private func fetchTerrainTile(_ tile: TileCoordinate)`
      - URL: `https://s3.amazonaws.com/elevation-tiles-prod/terrarium/\(tile.zoom)/\(tile.x)/\(tile.y).png`
      - Download PNG data via URLSession async
      - Decode PNG to raw RGBA pixels using CGImage + CGContext (create CGImage from data, draw into a 256x256 RGBA CGContext to get pixel bytes)
      - Apply Terrarium formula to all 65536 pixels: `elevation = (R * 256 + G + B/256) - 32768`
      - Store as `[Float]` array of 65536 elevation values
      - Call `buildTerrainMesh(tile:elevations:)` to generate vertex/index buffers
      - Store result in LRU cache

   c) `private func buildTerrainMesh(tile: TileCoordinate, elevations: [Float]) -> TerrainMeshData`
      - Subdivision: 32x32 segments = 33x33 = 1089 vertices, 2048 triangles, 6144 indices
      - Get tile world bounds using `TileCoordinate.tileBounds(tile:)` and `MapCoordinateSystem.shared`
      - For each vertex (ix, iy in 0...32):
        - u = Float(ix) / 32.0, v = Float(iy) / 32.0
        - worldX = minX + u * (maxX - minX)
        - worldZ = minZ + v * (maxZ - minZ)
        - Sample elevation: ex = min(Int(u * 255), 255), ey = min(Int(v * 255), 255), elevation = elevations[ey * 256 + ex]
        - worldY = max(0, elevation) * terrainScaleFactor (clamp negative = ocean to zero)
        - Write TerrainVertex with position=(worldX, worldY, worldZ), texCoord=(u, v), normal=(0,1,0) placeholder
      - Generate triangle indices: for each quad (ix, iy in 0..<32), two triangles with UInt32 indices (not UInt16 -- 1089 vertices fits UInt16 but use UInt32 for safety with future LOD)
      - Compute normals using neighbor cross-product method: for each vertex, sample left/right/up/down positions, compute cross(dz, dx), normalize. Clamp at edges.
      - Create MTLBuffer for vertices and indices with .storageModeShared
      - Return TerrainMeshData

   d) `func clearCache()` -- same as MapTileManager

   **Important details:**
   - PNG decoding MUST happen off main thread (the Task {} block handles this)
   - Use CGImage approach: `CGImage` from `CGDataProvider` with PNG data, then draw into CGContext to get raw pixel bytes. Use `CGImageSourceCreateWithData` + `CGImageSourceCreateImageAtIndex` from ImageIO for reliable PNG decoding.
   - The elevation array index convention: ey * 256 + ex where (0,0) is top-left of tile = north-west corner. This matches the texture UV convention where v=0 is the north edge (same as tile quad).
  </action>
  <verify>
Project builds with `xcodebuild -project AirplaneTracker3D.xcodeproj -scheme AirplaneTracker3D build 2>&1 | tail -5` showing "BUILD SUCCEEDED". TerrainVertex exists in ShaderTypes.h. TerrainTileManager.swift compiles with terrainMesh(for:) method.
  </verify>
  <done>
TerrainTileManager fetches Terrarium PNGs, decodes elevation, and generates 32x32 subdivided meshes with displaced vertices and computed normals. TerrainVertex struct is defined in the shared header. Mesh data is LRU-cached per tile coordinate.
  </done>
</task>

<task type="auto">
  <name>Task 2: Terrain shaders and Renderer integration replacing flat tiles</name>
  <files>
    AirplaneTracker3D/Rendering/TerrainShaders.metal
    AirplaneTracker3D/Rendering/Renderer.swift
  </files>
  <action>
1. Create TerrainShaders.metal with vertex and fragment shaders:

   ```metal
   #include <metal_stdlib>
   using namespace metal;
   #include "ShaderTypes.h"

   struct TerrainVertexIn {
       float3 position [[attribute(0)]];
       float2 texCoord [[attribute(1)]];
       float3 normal   [[attribute(2)]];
   };

   struct TerrainVertexOut {
       float4 position [[position]];
       float2 texCoord;
       float3 worldNormal;
       float3 worldPosition;
   };
   ```

   **terrain_vertex:** Takes TerrainVertexIn (already displaced on CPU), transforms by viewMatrix and projectionMatrix from Uniforms. No modelMatrix needed -- terrain vertices are already in world space (built from MapCoordinateSystem coordinates). Pass worldNormal and worldPosition to fragment.

   **terrain_fragment:** Sample the map tile texture at texCoord. Apply simple directional lighting: lightDir = normalize(float3(0.5, 1.0, 0.3)), diffuse = max(dot(normal, lightDir), 0.0), lighting = 0.4 + diffuse * 0.6. Output texColor.rgb * lighting with alpha 1.0.

   **terrain_fragment_placeholder:** For tiles still loading their map texture -- return a placeholder color (0.45, 0.50, 0.45, 1.0) with the same lighting calculation applied to show terrain shape even without texture.

2. Modify Renderer.swift to integrate terrain rendering:

   **New properties:**
   - `let terrainTileManager: TerrainTileManager`
   - `let terrainPipeline: MTLRenderPipelineState`
   - `let terrainPlaceholderPipeline: MTLRenderPipelineState`

   **In init(metalView:):**
   - Create `terrainTileManager = TerrainTileManager(device: device)`
   - Create terrain vertex descriptor with 3 attributes:
     - attribute 0: float3 position at offset 0
     - attribute 1: float2 texCoord at offset 16 (MemoryLayout<SIMD3<Float>>.stride)
     - attribute 2: float3 normal at offset 24 (16 + MemoryLayout<SIMD2<Float>>.stride... WAIT. Need to compute offsets from TerrainVertex layout. In the C struct: position is simd_float3 (12 bytes, padded to 16), texCoord is simd_float2 (8 bytes), normal is simd_float3 (12 bytes). Total stride should be computed via MemoryLayout<TerrainVertex>.stride. Attribute offsets: position=0, texCoord=16, normal=24. Actually check: simd_float3=12 bytes aligned to 16, simd_float2=8 bytes. Position at 0 (size 12, padded to 16). texCoord at 16 (size 8). normal at 24 (size 12). Total = 36, padded to 48? Need to verify with MemoryLayout. Use `MemoryLayout<TerrainVertex>.stride` for the layout stride and compute offsets using `MemoryLayout.offset(of:)` or hardcode based on C struct layout. Actually since it is a C struct from the bridging header, Swift will use the C layout. For simd_float3 + simd_float2 + simd_float3: position at offset 0 (16-byte aligned = 0), texCoord at offset 16 (8-byte aligned, after 16 bytes = ok), normal at offset 24 (16-byte aligned? simd_float3 has 16-byte alignment in Metal? No -- in C, simd_float3 is 16-byte aligned by default on Apple platforms). So normal would be at offset 32 (next 16-byte boundary after 24). Let me reconsider. Use `offsetof` or just compute at runtime with `MemoryLayout<TerrainVertex>.offset(of: \.texCoord)!` etc. SAFEST: compute offsets at runtime in Swift.
   - Set layout stride to `MemoryLayout<TerrainVertex>.stride`
   - Create terrainPipeline with terrain_vertex + terrain_fragment
   - Create terrainPlaceholderPipeline with terrain_vertex + terrain_fragment_placeholder

   **In draw(in:) -- replace flat tile rendering with terrain:**
   - For each visible tile, check BOTH `tileManager.texture(for: tile)` (map texture) AND `terrainTileManager.terrainMesh(for: tile)` (elevation mesh)
   - If terrain mesh exists AND map texture exists: draw terrain mesh with texture using terrainPipeline
   - If terrain mesh exists but NO map texture: draw terrain mesh with terrainPlaceholderPipeline (shows terrain shape while texture loads)
   - If NO terrain mesh but map texture exists: draw flat tile quad with existing texturedPipelineState (graceful fallback)
   - If neither: draw flat placeholder as before

   **Terrain draw call:**
   ```swift
   encoder.setRenderPipelineState(terrainPipeline)
   encoder.setVertexBuffer(mesh.vertexBuffer, offset: 0, index: Int(BufferIndexVertices.rawValue))
   encoder.setVertexBuffer(uniformBuffer, offset: 0, index: Int(BufferIndexUniforms.rawValue))
   encoder.setFragmentTexture(texture, index: Int(TextureIndexColor.rawValue))
   encoder.drawIndexedPrimitives(
       type: .triangle,
       indexCount: mesh.indexCount,
       indexType: .uint32,
       indexBuffer: mesh.indexBuffer,
       indexBufferOffset: 0
   )
   ```

   Note: Terrain vertices are already in world space, so no per-tile modelMatrix is needed (unlike flat tiles which transform a unit quad). The terrain_vertex shader should NOT multiply by a modelMatrix.

   **Keep flat tile rendering code** but only use it as fallback when terrain mesh is not yet loaded. This ensures tiles always appear (flat while terrain loads, then elevated once terrain arrives).

   **Ensure altitude lines go down to terrain level:** Currently altitude lines go to Y=0. With terrain, the ground is elevated. For now, keep Y=0 as the altitude line target -- fixing this is a visual polish item, not a blocker.
  </action>
  <verify>
Build succeeds with `xcodebuild -project AirplaneTracker3D.xcodeproj -scheme AirplaneTracker3D build 2>&1 | tail -5`. Run the app -- terrain elevation should be visible as 3D landforms on the ground plane. Mountains should be visibly raised. Ocean should be flat at Y=0. Map textures should drape over terrain. No frame rate degradation below 30fps with terrain loaded.
  </verify>
  <done>
Terrain elevation meshes render in the scene with Terrarium-decoded elevation data. Each tile has a 32x32 subdivided mesh with vertex displacement and lighting. Map tile textures drape over terrain. Flat tile fallback works while terrain is loading. The render loop maintains interactive frame rates.
  </done>
</task>

</tasks>

<verification>
1. Build the project: `xcodebuild -project AirplaneTracker3D.xcodeproj -scheme AirplaneTracker3D build`
2. Run the app and verify terrain elevation is visible (mountains, valleys, coastlines)
3. Pan around the map -- terrain tiles should load asynchronously without stuttering
4. Terrain meshes should tile seamlessly with no visible gaps
5. Map textures should be properly draped over the elevation mesh
6. Frame rate should remain above 30fps with terrain loaded
</verification>

<success_criteria>
- TerrainTileManager fetches Terrarium tiles and generates displaced meshes
- Terrain is visible in the scene with real-world elevation data
- Map tile textures drape over terrain with lighting
- Graceful fallback to flat tiles when terrain is loading
- No frame rate regression below 30fps
</success_criteria>

<output>
After completion, create `.planning/phases/08-terrain-themes/08-01-SUMMARY.md`
</output>
