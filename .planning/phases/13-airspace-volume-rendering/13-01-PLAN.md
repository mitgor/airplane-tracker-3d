---
phase: 13-airspace-volume-rendering
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - AirplaneTracker3D/Rendering/ShaderTypes.h
  - AirplaneTracker3D/Rendering/EarClipTriangulator.swift
  - AirplaneTracker3D/Rendering/AirspaceShaders.metal
  - AirplaneTracker3D/Rendering/AirspaceManager.swift
autonomous: true

must_haves:
  truths:
    - "AirspaceManager can fetch FAA Class B/C/D airspace GeoJSON from the ArcGIS FeatureServer for given map bounds"
    - "Polygon coordinates are correctly triangulated into triangle index arrays via ear clipping"
    - "Extruded 3D meshes are generated with floor, ceiling, and wall geometry for each airspace feature"
    - "AirspaceVertex struct in ShaderTypes.h matches the Metal shader input layout"
    - "Metal shaders compile and produce semi-transparent output with per-class coloring"
  artifacts:
    - path: "AirplaneTracker3D/Rendering/ShaderTypes.h"
      provides: "AirspaceVertex struct and BufferIndexAirspaceVertices constant"
      contains: "BufferIndexAirspaceVertices"
    - path: "AirplaneTracker3D/Rendering/EarClipTriangulator.swift"
      provides: "Pure Swift ear-clipping polygon triangulation"
      contains: "func triangulate"
    - path: "AirplaneTracker3D/Rendering/AirspaceShaders.metal"
      provides: "Vertex and fragment shaders for translucent airspace fill and wireframe edges"
      contains: "airspace_vertex"
    - path: "AirplaneTracker3D/Rendering/AirspaceManager.swift"
      provides: "FAA data fetching, GeoJSON parsing, mesh extrusion, triple-buffered GPU buffers"
      contains: "class AirspaceManager"
  key_links:
    - from: "AirplaneTracker3D/Rendering/AirspaceManager.swift"
      to: "FAA ArcGIS FeatureServer"
      via: "URLSession async fetch"
      pattern: "services6.arcgis.com.*Class_Airspace"
    - from: "AirplaneTracker3D/Rendering/AirspaceManager.swift"
      to: "AirplaneTracker3D/Rendering/EarClipTriangulator.swift"
      via: "triangulate() call for polygon mesh generation"
      pattern: "triangulate"
    - from: "AirplaneTracker3D/Rendering/AirspaceManager.swift"
      to: "AirplaneTracker3D/Rendering/ShaderTypes.h"
      via: "AirspaceVertex struct used for GPU buffer writes"
      pattern: "AirspaceVertex"
---

<objective>
Create the airspace data pipeline and Metal rendering primitives for FAA Class B/C/D airspace volumes.

Purpose: Establishes the data fetch, polygon triangulation, mesh extrusion, and shader infrastructure needed before wiring into the Renderer draw loop (Plan 02).
Output: Four files -- ShaderTypes.h additions, EarClipTriangulator.swift, AirspaceShaders.metal, AirspaceManager.swift -- all compilable but not yet called from the Renderer.
</objective>

<execution_context>
@/Users/mit/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mit/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/ARCHITECTURE.md
@.planning/research/STACK.md
@AirplaneTracker3D/Rendering/ShaderTypes.h
@AirplaneTracker3D/Rendering/Renderer.swift
@AirplaneTracker3D/Map/MapCoordinateSystem.swift
@airplane-tracker-3d-map.html (lines 1880-2017 for airspace reference)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add airspace types to ShaderTypes.h and create EarClipTriangulator</name>
  <files>
    AirplaneTracker3D/Rendering/ShaderTypes.h
    AirplaneTracker3D/Rendering/EarClipTriangulator.swift
  </files>
  <action>
**ShaderTypes.h changes:**

Add a new buffer index after `BufferIndexAltLineVertices = 7`:
```c
BufferIndexAirspaceVertices = 8
```

Add an `AirspaceVertex` struct (32 bytes, same layout as existing vertex patterns):
```c
typedef struct {
    simd_float3 position;    // 12 bytes: world-space XYZ
    float _pad0;             // 4 bytes: padding for alignment
    simd_float4 color;       // 16 bytes: per-vertex RGBA (class color with alpha)
} AirspaceVertex;
```

Also expand the `Uniforms` struct to include `cameraPosition` (needed for the Fresnel edge effect in the airspace fragment shader):
```c
typedef struct {
    simd_float4x4 modelMatrix;
    simd_float4x4 viewMatrix;
    simd_float4x4 projectionMatrix;
    simd_float3 cameraPosition;    // NEW: for Fresnel/specular calculations
    float _pad;                     // alignment padding
} Uniforms;
```

This Uniforms expansion is backward-compatible -- existing shaders access by field name.

**EarClipTriangulator.swift:**

Create a pure Swift ear-clipping triangulation utility (~80-100 lines). No external dependencies.

```swift
struct EarClipTriangulator {
    /// Triangulate a 2D polygon (array of (x, z) points) into triangle indices.
    /// Points should be in counter-clockwise order. Returns array of index triples.
    /// Handles convex and mildly concave polygons (typical FAA airspace boundaries).
    static func triangulate(polygon: [SIMD2<Float>]) -> [UInt32]
}
```

Implementation approach:
1. Build a linked list of vertex indices
2. Iterate: for each consecutive triple (prev, curr, next), check if the triangle is an "ear" (the triangle formed is inside the polygon and contains no other vertices)
3. If ear found, emit the triangle indices and remove `curr` from the list
4. Repeat until only 2 vertices remain
5. Use cross-product sign to check orientation and point-in-triangle test for ear validation
6. If polygon is clockwise, reverse it before processing

The `isEar` check:
- Cross product of (prev->curr) x (curr->next) must be positive (convex angle)
- No other polygon vertex may lie inside the triangle (prev, curr, next)

Point-in-triangle test: Use barycentric coordinates or three cross-product sign checks.

Keep this as a struct with static methods -- no state needed. FAA polygons have 8-50 vertices, so O(n^2) ear clipping is fine.
  </action>
  <verify>
Project builds with `xcodebuild build -project AirplaneTracker3D.xcodeproj -scheme AirplaneTracker3D -destination 'platform=macOS'`. Both new files are included in the build. The `AirspaceVertex` struct size matches 32 bytes. The `EarClipTriangulator.triangulate()` method exists and compiles.
  </verify>
  <done>
ShaderTypes.h has `BufferIndexAirspaceVertices = 8`, `AirspaceVertex` struct, and expanded `Uniforms` with `cameraPosition`. EarClipTriangulator.swift compiles and provides `triangulate(polygon:) -> [UInt32]`. Project builds without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create AirspaceShaders.metal and AirspaceManager.swift</name>
  <files>
    AirplaneTracker3D/Rendering/AirspaceShaders.metal
    AirplaneTracker3D/Rendering/AirspaceManager.swift
  </files>
  <action>
**AirspaceShaders.metal:**

Create a new Metal shader file with two shader pairs (fill + edge):

1. **Vertex shader** (`airspace_vertex`):
   - Input: `AirspaceVertex` from buffer at `BufferIndexAirspaceVertices`, `Uniforms` at `BufferIndexUniforms`
   - Transform position by `viewMatrix * modelMatrix * float4(position, 1.0)` then `projectionMatrix`
   - Pass through color, worldPosition, worldNormal (compute normal from cross products of adjacent triangles or pass as zero for non-Fresnel mode)
   - Pass cameraPosition from uniforms to fragment

2. **Fill fragment shader** (`airspace_fill_fragment`):
   - Receives interpolated color with low alpha (from vertex color, alpha ~0.06)
   - Apply Fresnel-like edge boost: `float fresnel = 1.0 - abs(dot(normalize(viewDir), normalize(normal)))`. Boost alpha at grazing angles: `alpha = baseAlpha + pow(fresnel, 2.0) * baseAlpha * 3.0`
   - For walls where normals are available, this gives a "glass bubble" boundary effect
   - For floor/ceiling faces, normals point up/down so Fresnel effect is minimal (they stay very transparent) -- this is desired behavior
   - Clamp alpha to max 0.5, discard if < 0.005
   - Return `float4(color.rgb * alpha, alpha)` (premultiplied for correct alpha blending)

3. **Edge fragment shader** (`airspace_edge_fragment`):
   - Receives interpolated color with higher alpha (~0.3)
   - Simply returns the color as-is (no Fresnel needed for wireframe edges)
   - Used for the wireframe outline pass

The vertex output struct:
```metal
struct AirspaceVertexOut {
    float4 position [[position]];
    float4 color;
    float3 worldPosition;
    float3 worldNormal;
    float3 cameraPosition;
};
```

Note: The `AirspaceVertex` struct does not carry normals. Compute normals on the fly in the vertex shader is not possible without adjacency. Instead, have the AirspaceManager bake normals into the vertex data by extending AirspaceVertex OR pass a flat normal. Given AirspaceVertex is already defined without normals: use a simple approach -- walls get horizontal normals (outward from polygon centroid), floor/ceiling get (0,1,0)/(0,-1,0). The AirspaceManager will compute and embed this in the color alpha channel or as a separate approach.

**Simpler approach (recommended):** Skip Fresnel for the fill pass. Use flat alpha from the color's alpha channel. The web app uses flat 0.06 opacity and it looks fine. Reserve Fresnel for a future polish pass. The fill fragment just returns `float4(in.color.rgb * in.color.a, in.color.a)`.

**AirspaceManager.swift:**

Create a manager class following the existing triple-buffered pattern (like TrailManager, LabelManager).

```swift
final class AirspaceManager {
    private let device: MTLDevice
    private let coordSystem = MapCoordinateSystem.shared

    // Triple-buffered vertex buffers for airspace fill geometry
    private var fillBuffers: [MTLBuffer] = []
    private var fillVertexCounts: [Int] = [0, 0, 0]

    // Triple-buffered vertex buffers for airspace edge geometry
    private var edgeBuffers: [MTLBuffer] = []
    private var edgeVertexCounts: [Int] = [0, 0, 0]

    // Cached airspace features from FAA API
    private var features: [AirspaceFeature] = []
    private var isLoading = false
    private var lastFetchBounds: (west: Double, south: Double, east: Double, north: Double)?

    // Class visibility filters
    var showClassB = true
    var showClassC = true
    var showClassD = true

    init(device: MTLDevice) { ... }
    func loadAirspace(bounds: ...) async { ... }
    func update(bufferIndex: Int, ...) { ... }
    func fillBuffer(at index: Int) -> MTLBuffer { ... }
    func fillVertexCount(at index: Int) -> Int { ... }
    func edgeBuffer(at index: Int) -> MTLBuffer { ... }
    func edgeVertexCount(at index: Int) -> Int { ... }
}
```

**Data fetching** (async, similar to MapTileManager pattern):
- Build URL from FAA ArcGIS FeatureServer: `https://services6.arcgis.com/ssFJjBXIUyZDrSYZ/arcgis/rest/services/Class_Airspace/FeatureServer/0/query`
- Query params: `where=CLASS+IN+('B','C','D')`, `geometry={west},{south},{east},{north}`, `geometryType=esriGeometryEnvelope`, `inSR=4326`, `spatialRel=esriSpatialRelIntersects`, `outFields=NAME,CLASS,LOCAL_TYPE,UPPER_VAL,LOWER_VAL,UPPER_UOM,LOWER_UOM,ICAO_ID`, `f=geojson`, `resultRecordCount=500`
- Parse response with JSONSerialization (dynamic GeoJSON, not Codable)
- Extract features array, parse properties (CLASS, UPPER_VAL, LOWER_VAL, UPPER_UOM, LOWER_UOM), and geometry coordinates
- Only re-fetch if camera bounds changed significantly (>20% shift from last fetch bounds)

**Altitude conversion** (match web app `_altToScene`):
- If UOM is "FL" (flight level), multiply value by 100 to get feet
- Convert feet to world Y: `feet * 0.001` (same altitudeScale as FlightDataActor)

**Mesh generation** (CPU-side, called after data fetch):
For each feature:
1. Extract polygon coordinates from GeoJSON geometry (handle Polygon and MultiPolygon types)
2. Convert lat/lon to world XZ using `coordSystem.lonToX()` / `coordSystem.latToZ()`
3. Triangulate the 2D polygon with `EarClipTriangulator.triangulate()`
4. Build extruded mesh:
   - **Floor face:** triangulated vertices at floor altitude Y
   - **Ceiling face:** same triangulation at ceiling altitude Y (reverse winding for correct face orientation)
   - **Wall quads:** for each polygon edge, create 2 triangles connecting floor to ceiling vertices
5. Assign per-vertex color based on airspace class:
   - Class B: `SIMD4<Float>(0.27, 0.40, 1.0, 0.06)` (blue)
   - Class C: `SIMD4<Float>(0.60, 0.27, 1.0, 0.06)` (purple)
   - Class D: `SIMD4<Float>(0.27, 0.67, 1.0, 0.06)` (cyan)
6. Generate edge vertices: for each polygon edge, create line segments at floor and ceiling, plus vertical edges at each vertex. Edge color = same RGB but alpha 0.3

**Buffer management:**
- Pre-allocate buffers for max ~50K vertices (fill) and ~20K vertices (edges) per buffer
- Each frame's `update()` writes filtered features (respecting class toggles) to the current buffer index
- Sort by class: D first, then C, then B (back-to-front by class importance, not per-feature distance sorting -- classes don't overlap geographically)

**Internal model:**
```swift
struct AirspaceFeature {
    let name: String
    let airspaceClass: String  // "B", "C", "D"
    let floorFeet: Float
    let ceilingFeet: Float
    let fillVertices: [AirspaceVertex]
    let edgeVertices: [AirspaceVertex]
}
```

Store pre-built vertices per feature. On `update()`, filter by class toggle and copy to GPU buffer.
  </action>
  <verify>
Project builds with `xcodebuild build`. AirspaceShaders.metal compiles (Metal compiler runs during build). AirspaceManager.swift compiles. The manager can be instantiated with `AirspaceManager(device: device)` without crashes. Verify the FAA API URL is correctly formed by checking the string construction matches: `services6.arcgis.com/ssFJjBXIUyZDrSYZ/arcgis/rest/services/Class_Airspace/FeatureServer/0/query`.
  </verify>
  <done>
AirspaceShaders.metal has `airspace_vertex`, `airspace_fill_fragment`, and `airspace_edge_fragment` shaders that compile. AirspaceManager.swift has FAA data fetching, GeoJSON parsing, ear-clip triangulation calls, extruded mesh generation, and triple-buffered GPU buffer management. All vertex data uses the `AirspaceVertex` struct from ShaderTypes.h. Project builds cleanly.
  </done>
</task>

</tasks>

<verification>
1. `xcodebuild build` succeeds with all 4 new/modified files
2. ShaderTypes.h: `BufferIndexAirspaceVertices = 8` exists, `AirspaceVertex` struct is 32 bytes, `Uniforms` has `cameraPosition`
3. EarClipTriangulator: `triangulate(polygon:)` handles a simple square (4 vertices -> 2 triangles = 6 indices)
4. AirspaceShaders.metal: Metal compiler produces no errors for vertex and fragment functions
5. AirspaceManager: Class compiles, init accepts MTLDevice, has loadAirspace/update/buffer accessor methods
</verification>

<success_criteria>
All airspace rendering infrastructure compiles and is ready for Renderer integration. No runtime validation yet -- that happens in Plan 02 when the manager is wired into the draw loop. The FAA API URL is correctly formed. Mesh extrusion produces floor + ceiling + wall geometry. Class-based coloring is applied per-vertex.
</success_criteria>

<output>
After completion, create `.planning/phases/13-airspace-volume-rendering/13-01-SUMMARY.md`
</output>
