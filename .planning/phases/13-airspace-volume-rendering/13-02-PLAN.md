---
phase: 13-airspace-volume-rendering
plan: 02
type: execute
wave: 2
depends_on: ["13-01"]
files_modified:
  - AirplaneTracker3D/Rendering/Renderer.swift
  - AirplaneTracker3D/Rendering/ThemeManager.swift
  - AirplaneTracker3D/Views/SettingsView.swift
autonomous: false

must_haves:
  truths:
    - "User sees semi-transparent 3D volumes rendered over major airports representing FAA Class B, C, and D airspace boundaries with correct floor/ceiling altitudes"
    - "User can independently toggle visibility of Class B, Class C, and Class D airspace volumes from the UI"
    - "User sees airspace volumes colored distinctly by class (blue for Class B, green for Class C, magenta for Class D) with concentric altitude tiers visible"
    - "Aircraft and trails remain visible through and in front of airspace volumes (volumes do not occlude other scene elements)"
  artifacts:
    - path: "AirplaneTracker3D/Rendering/Renderer.swift"
      provides: "Airspace pipeline states, encode methods, draw loop integration"
      contains: "encodeAirspaceVolumes"
    - path: "AirplaneTracker3D/Rendering/ThemeManager.swift"
      provides: "Per-theme airspace colors for all three classes"
      contains: "airspaceClassBColor"
    - path: "AirplaneTracker3D/Views/SettingsView.swift"
      provides: "Toggle controls for airspace visibility per class"
      contains: "showAirspaceClassB"
  key_links:
    - from: "AirplaneTracker3D/Rendering/Renderer.swift"
      to: "AirplaneTracker3D/Rendering/AirspaceManager.swift"
      via: "airspaceManager property, update() call, buffer accessors in encode method"
      pattern: "airspaceManager"
    - from: "AirplaneTracker3D/Rendering/Renderer.swift"
      to: "AirplaneTracker3D/Rendering/AirspaceShaders.metal"
      via: "pipeline state referencing airspace_vertex/airspace_fill_fragment shader functions"
      pattern: "airspace_vertex"
    - from: "AirplaneTracker3D/Views/SettingsView.swift"
      to: "AirplaneTracker3D/Rendering/Renderer.swift"
      via: "@AppStorage values read by Renderer each frame via UserDefaults"
      pattern: "showAirspaceClass"
    - from: "AirplaneTracker3D/Rendering/Renderer.swift"
      to: "AirplaneTracker3D/Rendering/ThemeManager.swift"
      via: "themeManager.config for airspace colors passed to AirspaceManager.update()"
      pattern: "airspaceClassBColor"
---

<objective>
Wire airspace volume rendering into the Renderer draw loop, add theme-aware colors, and expose per-class toggle controls in SettingsView.

Purpose: Completes the airspace feature by connecting Plan 01's infrastructure (AirspaceManager, shaders, types) to the visible rendering pipeline and user-facing controls.
Output: Users see translucent airspace volumes on the map and can toggle each class independently.
</objective>

<execution_context>
@/Users/mit/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mit/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/ARCHITECTURE.md
@.planning/research/STACK.md
@.planning/phases/13-airspace-volume-rendering/13-01-SUMMARY.md
@AirplaneTracker3D/Rendering/Renderer.swift
@AirplaneTracker3D/Rendering/ThemeManager.swift
@AirplaneTracker3D/Views/SettingsView.swift
@AirplaneTracker3D/Rendering/ShaderTypes.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add theme colors, Renderer pipeline states, draw loop integration, and settings toggles</name>
  <files>
    AirplaneTracker3D/Rendering/ThemeManager.swift
    AirplaneTracker3D/Rendering/Renderer.swift
    AirplaneTracker3D/Views/SettingsView.swift
  </files>
  <action>
**ThemeManager.swift changes:**

Add airspace color fields to `ThemeConfig` struct:
```swift
let airspaceClassBColor: SIMD4<Float>
let airspaceClassCColor: SIMD4<Float>
let airspaceClassDColor: SIMD4<Float>
```

Update all three theme configs in `ThemeManager.configs`:

Day theme:
```swift
airspaceClassBColor: SIMD4<Float>(0.27, 0.40, 1.0, 0.06),
airspaceClassCColor: SIMD4<Float>(0.60, 0.27, 1.0, 0.06),
airspaceClassDColor: SIMD4<Float>(0.27, 0.67, 1.0, 0.06)
```

Night theme (slightly brighter for dark background):
```swift
airspaceClassBColor: SIMD4<Float>(0.33, 0.47, 1.0, 0.08),
airspaceClassCColor: SIMD4<Float>(0.67, 0.33, 1.0, 0.08),
airspaceClassDColor: SIMD4<Float>(0.33, 0.73, 1.0, 0.08)
```

Retro theme (all green, lower alpha):
```swift
airspaceClassBColor: SIMD4<Float>(0.0, 1.0, 0.0, 0.03),
airspaceClassCColor: SIMD4<Float>(0.0, 1.0, 0.0, 0.03),
airspaceClassDColor: SIMD4<Float>(0.0, 1.0, 0.0, 0.03)
```

**Renderer.swift changes:**

1. Add new properties (in the appropriate MARK sections):
```swift
// MARK: - Airspace Pipeline States
let airspaceFillPipeline: MTLRenderPipelineState
let airspaceEdgePipeline: MTLRenderPipelineState
let airspaceManager: AirspaceManager
```

2. In `init(metalView:)`, create the two pipeline states.

**airspaceFillPipeline** -- follows the exact same pattern as `trailPipeline` (lines 340-360 of Renderer.swift):
```swift
let airspaceFillDesc = MTLRenderPipelineDescriptor()
airspaceFillDesc.vertexFunction = library.makeFunction(name: "airspace_vertex")
airspaceFillDesc.fragmentFunction = library.makeFunction(name: "airspace_fill_fragment")
airspaceFillDesc.colorAttachments[0].pixelFormat = metalView.colorPixelFormat
airspaceFillDesc.colorAttachments[0].isBlendingEnabled = true
airspaceFillDesc.colorAttachments[0].rgbBlendOperation = .add
airspaceFillDesc.colorAttachments[0].alphaBlendOperation = .add
airspaceFillDesc.colorAttachments[0].sourceRGBBlendFactor = .sourceAlpha
airspaceFillDesc.colorAttachments[0].destinationRGBBlendFactor = .oneMinusSourceAlpha
airspaceFillDesc.colorAttachments[0].sourceAlphaBlendFactor = .sourceAlpha
airspaceFillDesc.colorAttachments[0].destinationAlphaBlendFactor = .oneMinusSourceAlpha
airspaceFillDesc.depthAttachmentPixelFormat = metalView.depthStencilPixelFormat
airspaceFillDesc.rasterSampleCount = metalView.sampleCount
```

**airspaceEdgePipeline** -- identical blend config but uses `airspace_edge_fragment`:
```swift
let airspaceEdgeDesc = MTLRenderPipelineDescriptor()
airspaceEdgeDesc.vertexFunction = library.makeFunction(name: "airspace_vertex")
airspaceEdgeDesc.fragmentFunction = library.makeFunction(name: "airspace_edge_fragment")
// ... same blend config as fill pipeline ...
```

Both pipeline states: NO vertex descriptor needed (reading raw buffer by index like trails).

3. Initialize the AirspaceManager:
```swift
airspaceManager = AirspaceManager(device: device)
```

4. In `draw(in:)`, populate `uniforms.pointee.cameraPosition = camera.position` wherever uniforms are written (near the existing modelMatrix/viewMatrix/projectionMatrix writes).

5. Read airspace toggle settings from UserDefaults each frame (same pattern as trailLength/trailWidth at ~line 809-816):
```swift
let showAirspace = UserDefaults.standard.bool(forKey: "showAirspace")
let showClassB = UserDefaults.standard.bool(forKey: "showAirspaceClassB")
let showClassC = UserDefaults.standard.bool(forKey: "showAirspaceClassC")
let showClassD = UserDefaults.standard.bool(forKey: "showAirspaceClassD")
```

6. Trigger airspace data loading based on camera bounds. Compute visible bounds from camera position and distance. Call `airspaceManager.loadAirspace(bounds:)` asynchronously when bounds change significantly. Use a frame-throttled check (every ~120 frames, ~2 seconds):
```swift
if frameCounter % 120 == 0 && showAirspace {
    let bounds = computeVisibleBounds()  // derive from camera position + distance
    Task { await airspaceManager.loadAirspace(bounds: bounds) }
}
```

For `computeVisibleBounds()`: use `coordSystem.xToLon()` and `coordSystem.zToLat()` to convert camera-centered world-space box to geographic bounds. Estimate visible range from camera distance (e.g., `camera.distance * 0.5` in world units as the half-extent).

7. Update airspace manager with class filters and current buffer:
```swift
airspaceManager.showClassB = showClassB
airspaceManager.showClassC = showClassC
airspaceManager.showClassD = showClassD
airspaceManager.update(bufferIndex: currentBufferIndex, themeConfig: themeManager.config)
```

The `update()` method on AirspaceManager should accept the ThemeConfig to apply theme-appropriate colors when writing vertices to the GPU buffer.

8. Add `encodeAirspaceVolumes()` method and call in draw loop:

```swift
private func encodeAirspaceVolumes(encoder: MTLRenderCommandEncoder, uniformBuffer: MTLBuffer) {
    // Fill pass
    let fillCount = airspaceManager.fillVertexCount(at: currentBufferIndex)
    if fillCount > 0 {
        encoder.setRenderPipelineState(airspaceFillPipeline)
        encoder.setDepthStencilState(glowDepthStencilState)  // depth read, no write
        encoder.setCullMode(.none)  // render both faces for transparency
        encoder.setVertexBuffer(uniformBuffer, offset: 0, index: Int(BufferIndexUniforms.rawValue))
        encoder.setVertexBuffer(airspaceManager.fillBuffer(at: currentBufferIndex), offset: 0,
                                 index: Int(BufferIndexAirspaceVertices.rawValue))
        encoder.drawPrimitives(type: .triangle, vertexStart: 0, vertexCount: fillCount)
    }

    // Edge pass
    let edgeCount = airspaceManager.edgeVertexCount(at: currentBufferIndex)
    if edgeCount > 0 {
        encoder.setRenderPipelineState(airspaceEdgePipeline)
        encoder.setDepthStencilState(glowDepthStencilState)
        encoder.setVertexBuffer(uniformBuffer, offset: 0, index: Int(BufferIndexUniforms.rawValue))
        encoder.setVertexBuffer(airspaceManager.edgeBuffer(at: currentBufferIndex), offset: 0,
                                 index: Int(BufferIndexAirspaceVertices.rawValue))
        encoder.drawPrimitives(type: .line, vertexStart: 0, vertexCount: edgeCount)
    }

    // Restore cull mode
    encoder.setCullMode(.none)
}
```

9. Insert the call in the draw loop. The airspace volumes go AFTER spinning parts and wireframe restore, BEFORE trails:
```swift
// After: encodeSpinningParts(encoder:, uniformBuffer:)
// After: if isRetro { encoder.setTriangleFillMode(.fill) }

// Encode airspace volumes (translucent, depth-read no-write)
if showAirspace {
    encodeAirspaceVolumes(encoder: encoder, uniformBuffer: uniformBuffer)
}

// Before: encodeTrails(encoder:, uniformBuffer:, drawableSize:)
```

This render order ensures:
- Airspace volumes are occluded by terrain (terrain wrote depth)
- Aircraft render on top of volumes (aircraft bodies write depth after volumes)
- Wait -- aircraft render BEFORE airspace in the current order above. Let me reconsider.

Actually, looking at the research ARCHITECTURE.md, it says airspace should render AFTER opaque geometry but BEFORE trails. The current draw order is: altitude lines -> aircraft -> spinning parts -> [wireframe restore] -> trails -> labels -> glow. So airspace should go after spinning parts but before trails. This is correct because:
- Terrain already wrote depth, so volumes behind terrain are correctly hidden
- Aircraft are opaque and already wrote depth, so volumes behind aircraft are hidden too
- Volumes don't write depth, so they don't occlude trails/labels/glow rendered after them

This is the correct position. The key insight: because airspace has depth-write OFF, aircraft that are physically INSIDE the airspace volume will render correctly (they were drawn with depth-write ON earlier, so their depth values are in the buffer, and they visually appear in front).

**SettingsView.swift changes:**

Add new @AppStorage toggles:
```swift
// MARK: - Airspace Settings
@AppStorage("showAirspace") private var showAirspace: Bool = true
@AppStorage("showAirspaceClassB") private var showAirspaceClassB: Bool = true
@AppStorage("showAirspaceClassC") private var showAirspaceClassC: Bool = true
@AppStorage("showAirspaceClassD") private var showAirspaceClassD: Bool = true
```

Defaults: `showAirspace = true` (on by default, this is a feature users expect), individual classes all true.

Add an "Airspace" section to the `renderingTab` form, after the altitude exaggeration slider:
```swift
Section("Airspace Volumes") {
    Toggle("Show Airspace", isOn: $showAirspace)
    if showAirspace {
        Toggle("Class B", isOn: $showAirspaceClassB)
            .foregroundColor(.blue)
        Toggle("Class C", isOn: $showAirspaceClassC)
            .foregroundColor(.purple)
        Toggle("Class D", isOn: $showAirspaceClassD)
            .foregroundColor(.cyan)
    }
}
```

The per-class toggles only appear when the master toggle is enabled. Color labels hint at the class color.

Also increase the SettingsView frame height to accommodate the new controls: change `.frame(width: 400, height: 350)` to `.frame(width: 400, height: 450)`.
  </action>
  <verify>
1. `xcodebuild build` succeeds
2. Launch the app and verify airspace volumes appear around the default center (Seattle, KSEA has Class B airspace)
3. Verify volumes are semi-transparent (map tiles and terrain visible through them)
4. Verify aircraft fly through/over volumes without being occluded
5. Open Settings > Rendering tab and verify the "Airspace Volumes" section has 4 toggles
6. Toggle off "Class B" and verify Class B volumes disappear while C and D remain
7. Toggle off "Show Airspace" and verify all volumes disappear
8. Switch theme (T key) and verify colors change (blue/purple/cyan for day, brighter for night, green for retro)
  </verify>
  <done>
Airspace volumes render in the draw loop at the correct position (after aircraft, before trails). Per-class colors match the spec (blue=B, purple/green=C, cyan=D). All four toggles work independently. Volumes are translucent and do not occlude aircraft or trails. Theme switching updates airspace colors correctly. Build succeeds.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: Verify airspace volumes render correctly</name>
  <files>None (visual verification only)</files>
  <action>
Human verifies the complete airspace volume rendering system: FAA data fetch, polygon triangulation, extruded 3D meshes, semi-transparent Metal rendering with per-class coloring, and Settings UI toggles for independent class control.

Steps to verify:
1. Launch the app (it should center on Seattle area by default)
2. Observe: Semi-transparent blue volumes should appear around KSEA (Class B) forming an inverted wedding cake pattern with multiple altitude tiers
3. Look for smaller volumes at nearby airports (Class C/D in the region)
4. Verify transparency: map tiles and terrain should be visible through the volumes
5. Verify aircraft: planes should appear in front of/through the volumes, not hidden behind them
6. Open Settings (Cmd+,) > Rendering tab > Airspace Volumes section
7. Toggle "Class B" off -- blue volumes disappear, others remain
8. Toggle "Class B" back on, toggle "Class C" off -- verify only Class C disappears
9. Toggle "Show Airspace" off -- all volumes disappear
10. Toggle "Show Airspace" back on -- all volumes reappear
11. Press T to cycle themes: verify blue/purple/cyan (day), brighter variants (night), green (retro)
12. Pan to a different area (e.g., zoom out to see more airports) and verify new airspace data loads

Resume signal: Type "approved" if airspace volumes render correctly with proper transparency and controls, or describe any issues.
  </action>
  <verify>All 12 verification steps pass visual inspection.</verify>
  <done>User confirms airspace volumes render correctly with proper transparency, class coloring, toggle controls, and theme support.</done>
</task>

</tasks>

<verification>
1. `xcodebuild build` succeeds with all modifications
2. App launches and displays translucent airspace volumes around airports
3. Class B = blue, Class C = purple, Class D = cyan coloring visible
4. Multiple altitude tiers visible (inverted wedding cake for Class B)
5. All four Settings toggles work independently
6. Volumes do not occlude aircraft, trails, labels, or glow sprites
7. Theme cycling changes airspace colors appropriately
8. Panning the camera triggers loading of new airspace data for the visible area
</verification>

<success_criteria>
Phase 13 success criteria met:
1. Semi-transparent 3D volumes rendered over major airports with correct floor/ceiling altitudes
2. Independent toggle visibility of Class B, Class C, and Class D from UI
3. Distinct coloring by class with concentric altitude tiers visible
4. Aircraft and trails remain visible through and in front of volumes
</success_criteria>

<output>
After completion, create `.planning/phases/13-airspace-volume-rendering/13-02-SUMMARY.md`
</output>
