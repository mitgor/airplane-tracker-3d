---
phase: 14-coverage-heatmap
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - AirplaneTracker3D/Rendering/ShaderTypes.h
  - AirplaneTracker3D/Rendering/HeatmapShaders.metal
  - AirplaneTracker3D/Rendering/HeatmapManager.swift
autonomous: true

must_haves:
  truths:
    - "HeatmapManager accumulates aircraft positions into a 32x32 density grid"
    - "Grid data is uploaded to a Metal texture each frame as an RGBA color ramp"
    - "A ground-plane quad with the heatmap texture can be rendered with alpha blending"
  artifacts:
    - path: "AirplaneTracker3D/Rendering/HeatmapManager.swift"
      provides: "Heatmap grid accumulation, texture generation, ground quad geometry, and triple-buffered GPU resources"
      min_lines: 100
    - path: "AirplaneTracker3D/Rendering/HeatmapShaders.metal"
      provides: "Vertex shader for textured ground quad and fragment shader sampling heatmap texture with alpha"
      min_lines: 30
    - path: "AirplaneTracker3D/Rendering/ShaderTypes.h"
      provides: "BufferIndexHeatmapVertices enum value and HeatmapVertex struct"
      contains: "BufferIndexHeatmapVertices"
  key_links:
    - from: "AirplaneTracker3D/Rendering/HeatmapManager.swift"
      to: "AirplaneTracker3D/Rendering/ShaderTypes.h"
      via: "HeatmapVertex struct usage"
      pattern: "HeatmapVertex"
    - from: "AirplaneTracker3D/Rendering/HeatmapShaders.metal"
      to: "AirplaneTracker3D/Rendering/ShaderTypes.h"
      via: "includes ShaderTypes.h for buffer indices and vertex types"
      pattern: "BufferIndexHeatmapVertices"
---

<objective>
Build the HeatmapManager data pipeline: a 32x32 CPU grid that accumulates aircraft detection counts, converts them to a color-ramped RGBA Metal texture, and provides a textured ground-plane quad for rendering.

Purpose: This is the core data engine for the coverage heatmap feature (HEAT-01). Without it, there is no density visualization.
Output: HeatmapManager.swift, HeatmapShaders.metal, updated ShaderTypes.h
</objective>

<execution_context>
@/Users/mit/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mit/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@AirplaneTracker3D/Rendering/ShaderTypes.h
@AirplaneTracker3D/Rendering/AirspaceManager.swift
@AirplaneTracker3D/Rendering/AirspaceShaders.metal
@AirplaneTracker3D/Map/MapCoordinateSystem.swift
@AirplaneTracker3D/Models/AircraftModel.swift
@AirplaneTracker3D/Rendering/Renderer.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add HeatmapVertex and buffer index to ShaderTypes.h</name>
  <files>AirplaneTracker3D/Rendering/ShaderTypes.h</files>
  <action>
Add a new buffer index `BufferIndexHeatmapVertices = 9` to the BufferIndex enum (after BufferIndexAirspaceVertices = 8).

Add a new vertex struct for the heatmap textured quad:

```c
// Per-vertex data for heatmap ground quad (position + texCoord, 32 bytes)
typedef struct {
    simd_float3 position;    // 12 bytes: world-space XYZ
    float _pad0;             // 4 bytes: padding
    simd_float2 texCoord;    // 8 bytes: UV for heatmap texture sampling
    simd_float2 _pad1;       // 8 bytes: padding to 32 bytes
} HeatmapVertex;
// Total: 32 bytes
```

This follows the existing pattern of ShaderTypes.h structs (AirspaceVertex is 32 bytes with explicit padding).
  </action>
  <verify>Project builds with `xcodebuild -project AirplaneTracker3D.xcodeproj -scheme AirplaneTracker3D build 2>&1 | tail -5` showing BUILD SUCCEEDED.</verify>
  <done>ShaderTypes.h contains BufferIndexHeatmapVertices = 9 and HeatmapVertex struct with position and texCoord fields.</done>
</task>

<task type="auto">
  <name>Task 2: Create HeatmapShaders.metal</name>
  <files>AirplaneTracker3D/Rendering/HeatmapShaders.metal</files>
  <action>
Create a new Metal shader file at `AirplaneTracker3D/Rendering/HeatmapShaders.metal`. Follow the pattern of AirspaceShaders.metal.

Include `ShaderTypes.h`.

Define a vertex output struct `HeatmapVertexOut` with:
- `float4 position [[position]]`
- `float2 texCoord`

Vertex shader `heatmap_vertex`:
- Reads HeatmapVertex from `buffer(BufferIndexHeatmapVertices)` by vertexID
- Reads Uniforms from `buffer(BufferIndexUniforms)`
- Transforms position through viewMatrix and projectionMatrix (no modelMatrix needed -- positions are already in world space)
- Passes through texCoord

Fragment shader `heatmap_fragment`:
- Takes `HeatmapVertexOut` as stage_in
- Samples `texture2d<float>` at index 0 using texCoord with `sampler(mag_filter::linear, min_filter::linear)`
- The texture already contains premultiplied RGBA from the CPU-side color ramp
- If alpha < 0.01, `discard_fragment()` (skip empty cells)
- Returns the sampled color directly (premultiplied alpha)

This is a simple textured quad shader, similar to the existing `vertex_textured`/`fragment_textured` pair but reading from a different buffer index and using the heatmap texture.
  </action>
  <verify>Project builds successfully. The .metal file is compiled by Xcode as part of the default Metal library.</verify>
  <done>HeatmapShaders.metal exists with heatmap_vertex and heatmap_fragment shader functions that compile without errors.</done>
</task>

<task type="auto">
  <name>Task 3: Create HeatmapManager.swift</name>
  <files>AirplaneTracker3D/Rendering/HeatmapManager.swift</files>
  <action>
Create `AirplaneTracker3D/Rendering/HeatmapManager.swift` following the AirspaceManager pattern. This is the core of the heatmap feature.

Key design (per project decision: CPU-side heatmap grid with texture upload, no compute shader):

**Grid State:**
- `private var grid: [UInt32]` -- 32x32 flat array (1024 cells), each cell counts aircraft detections
- Grid bounds: track the geographic bounds (west, south, east, north) of the current visible area
- The grid covers the camera's visible area at the time of first accumulation, and resets when camera moves significantly (>50% shift)

**Public API:**
- `func accumulate(states: [InterpolatedAircraftState])` -- For each aircraft with valid lat/lon, map its position into the 32x32 grid and increment the corresponding cell. Use the MapCoordinateSystem shared instance to get visible bounds from the Renderer (pass bounds as parameter: `west, south, east, north`). Normalize aircraft lat/lon into 0..1 range within those bounds, multiply by 32, floor to get grid X/Y, increment `grid[y * 32 + x]`.
- `func update(bufferIndex: Int, themeConfig: ThemeConfig)` -- Generate the RGBA texture from the grid, upload to Metal texture, update the ground-quad vertex buffer.
- Expose texture and vertex buffer for Renderer to draw.

**Texture Generation (CPU-side color ramp):**
- Find `maxVal = max(grid)` (clamp to at least 1 to avoid division by zero)
- For each cell, compute `intensity = Float(grid[cell]) / Float(maxVal)`
- Map intensity to RGBA color ramp (theme-aware):
  - Day: blue(0,100,255) at low intensity -> cyan(0,255,255) at high intensity, alpha = 0.15 + intensity * 0.45
  - Night: dark-blue(0,80,180) at low -> bright-cyan(0,255,255) at high, alpha = 0.15 + intensity * 0.55
  - Retro: dark-green(0,60,0) at low -> bright-green(0,255,0) at high, alpha = 0.15 + intensity * 0.55
- Zero cells get alpha = 0 (transparent)
- Premultiply alpha for correct blending
- Write RGBA8 pixels into a `MTLTexture` (32x32, .rgba8Unorm) using `texture.replace()`

**Ground Quad Geometry (triple-buffered HeatmapVertex buffers):**
- 6 vertices (2 triangles) forming a quad on the ground plane (Y = 0.01 -- slightly above ground to prevent z-fighting with map tiles)
- Quad corners computed from the geographic bounds: use `MapCoordinateSystem.shared.lonToX()` and `latToZ()` to get world-space X/Z
- texCoord: (0,0) at northwest corner, (1,1) at southeast corner
- Triple-buffered like AirspaceManager: pre-allocate 3 vertex buffers at init, write to `buffers[bufferIndex]` each frame

**Bounds Tracking:**
- Store `lastBounds` (west, south, east, north)
- When `accumulate()` is called, if bounds shifted >50% of the span in either axis, reset the grid to zeros and update `lastBounds`
- This prevents stale data from a previous camera position

**Init:**
- Takes `MTLDevice`
- Pre-allocate the 32x32 Metal texture (reused, replaced each frame)
- Pre-allocate 3 HeatmapVertex buffers (6 vertices each = 6 * 32 bytes = 192 bytes per buffer)

**Accessors for Renderer:**
- `func vertexBuffer(at index: Int) -> MTLBuffer`
- `func vertexCount() -> Int` (always 6)
- `func heatmapTexture() -> MTLTexture?`
- `var hasData: Bool` (true if any grid cell > 0)

Follow AirspaceManager conventions: `final class`, `private let device: MTLDevice`, `private let coordSystem = MapCoordinateSystem.shared`.
  </action>
  <verify>Project builds successfully with `xcodebuild build`. HeatmapManager can be instantiated with a device.</verify>
  <done>HeatmapManager.swift exists with grid accumulation, theme-aware RGBA texture generation, ground quad geometry, and triple-buffered vertex buffers. All methods compile and the class follows the AirspaceManager pattern.</done>
</task>

</tasks>

<verification>
1. `xcodebuild -project AirplaneTracker3D.xcodeproj -scheme AirplaneTracker3D build 2>&1 | tail -5` shows BUILD SUCCEEDED
2. ShaderTypes.h has BufferIndexHeatmapVertices = 9 and HeatmapVertex struct
3. HeatmapShaders.metal compiles as part of the default Metal library
4. HeatmapManager.swift compiles and follows triple-buffered pattern
</verification>

<success_criteria>
- ShaderTypes.h extended with heatmap buffer index and vertex type
- HeatmapShaders.metal has vertex and fragment shaders for textured ground quad
- HeatmapManager.swift accumulates aircraft positions into 32x32 grid, generates theme-aware RGBA texture, provides triple-buffered quad geometry
- All three files compile without errors in the Xcode project
</success_criteria>

<output>
After completion, create `.planning/phases/14-coverage-heatmap/14-01-SUMMARY.md`
</output>
