---
phase: 15-visual-polish
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - AirplaneTracker3D/Rendering/AirspaceLabelManager.swift
  - AirplaneTracker3D/Rendering/Renderer.swift
  - AirplaneTracker3D/Rendering/AirspaceManager.swift
autonomous: true

must_haves:
  truths:
    - "User sees text labels at the center of each visible airspace volume identifying the airport name"
    - "Airspace labels appear and disappear with airspace visibility toggles"
    - "Airspace labels update when the camera moves to a new area (new airspace data loads)"
  artifacts:
    - path: "AirplaneTracker3D/Rendering/AirspaceLabelManager.swift"
      provides: "Airspace label texture atlas and instance buffer management"
      contains: "class AirspaceLabelManager"
    - path: "AirplaneTracker3D/Rendering/Renderer.swift"
      provides: "Airspace label rendering in draw loop"
      contains: "encodeAirspaceLabels"
    - path: "AirplaneTracker3D/Rendering/AirspaceManager.swift"
      provides: "Public access to features array for label positioning"
      contains: "visibleFeatures"
  key_links:
    - from: "Renderer.swift draw loop"
      to: "AirspaceLabelManager.update()"
      via: "passes airspaceManager features + class filters + bufferIndex"
      pattern: "airspaceLabelManager\\.update"
    - from: "AirspaceLabelManager"
      to: "AirspaceManager.features"
      via: "reads features for centroid + name"
      pattern: "features"
    - from: "Renderer encodeAirspaceLabels"
      to: "labelPipeline"
      via: "reuses existing label shader pipeline"
      pattern: "labelPipeline"
---

<objective>
Add text labels at the center of each airspace volume showing the airport name.

Purpose: VIS-03 gives users immediate identification of which airport each airspace volume belongs to, completing the airspace visualization feature.
Output: New AirspaceLabelManager class, updated Renderer with airspace label rendering, updated AirspaceManager with public feature access.
</objective>

<execution_context>
@/Users/mit/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mit/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@AirplaneTracker3D/Rendering/AirportLabelManager.swift
@AirplaneTracker3D/Rendering/AirspaceManager.swift
@AirplaneTracker3D/Rendering/Renderer.swift
@AirplaneTracker3D/Rendering/LabelManager.swift
@AirplaneTracker3D/Rendering/ThemeManager.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create AirspaceLabelManager</name>
  <files>
    AirplaneTracker3D/Rendering/AirspaceLabelManager.swift
    AirplaneTracker3D/Rendering/AirspaceManager.swift
  </files>
  <action>
**Create a new file `AirspaceLabelManager.swift`** modeled closely on `AirportLabelManager.swift` but adapted for airspace features. Key differences from AirportLabelManager:

- Labels are dynamic (airspace features change when camera moves), not static (airports loaded once from JSON).
- Position is at the polygon centroid at mid-altitude (between floor and ceiling), not at a fixed ground position.
- Text shows the airspace name + class (e.g., "SEA Class B").

**AirspaceLabelManager class structure:**

```swift
import MetalKit
import CoreText
import AppKit

final class AirspaceLabelManager {
    // Atlas: 1024x512, slots 128x32 => 128 slots (same as AirportLabelManager)
    private let atlasWidth = 1024
    private let atlasHeight = 512
    private let slotWidth = 128
    private let slotHeight = 32
    private let columnsPerRow = 8
    private let rowCount = 16

    // Texture atlas
    private(set) var textureAtlas: MTLTexture?

    // Triple-buffered label instance buffers
    private var labelBuffers: [MTLBuffer] = []
    private var labelCounts: [Int] = [0, 0, 0]

    let maxVisibleLabels = 60

    // Distance culling
    let maxDistance: Float = 500.0
    let fadeDistance: Float = 300.0

    // Cache: feature name -> slot index (avoid re-rasterization)
    private var labelCache: [String: Int] = [:]
    private var nextSlot = 0

    // CGContext for rasterization
    private var cgContext: CGContext?

    private let device: MTLDevice
}
```

**init(device:):**
- Create the texture atlas (same pattern as AirportLabelManager).
- Clear atlas to transparent.
- Create reusable CGContext (128x32).
- Allocate triple-buffered label instance buffers for maxVisibleLabels.

**rasterizeLabel(text:slot:config:):**
- Same pattern as AirportLabelManager.rasterizeLabel but:
  - Use a slightly smaller font (12pt bold) to fit "NAME Class X" text.
  - Background color: use `config.airportLabelColor` tinted dark (same as airport labels) for visual consistency.
  - Text color: use `config.airportLabelColor` at full opacity.

**updateTheme(_ config: ThemeConfig):**
- Clear atlas, reset cache and nextSlot to 0.
- Labels will be re-rasterized lazily on next update().

**update(features:showClassB:showClassC:showClassD:bufferIndex:cameraPosition:themeConfig:):**
- Filter features by class visibility (same logic as AirspaceManager.update).
- For each visible feature:
  1. Compute centroid: average of all fill vertices' X and Z positions. Y position = midpoint between floor and ceiling altitude (floorFeet * 0.001 + ceilingFeet * 0.001) / 2. Use the same altitudeScale as AirspaceManager (0.001).
     - Simpler: since AirspaceFeature already has fillVertices, compute centroid as average of the first triangle's vertices (3 positions). Or better: compute centroid from the feature's fillVertices by averaging all unique X,Z positions from the floor face only (first triCount * 3 vertices where Y == floorY). Actually simplest: `(floorFeet + ceilingFeet) / 2.0 * 0.001` for Y, and average the X,Z of the first 3 fillVertices for horizontal position.
  2. Compute distance to camera.
  3. Skip if distance > maxDistance.
  4. Build label text: `"\(feature.name)"` (just the name, class is shown by color). If name is too long, truncate to 12 characters.
  5. Check labelCache for this name. If not cached, rasterize into next available slot and cache it.
  6. Write LabelInstanceData to buffer (same struct as airport/aircraft labels: position, size=6.0, atlasUV, atlasSize, opacity based on distance fade).
- Sort by distance (nearest first), cap at maxVisibleLabels.

**Deduplicate by name:** Multiple airspace features share the same name (e.g., "SEA" Class B has multiple tiers). Only show one label per unique name. Use a Set<String> to track which names have already been added. Pick the tier with the largest area (most fill vertices) or simply the first one encountered.

**Buffer accessors:** `labelBuffer(at:)`, `labelCount(at:)` -- same pattern as AirportLabelManager.

**In AirspaceManager.swift -- expose features for the label manager:**
- Add a computed property: `var visibleFeatures: [AirspaceFeature] { return features }`
- This gives read access to the cached features without exposing internal mutation.

**Important:** Reuse the existing `LabelInstanceData` struct and `labelPipeline` shader. Do NOT create new Metal shader functions. The label vertex/fragment shaders are generic billboard renderers -- they work with any atlas.
  </action>
  <verify>
Build with `xcodebuild -project AirplaneTracker3D.xcodeproj -scheme AirplaneTracker3D -configuration Debug build 2>&1 | tail -5` -- must compile. Grep for `class AirspaceLabelManager` in the new file.
  </verify>
  <done>
AirspaceLabelManager.swift exists with texture atlas, triple-buffered label buffers, centroid computation from AirspaceFeature geometry, distance culling, name deduplication, and theme-aware rasterization. AirspaceManager exposes `visibleFeatures` property. Project compiles.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate airspace labels into Renderer</name>
  <files>AirplaneTracker3D/Rendering/Renderer.swift</files>
  <action>
Wire AirspaceLabelManager into the Renderer following the exact same pattern as AirportLabelManager.

**In Renderer.swift init():**
1. Add property: `let airspaceLabelManager: AirspaceLabelManager`
2. Initialize after airspaceManager: `airspaceLabelManager = AirspaceLabelManager(device: device)`

**In handleThemeChange(_:):**
- Add: `airspaceLabelManager.updateTheme(config)` (re-rasterize labels with new theme colors).

**Add encodeAirspaceLabels method** (copy pattern from `encodeAirportLabels`):
```swift
private func encodeAirspaceLabels(encoder: MTLRenderCommandEncoder, uniformBuffer: MTLBuffer) {
    let count = airspaceLabelManager.labelCount(at: currentBufferIndex)
    guard count > 0 else { return }

    encoder.setRenderPipelineState(labelPipeline)
    encoder.setDepthStencilState(glowDepthStencilState)

    encoder.setVertexBuffer(uniformBuffer, offset: 0, index: Int(BufferIndexUniforms.rawValue))
    encoder.setVertexBuffer(airspaceLabelManager.labelBuffer(at: currentBufferIndex), offset: 0,
                             index: Int(BufferIndexLabelInstances.rawValue))

    if let atlas = airspaceLabelManager.textureAtlas {
        encoder.setFragmentTexture(atlas, index: 0)
    }

    encoder.drawPrimitives(
        type: .triangle,
        vertexStart: 0,
        vertexCount: 6,
        instanceCount: count
    )
}
```

**In the draw() method:**
1. After the existing `airspaceManager.update(bufferIndex:themeConfig:)` call (~line 1008), add:
```swift
airspaceLabelManager.update(
    features: airspaceManager.visibleFeatures,
    showClassB: showClassB,
    showClassC: showClassC,
    showClassD: showClassD,
    bufferIndex: currentBufferIndex,
    cameraPosition: camera.position,
    themeConfig: config
)
```

2. In the draw loop, after `encodeAirspaceVolumes` calls (both in the `if !states.isEmpty` branch and the `else` branch where airspace is rendered without aircraft), add:
```swift
if showAirspace {
    encodeAirspaceLabels(encoder: encoder, uniformBuffer: uniformBuffer)
}
```
Place it right after each `encodeAirspaceVolumes` call so labels render on top of volumes.

**Important:** The airspace labels should render AFTER airspace volumes (so they appear on top) but BEFORE aircraft labels and glow (so aircraft remain most prominent). Place the `encodeAirspaceLabels` call right after each `encodeAirspaceVolumes` call.

**Do NOT** add any new pipeline states, shaders, or vertex descriptors. Reuse `labelPipeline` which is already set up for billboarded text sprites.
  </action>
  <verify>
Build with `xcodebuild -project AirplaneTracker3D.xcodeproj -scheme AirplaneTracker3D -configuration Debug build 2>&1 | tail -5` -- must compile without errors. Grep Renderer.swift for `airspaceLabelManager` -- should find init, update, and encode calls. Grep for `encodeAirspaceLabels` -- should find method definition and 2 call sites (with-aircraft and without-aircraft branches).
  </verify>
  <done>
Renderer creates AirspaceLabelManager, updates it each frame with filtered airspace features, and renders airspace labels using the existing label pipeline. Labels appear at the centroid of airspace volumes, show airport names, are distance-culled, and respect class visibility toggles and theme changes. Project compiles and runs without errors.
  </done>
</task>

</tasks>

<verification>
1. `xcodebuild -project AirplaneTracker3D.xcodeproj -scheme AirplaneTracker3D build` succeeds
2. AirspaceLabelManager.swift exists with centroid computation, atlas management, distance culling
3. Renderer.swift creates, updates, and encodes airspace labels
4. Labels only appear when showAirspace is true and respect per-class toggles
5. Labels render after airspace volumes but before aircraft labels
</verification>

<success_criteria>
- Text labels appear at the center of each visible airspace volume showing the airport name
- Labels respect airspace visibility toggles (showAirspace, showClassB/C/D)
- Labels update when airspace data changes (camera moves to new area)
- Labels are distance-culled and fade with distance
- Project compiles and runs without errors
</success_criteria>

<output>
After completion, create `.planning/phases/15-visual-polish/15-02-SUMMARY.md`
</output>
