---
phase: 16-camera-following-api
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - AirplaneTracker3D/DataLayer/FlightDataActor.swift
  - AirplaneTracker3D/ContentView.swift
autonomous: true

must_haves:
  truths:
    - "Aircraft load for whatever geographic area the camera is pointed at, not just Seattle"
    - "Panning the camera to a new continent causes aircraft to appear for that area within one polling cycle (5 seconds)"
    - "Switching data source still works and respects the current camera position"
  artifacts:
    - path: "AirplaneTracker3D/DataLayer/FlightDataActor.swift"
      provides: "Dynamic query center that updates between polling cycles"
      contains: "updateCenter"
    - path: "AirplaneTracker3D/ContentView.swift"
      provides: "Camera-to-polling-center pipeline that feeds camera lat/lon to the actor"
      contains: "updateCenter"
  key_links:
    - from: "AirplaneTracker3D/Rendering/Renderer.swift"
      to: "AirplaneTracker3D/ContentView.swift"
      via: ".cameraTargetUpdated notification (already exists, posted every 30 frames)"
      pattern: "cameraTargetUpdated"
    - from: "AirplaneTracker3D/ContentView.swift"
      to: "AirplaneTracker3D/DataLayer/FlightDataActor.swift"
      via: "flightDataManager.updateCenter() call in .cameraTargetUpdated handler"
      pattern: "updateCenter"
    - from: "AirplaneTracker3D/DataLayer/FlightDataActor.swift"
      to: "API providers (airplanes.live, adsb.lol)"
      via: "fetchWithFallback reads currentCenter instead of closure-captured center"
      pattern: "currentCenter"
---

<objective>
Make aircraft visible wherever the user looks by connecting the existing camera position broadcast to the API polling center.

Purpose: Currently FlightDataActor polls with a fixed Seattle center coordinate captured at startup. The Renderer already broadcasts the camera target position every ~0.5s via `.cameraTargetUpdated`, and ContentView already converts this to lat/lon. The missing link is feeding that lat/lon into the polling actor so each API call queries the area the user is actually viewing.

Output: Modified FlightDataActor with mutable query center + ContentView wiring that updates the center on each camera target notification.
</objective>

<execution_context>
@/Users/mit/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mit/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@AirplaneTracker3D/DataLayer/FlightDataActor.swift
@AirplaneTracker3D/ContentView.swift
@AirplaneTracker3D/Map/MapCoordinateSystem.swift
@AirplaneTracker3D/Rendering/Renderer.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add dynamic center to FlightDataActor and FlightDataManager</name>
  <files>AirplaneTracker3D/DataLayer/FlightDataActor.swift</files>
  <action>
Modify FlightDataActor to use a mutable center property instead of a closure-captured center parameter:

1. Add a private stored property to FlightDataActor:
   ```swift
   private var currentCenter: (lat: Double, lon: Double) = (lat: 47.6, lon: -122.3)
   ```

2. Add a public `updateCenter` method on the actor:
   ```swift
   func updateCenter(lat: Double, lon: Double) {
       currentCenter = (lat: lat, lon: lon)
   }
   ```

3. Modify `startPolling(mode:center:)` to store the initial center in `currentCenter`, then have the polling loop read `currentCenter` on each cycle instead of the closure-captured `center` parameter. Change line 99 from:
   ```swift
   let aircraft = await self.fetchWithFallback(mode: mode, center: center)
   ```
   to:
   ```swift
   let currentCenter = await self.currentCenter
   let aircraft = await self.fetchWithFallback(mode: mode, center: currentCenter)
   ```
   Also set `currentCenter = center` at the top of `startPolling` (before the AsyncStream creation).

4. Modify FlightDataManager (in the same file) to expose `updateCenter`:
   ```swift
   func updateCenter(lat: Double, lon: Double) {
       Task {
           await actor.updateCenter(lat: lat, lon: lon)
       }
   }
   ```

5. Also update `switchMode(to:center:)` on FlightDataManager to set the center:
   In the existing `switchMode` method, after calling `actor.switchMode(to: mode)`, also call `actor.updateCenter(lat: center.lat, lon: center.lon)` in the same Task block.

IMPORTANT: Do NOT modify MapCoordinateSystem.swift. Its centerLat/centerLon are for the Mercator projection coordinate system and must stay fixed at Seattle (47.6, -122.3).
  </action>
  <verify>
Build the project: `cd /Users/mit/Documents/GitHub/airplane-tracker-3d && xcodebuild -scheme AirplaneTracker3D -destination 'platform=macOS' build 2>&1 | tail -5`

Verify no build errors. The polling loop should compile with the new currentCenter read pattern.
  </verify>
  <done>
FlightDataActor has a mutable `currentCenter` property, an `updateCenter(lat:lon:)` method, and the polling loop reads `currentCenter` each cycle instead of a fixed captured value. FlightDataManager exposes `updateCenter(lat:lon:)` as a main-actor-safe wrapper. Project builds without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire camera position updates to polling center in ContentView</name>
  <files>AirplaneTracker3D/ContentView.swift</files>
  <action>
Connect the existing `.cameraTargetUpdated` notification handler in ContentView to update the FlightDataManager's query center:

1. In the `.onReceive(NotificationCenter.default.publisher(for: .cameraTargetUpdated))` handler (around line 181-188), after the existing lines that update `centerLat` and `centerLon`, add a call to update the polling center:
   ```swift
   flightDataManager.updateCenter(lat: centerLat, lon: centerLon)
   ```
   Place this AFTER the `centerLat = ...` and `centerLon = ...` assignments so it uses the freshly converted values.

2. In the `.onReceive(NotificationCenter.default.publisher(for: .switchDataSource))` handler (around line 207-214), change the center from the hardcoded MapCoordinateSystem values to the current camera position:
   ```swift
   let center = (lat: centerLat, lon: centerLon)
   ```
   This replaces the existing:
   ```swift
   let center = (lat: MapCoordinateSystem.shared.centerLat,
                 lon: MapCoordinateSystem.shared.centerLon)
   ```
   So when the user switches data source, it starts polling from where the camera currently is, not from Seattle.

3. Leave the `.onAppear` handler's initial center as MapCoordinateSystem.shared values (Seattle). This is correct because on first launch the camera starts at the coordinate system origin, which IS Seattle. The camera target updates will quickly override this once the Renderer starts posting.

This completes the pipeline: Renderer posts camera target every ~30 frames -> ContentView receives notification, converts to lat/lon -> ContentView calls flightDataManager.updateCenter -> next polling cycle in FlightDataActor uses new center -> API returns aircraft for camera area.
  </action>
  <verify>
Build the project: `cd /Users/mit/Documents/GitHub/airplane-tracker-3d && xcodebuild -scheme AirplaneTracker3D -destination 'platform=macOS' build 2>&1 | tail -5`

Verify no build errors. Then grep to confirm the wiring is in place:
- `grep -n "updateCenter" AirplaneTracker3D/ContentView.swift` should show the call in the cameraTargetUpdated handler
- `grep -n "currentCenter" AirplaneTracker3D/DataLayer/FlightDataActor.swift` should show the property, updateCenter method, and polling loop read
  </verify>
  <done>
ContentView's `.cameraTargetUpdated` handler calls `flightDataManager.updateCenter(lat:lon:)` with the camera-derived coordinates. The `.switchDataSource` handler uses the current camera position instead of hardcoded Seattle. The full pipeline is connected: camera movement -> lat/lon conversion -> polling center update -> API queries follow camera. Project builds without errors.
  </done>
</task>

</tasks>

<verification>
After both tasks are complete, verify the full pipeline:

1. Build succeeds: `xcodebuild -scheme AirplaneTracker3D -destination 'platform=macOS' build`
2. Grep confirms `updateCenter` exists in both FlightDataActor.swift and ContentView.swift
3. Grep confirms `currentCenter` is read in the polling loop (not the old closure-captured `center`)
4. Grep confirms MapCoordinateSystem.swift is UNCHANGED (centerLat/centerLon still hardcoded at 47.6/-122.3)
5. No hardcoded Seattle coordinates remain in ContentView's switchDataSource handler
</verification>

<success_criteria>
1. FlightDataActor reads a mutable `currentCenter` each polling cycle instead of a closure-captured fixed center
2. ContentView feeds camera lat/lon to FlightDataManager.updateCenter on every `.cameraTargetUpdated` notification
3. Data source switching uses the current camera position, not hardcoded Seattle
4. MapCoordinateSystem.swift is untouched (projection center stays fixed)
5. Project builds without errors
</success_criteria>

<output>
After completion, create `.planning/phases/16-camera-following-api/16-01-SUMMARY.md`
</output>
