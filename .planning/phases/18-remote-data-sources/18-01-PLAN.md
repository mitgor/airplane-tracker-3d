---
phase: 18-remote-data-sources
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - AirplaneTracker3D/DataLayer/FlightDataActor.swift
  - AirplaneTracker3D/Views/SettingsView.swift
  - AirplaneTracker3D/ContentView.swift
  - AirplaneTracker3D/AirplaneTracker3DApp.swift
autonomous: true

must_haves:
  truths:
    - "User can enter a remote dump1090 IP address and port in Settings"
    - "User can choose between Global, Local, and Remote data sources in Settings"
    - "Switching data source takes effect immediately without restarting the app"
    - "Remote dump1090 polls aircraft.json from the configured IP:port and displays aircraft on the map"
  artifacts:
    - path: "AirplaneTracker3D/DataLayer/FlightDataActor.swift"
      provides: "DataMode.remote(host, port) case and fetchRemote method"
      contains: "case remote"
    - path: "AirplaneTracker3D/Views/SettingsView.swift"
      provides: "Remote picker option and IP/port input fields"
      contains: "remoteHost"
    - path: "AirplaneTracker3D/ContentView.swift"
      provides: "Remote source handling in switchDataSource notification"
      contains: ".remote"
    - path: "AirplaneTracker3D/AirplaneTracker3DApp.swift"
      provides: "Default values for remoteHost and remotePort"
      contains: "remoteHost"
  key_links:
    - from: "AirplaneTracker3D/Views/SettingsView.swift"
      to: "AirplaneTracker3D/ContentView.swift"
      via: "NotificationCenter .switchDataSource with source='remote'"
      pattern: "switchDataSource.*remote"
    - from: "AirplaneTracker3D/ContentView.swift"
      to: "AirplaneTracker3D/DataLayer/FlightDataActor.swift"
      via: "flightDataManager.switchMode(to: .remote(host:port:))"
      pattern: "\\.remote\\("
    - from: "AirplaneTracker3D/DataLayer/FlightDataActor.swift"
      to: "http://{host}:{port}/data/aircraft.json"
      via: "fetchRemote builds URL from host/port parameters"
      pattern: "data/aircraft\\.json"
---

<objective>
Add configurable remote dump1090 data source so users can connect to a network ADS-B receiver and seamlessly switch between Global, Local, and Remote modes.

Purpose: Enables users with a dump1090 receiver on another machine (e.g., Raspberry Pi) to view its aircraft data without running the receiver locally.
Output: Working remote data source with Settings UI for IP/port configuration and immediate source switching.
</objective>

<execution_context>
@/Users/mit/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mit/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@AirplaneTracker3D/DataLayer/FlightDataActor.swift
@AirplaneTracker3D/Views/SettingsView.swift
@AirplaneTracker3D/ContentView.swift
@AirplaneTracker3D/AirplaneTracker3DApp.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add remote DataMode and fetch method to FlightDataActor</name>
  <files>AirplaneTracker3D/DataLayer/FlightDataActor.swift</files>
  <action>
Modify FlightDataActor to support a configurable remote dump1090 receiver:

1. **Change `DataMode` enum** -- Add a `remote(host: String, port: Int)` case:
   ```swift
   enum DataMode: Sendable {
       case local
       case global
       case remote(host: String, port: Int)
   }
   ```

2. **Add `fetchRemote(host:port:)` method** -- Same as `fetchLocal()` but builds URL from parameters instead of using `localURL` constant:
   ```swift
   private func fetchRemote(host: String, port: Int) async -> [AircraftModel] {
       guard let url = URL(string: "http://\(host):\(port)/data/aircraft.json") else {
           return []
       }
       do {
           let (data, _) = try await URLSession.shared.data(from: url)
           let response = try JSONDecoder().decode(Dump1090Response.self, from: data)
           return DataNormalizer.normalizeDump1090(response)
       } catch {
           return []
       }
   }
   ```

3. **Update `fetchWithFallback(mode:center:)`** -- Add a case for `.remote` that calls `fetchRemote`:
   ```swift
   private func fetchWithFallback(mode: DataMode, center: (lat: Double, lon: Double)) async -> [AircraftModel] {
       switch mode {
       case .local:
           return await fetchLocal()
       case .remote(let host, let port):
           return await fetchRemote(host: host, port: port)
       case .global:
           // existing provider fallback logic (unchanged)
       }
   }
   ```
   The existing `if mode == .local` guard must become a switch statement to handle all three cases.

4. **Update `startPolling(mode:center:)`** -- The polling interval for `.remote` should be 1 second (same as local, since it's a dump1090 instance). Update the interval logic:
   ```swift
   let interval: Duration
   switch mode {
   case .local, .remote:
       interval = .seconds(1)
   case .global:
       interval = .seconds(5)
   }
   ```

5. **Update `updateBuffer(_:)`** -- The `bufferWindow` and `staleThreshold` selection currently uses `currentMode == .local`. Change to handle `.remote` with the same timing as `.local`:
   ```swift
   let isLocalOrRemote: Bool
   switch currentMode {
   case .local, .remote: isLocalOrRemote = true
   case .global: isLocalOrRemote = false
   }
   let bufferWindow = isLocalOrRemote ? localBufferWindow : globalBufferWindow
   let staleThreshold = isLocalOrRemote ? localStaleThreshold : globalStaleThreshold
   ```

No changes needed to `switchMode(to:)`, `getBufferSnapshot()`, `latestAircraft()`, or `FlightDataManager` -- those all work with DataMode generically already. FlightDataManager.switchMode already forwards the mode through.
  </action>
  <verify>
Build the project with Cmd+B (or `xcodebuild build` from CLI). The DataMode enum change will cause compile errors in ContentView.swift (the switch in .onAppear and .onReceive) -- that is expected and will be fixed in Task 2. Verify FlightDataActor.swift itself has no syntax errors by checking the build output for errors specifically in that file.
  </verify>
  <done>
FlightDataActor has a `.remote(host:port:)` DataMode case, a `fetchRemote` method that builds `http://{host}:{port}/data/aircraft.json` URLs, and the polling/buffer logic treats remote like local (1s interval, 5s buffer, 4s stale threshold).
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Remote option to Settings UI and wire through ContentView</name>
  <files>AirplaneTracker3D/Views/SettingsView.swift, AirplaneTracker3D/ContentView.swift, AirplaneTracker3D/AirplaneTracker3DApp.swift</files>
  <action>
Wire the remote data source through the UI layer:

**AirplaneTracker3DApp.swift** -- Register default values for remote host and port in the `UserDefaults.standard.register(defaults:)` call in `init()`:
```swift
"remoteHost": "192.168.1.100",
"remotePort": 8080,
```
Add these to the existing defaults dictionary alongside the showAirspace/showHeatmap entries.

**SettingsView.swift** -- Add Remote as a third data source option with IP/port configuration:

1. Add two new `@AppStorage` properties in the "Data Settings" section:
   ```swift
   @AppStorage("remoteHost") private var remoteHost: String = "192.168.1.100"
   @AppStorage("remotePort") private var remotePort: Int = 8080
   ```

2. Update the Data Source picker in `renderingTab` to include Remote:
   ```swift
   Picker("Data Source", selection: $dataSource) {
       Text("Global (airplanes.live)").tag("global")
       Text("Local (dump1090)").tag("local")
       Text("Remote (dump1090)").tag("remote")
   }
   ```

3. Add IP/port text fields that appear conditionally when "remote" is selected. Place them directly after the Picker, inside the same Form:
   ```swift
   if dataSource == "remote" {
       VStack(alignment: .leading, spacing: 4) {
           Text("Remote dump1090 Address")
               .font(.caption)
               .foregroundColor(.secondary)
           HStack {
               TextField("IP Address", text: $remoteHost)
                   .textFieldStyle(.roundedBorder)
                   .frame(width: 180)
               Text(":")
               TextField("Port", value: $remotePort, format: .number)
                   .textFieldStyle(.roundedBorder)
                   .frame(width: 70)
           }
       }
   }
   ```

4. The existing `.onChange(of: dataSource)` handler already posts the `.switchDataSource` notification -- that covers switching TO and FROM remote. However, we also need to re-trigger when the user changes the host or port while already in remote mode. Add two more `.onChange` handlers on the outer body (alongside the existing `.onChange(of: selectedTheme)` and `.onChange(of: dataSource)`):
   ```swift
   .onChange(of: remoteHost) { _, _ in
       if dataSource == "remote" {
           NotificationCenter.default.post(
               name: .switchDataSource,
               object: nil,
               userInfo: ["source": "remote"]
           )
       }
   }
   .onChange(of: remotePort) { _, _ in
       if dataSource == "remote" {
           NotificationCenter.default.post(
               name: .switchDataSource,
               object: nil,
               userInfo: ["source": "remote"]
           )
       }
   }
   ```

**ContentView.swift** -- Handle the "remote" source string and read stored IP/port:

1. Update the `.onAppear` block where it maps `savedSource` to `DataMode`. Replace the ternary with a proper mapping:
   ```swift
   let mode: FlightDataActor.DataMode
   switch savedSource {
   case "local":
       mode = .local
   case "remote":
       let host = UserDefaults.standard.string(forKey: "remoteHost") ?? "192.168.1.100"
       let port = UserDefaults.standard.integer(forKey: "remotePort")
       mode = .remote(host: host, port: port > 0 ? port : 8080)
   default:
       mode = .global
   }
   ```

2. Update the `.onReceive(NotificationCenter.default.publisher(for: .switchDataSource))` handler. Replace the existing ternary mapping with the same switch:
   ```swift
   .onReceive(NotificationCenter.default.publisher(for: .switchDataSource)) { notification in
       if let source = notification.userInfo?["source"] as? String {
           let center = (lat: centerLat, lon: centerLon)
           let mode: FlightDataActor.DataMode
           switch source {
           case "local":
               mode = .local
           case "remote":
               let host = UserDefaults.standard.string(forKey: "remoteHost") ?? "192.168.1.100"
               let port = UserDefaults.standard.integer(forKey: "remotePort")
               mode = .remote(host: host, port: port > 0 ? port : 8080)
           default:
               mode = .global
           }
           flightDataManager.switchMode(to: mode, center: center)
       }
   }
   ```
   The `port > 0 ? port : 8080` guard handles the case where UserDefaults returns 0 for an unset integer key.
  </action>
  <verify>
Build the project with `xcodebuild build -scheme AirplaneTracker3D -destination 'platform=macOS'` (or Cmd+B in Xcode). The build must succeed with zero errors. Then:
1. Run the app
2. Open Settings (Cmd+,)
3. Go to the Rendering tab
4. Verify the Data Source picker shows three options: Global, Local, Remote
5. Select "Remote" and verify the IP address and port fields appear
6. Change IP/port values and verify they persist after closing and reopening Settings
7. Switch between Global, Local, and Remote -- verify no crash and that the data source changes immediately (aircraft from new source appear)
  </verify>
  <done>
Settings shows Global/Local/Remote picker. Selecting Remote reveals IP:port fields stored in @AppStorage. Switching data source (including changing host/port while in Remote mode) immediately restarts polling with the new configuration. App launch respects the saved data source selection including remote with stored host/port.
  </done>
</task>

</tasks>

<verification>
1. Build succeeds with zero errors and zero warnings related to these changes
2. Settings > Rendering tab shows three data source options: Global (airplanes.live), Local (dump1090), Remote (dump1090)
3. Selecting Remote reveals IP address and port text fields
4. IP and port values persist across app restarts (stored in UserDefaults via @AppStorage)
5. Switching between any two data sources takes effect immediately -- new aircraft appear without restarting the app
6. If a remote dump1090 receiver is reachable at the configured IP:port, aircraft from it appear on the 3D map
7. If the remote receiver is unreachable, the app does not crash (silent failure, same as local mode behavior)
</verification>

<success_criteria>
- DataMode enum has three cases: .local, .global, .remote(host:port:)
- FlightDataActor fetches from http://{host}:{port}/data/aircraft.json for remote mode
- Remote mode uses 1-second polling interval (same as local)
- Settings picker has Global/Local/Remote options
- Remote IP/port fields appear only when Remote is selected
- Host and port persist in UserDefaults (keys: "remoteHost", "remotePort")
- Source switching is immediate (no app restart required)
- Changing host or port while in Remote mode re-triggers the data source switch
</success_criteria>

<output>
After completion, create `.planning/phases/18-remote-data-sources/18-01-SUMMARY.md`
</output>
