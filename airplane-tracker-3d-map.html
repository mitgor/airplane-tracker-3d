<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Airplane Tracker with Map</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            transition: background 0.3s ease;
        }
        body.theme-day {
            background: #87CEEB;
            color: #333;
        }
        body.theme-night {
            background: #0a0a1a;
            color: #fff;
        }
        body.theme-retro {
            background: #000800;
            color: #00ff00;
        }
        #container {
            width: 100vw;
            height: 100vh;
        }
        #info-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 20px;
            border-radius: 12px;
            min-width: 280px;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }
        .theme-day #info-panel {
            background: rgba(255, 255, 255, 0.85);
            border: 1px solid rgba(0, 100, 200, 0.3);
        }
        .theme-night #info-panel {
            background: rgba(0, 20, 40, 0.85);
            border: 1px solid rgba(0, 150, 255, 0.3);
        }
        .theme-retro #info-panel {
            background: rgba(0, 20, 0, 0.9);
            border: 1px solid #00ff00;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.3);
        }
        #info-panel h2 {
            margin-bottom: 15px;
            font-size: 1.4em;
        }
        .theme-day #info-panel h2 { color: #0066cc; }
        .theme-night #info-panel h2 { color: #00d4ff; }
        .theme-retro #info-panel h2 { color: #00ff00; text-shadow: 0 0 10px #00ff00; }

        .stat {
            margin: 8px 0;
            font-size: 0.95em;
        }
        .stat-label {
            opacity: 0.7;
        }
        .stat-value {
            font-weight: bold;
        }
        .theme-day .stat-value { color: #00aa44; }
        .theme-night .stat-value { color: #00ff88; }
        .theme-retro .stat-value { color: #00ff00; text-shadow: 0 0 5px #00ff00; }

        #selected-plane {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 20px;
            border-radius: 12px;
            min-width: 300px;
            display: none;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }
        .theme-day #selected-plane {
            background: rgba(255, 255, 255, 0.85);
            border: 1px solid rgba(255, 150, 0, 0.3);
        }
        .theme-night #selected-plane {
            background: rgba(0, 20, 40, 0.85);
            border: 1px solid rgba(255, 150, 0, 0.3);
        }
        .theme-retro #selected-plane {
            background: rgba(0, 20, 0, 0.9);
            border: 1px solid #00ff00;
        }
        #selected-plane h3 {
            margin-bottom: 15px;
        }
        .theme-day #selected-plane h3 { color: #cc6600; }
        .theme-night #selected-plane h3 { color: #ffaa00; }
        .theme-retro #selected-plane h3 { color: #00ff00; }

        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 15px 25px;
            border-radius: 30px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(10px);
            max-width: 95vw;
            transition: all 0.3s ease;
        }
        .theme-day #controls {
            background: rgba(255, 255, 255, 0.85);
        }
        .theme-night #controls {
            background: rgba(0, 20, 40, 0.85);
        }
        .theme-retro #controls {
            background: rgba(0, 20, 0, 0.9);
            border: 1px solid #00ff00;
        }

        button {
            border: none;
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.85em;
            transition: all 0.3s ease;
        }
        .theme-day button {
            background: linear-gradient(135deg, #0088ff, #0066cc);
            color: #fff;
        }
        .theme-night button {
            background: linear-gradient(135deg, #0066cc, #0044aa);
            color: #fff;
        }
        .theme-retro button {
            background: transparent;
            color: #00ff00;
            border: 1px solid #00ff00;
        }
        button:hover {
            transform: scale(1.05);
        }
        .theme-retro button:hover {
            background: rgba(0, 255, 0, 0.2);
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
        }
        button.active {
            background: #00aa00 !important;
        }
        .theme-retro button.active {
            background: rgba(0, 255, 0, 0.3) !important;
        }

        .control-group {
            display: flex;
            gap: 5px;
            align-items: center;
            padding: 0 10px;
            border-right: 1px solid rgba(128, 128, 128, 0.3);
        }
        .control-group:last-child {
            border-right: none;
        }
        .control-label {
            font-size: 0.75em;
            opacity: 0.7;
            margin-right: 5px;
        }

        #altitude-slider-container {
            position: absolute;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            padding: 15px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }
        .theme-day #altitude-slider-container {
            background: rgba(255, 255, 255, 0.85);
        }
        .theme-night #altitude-slider-container {
            background: rgba(0, 20, 40, 0.85);
        }
        .theme-retro #altitude-slider-container {
            background: rgba(0, 20, 0, 0.9);
            border: 1px solid #00ff00;
        }

        #altitude-slider-container h4 {
            font-size: 0.85em;
            margin-bottom: 10px;
            text-align: center;
        }

        #altitude-slider {
            writing-mode: bt-lr;
            -webkit-appearance: slider-vertical;
            width: 30px;
            height: 150px;
            cursor: pointer;
        }

        #altitude-value {
            text-align: center;
            margin-top: 10px;
            font-weight: bold;
            font-size: 0.9em;
        }

        /* Graphs Panel Styles */
        #graphs-panel {
            position: absolute;
            right: 80px;
            top: 20px;
            width: 320px;
            max-height: calc(100vh - 120px);
            overflow-y: auto;
            padding: 15px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            display: none;
        }
        #graphs-panel.visible {
            display: block;
        }
        .theme-day #graphs-panel {
            background: rgba(255, 255, 255, 0.92);
            border: 1px solid rgba(0, 100, 200, 0.3);
        }
        .theme-night #graphs-panel {
            background: rgba(0, 20, 40, 0.92);
            border: 1px solid rgba(0, 150, 255, 0.3);
        }
        .theme-retro #graphs-panel {
            background: rgba(0, 20, 0, 0.95);
            border: 1px solid #00ff00;
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.3);
        }

        #graphs-panel h3 {
            margin-bottom: 12px;
            font-size: 1.1em;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .theme-day #graphs-panel h3 { color: #0066cc; }
        .theme-night #graphs-panel h3 { color: #00d4ff; }
        .theme-retro #graphs-panel h3 { color: #00ff00; text-shadow: 0 0 10px #00ff00; }

        .time-period-selector {
            display: flex;
            gap: 4px;
            margin-bottom: 12px;
            flex-wrap: wrap;
        }
        .time-period-btn {
            flex: 1;
            min-width: 45px;
            padding: 6px 8px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8em;
            font-weight: 500;
            transition: all 0.2s ease;
        }
        .theme-day .time-period-btn {
            background: rgba(0, 100, 200, 0.15);
            color: #0066cc;
        }
        .theme-day .time-period-btn:hover {
            background: rgba(0, 100, 200, 0.25);
        }
        .theme-day .time-period-btn.active {
            background: #0088ff;
            color: #fff;
        }
        .theme-night .time-period-btn {
            background: rgba(0, 150, 255, 0.2);
            color: #00d4ff;
        }
        .theme-night .time-period-btn:hover {
            background: rgba(0, 150, 255, 0.35);
        }
        .theme-night .time-period-btn.active {
            background: #0088ff;
            color: #fff;
        }
        .theme-retro .time-period-btn {
            background: rgba(0, 255, 0, 0.1);
            color: #00ff00;
            border: 1px solid rgba(0, 255, 0, 0.3);
        }
        .theme-retro .time-period-btn:hover {
            background: rgba(0, 255, 0, 0.2);
            box-shadow: 0 0 5px rgba(0, 255, 0, 0.3);
        }
        .theme-retro .time-period-btn.active {
            background: rgba(0, 255, 0, 0.3);
            border-color: #00ff00;
            box-shadow: 0 0 8px rgba(0, 255, 0, 0.5);
        }

        .graphs1090-status {
            font-size: 0.7em;
            padding: 2px 8px;
            border-radius: 10px;
            font-weight: normal;
        }
        .graphs1090-status.connected {
            background: rgba(0, 200, 100, 0.3);
            color: #00cc66;
        }
        .graphs1090-status.local {
            background: rgba(255, 150, 0, 0.3);
            color: #ffaa00;
        }

        .graph-card {
            margin-bottom: 12px;
            padding: 10px;
            border-radius: 8px;
            transition: all 0.3s ease;
        }
        .theme-day .graph-card {
            background: rgba(0, 100, 200, 0.1);
        }
        .theme-night .graph-card {
            background: rgba(0, 100, 200, 0.2);
        }
        .theme-retro .graph-card {
            background: rgba(0, 255, 0, 0.1);
            border: 1px solid rgba(0, 255, 0, 0.3);
        }

        .graph-card h4 {
            font-size: 0.85em;
            margin-bottom: 8px;
            opacity: 0.9;
        }

        .graph-current-value {
            font-size: 1.5em;
            font-weight: bold;
            margin-bottom: 8px;
        }
        .theme-day .graph-current-value { color: #0088ff; }
        .theme-night .graph-current-value { color: #00d4ff; }
        .theme-retro .graph-current-value { color: #00ff00; text-shadow: 0 0 8px #00ff00; }

        .graph-canvas-container {
            width: 100%;
            height: 60px;
            border-radius: 4px;
            overflow: hidden;
        }
        .theme-day .graph-canvas-container {
            background: rgba(0, 0, 0, 0.05);
        }
        .theme-night .graph-canvas-container {
            background: rgba(0, 0, 0, 0.3);
        }
        .theme-retro .graph-canvas-container {
            background: rgba(0, 50, 0, 0.5);
        }

        .graph-canvas {
            width: 100%;
            height: 100%;
        }

        .graph-stats {
            display: flex;
            justify-content: space-between;
            font-size: 0.75em;
            margin-top: 6px;
            opacity: 0.7;
        }

        #graphs-panel::-webkit-scrollbar {
            width: 6px;
        }
        #graphs-panel::-webkit-scrollbar-track {
            background: transparent;
        }
        .theme-day #graphs-panel::-webkit-scrollbar-thumb {
            background: rgba(0, 100, 200, 0.3);
            border-radius: 3px;
        }
        .theme-night #graphs-panel::-webkit-scrollbar-thumb {
            background: rgba(0, 150, 255, 0.3);
            border-radius: 3px;
        }
        .theme-retro #graphs-panel::-webkit-scrollbar-thumb {
            background: rgba(0, 255, 0, 0.3);
            border-radius: 3px;
        }

        select {
            padding: 6px 10px;
            border-radius: 15px;
            cursor: pointer;
            font-size: 0.85em;
        }
        .theme-day select {
            background: #fff;
            border: 1px solid #ccc;
            color: #333;
        }
        .theme-night select {
            background: #1a3a5a;
            border: 1px solid #0066cc;
            color: #fff;
        }
        .theme-retro select {
            background: #001a00;
            border: 1px solid #00ff00;
            color: #00ff00;
        }
    </style>
</head>
<body class="theme-day">
    <div id="container"></div>

    <div id="info-panel">
        <h2>3D Flight Tracker</h2>
        <div class="stat">
            <span class="stat-label">Aircraft Tracked:</span>
            <span class="stat-value" id="plane-count">0</span>
        </div>
        <div class="stat">
            <span class="stat-label">Last Update:</span>
            <span class="stat-value" id="last-update">--:--:--</span>
        </div>
        <div class="stat">
            <span class="stat-label">Center:</span>
            <span class="stat-value" id="center-coords">--</span>
        </div>
        <div class="stat">
            <span class="stat-label">Map Zoom:</span>
            <span class="stat-value" id="map-zoom">9</span>
        </div>
    </div>

    <div id="selected-plane">
        <h3>Selected Aircraft</h3>
        <div class="stat">
            <span class="stat-label">Callsign:</span>
            <span class="stat-value" id="sel-callsign">--</span>
        </div>
        <div class="stat">
            <span class="stat-label">Altitude:</span>
            <span class="stat-value" id="sel-altitude">--</span>
        </div>
        <div class="stat">
            <span class="stat-label">Speed:</span>
            <span class="stat-value" id="sel-speed">--</span>
        </div>
        <div class="stat">
            <span class="stat-label">Track:</span>
            <span class="stat-value" id="sel-track">--</span>
        </div>
        <div class="stat">
            <span class="stat-label">Vert Rate:</span>
            <span class="stat-value" id="sel-vertrate">--</span>
        </div>
        <div class="stat">
            <span class="stat-label">Squawk:</span>
            <span class="stat-value" id="sel-squawk">--</span>
        </div>
        <div class="stat">
            <span class="stat-label">Position:</span>
            <span class="stat-value" id="sel-position">--</span>
        </div>
    </div>

    <div id="altitude-slider-container">
        <h4>Altitude Scale</h4>
        <input type="range" id="altitude-slider" min="1" max="200" value="30" orient="vertical">
        <div id="altitude-value">30x</div>
    </div>

    <div id="graphs-panel">
        <h3>ADS-B Statistics <span class="graphs1090-status local" id="graphs-status">Local DB</span></h3>

        <div class="time-period-selector">
            <button class="time-period-btn active" onclick="setGraphsTimePeriod(3600)" data-period="3600">1h</button>
            <button class="time-period-btn" onclick="setGraphsTimePeriod(7200)" data-period="7200">2h</button>
            <button class="time-period-btn" onclick="setGraphsTimePeriod(28800)" data-period="28800">8h</button>
            <button class="time-period-btn" onclick="setGraphsTimePeriod(86400)" data-period="86400">24h</button>
            <button class="time-period-btn" onclick="setGraphsTimePeriod(172800)" data-period="172800">48h</button>
        </div>

        <div class="graph-card" id="card-message-rate">
            <h4>Message Rate</h4>
            <div class="graph-current-value" id="msg-rate-value">-- msg/s</div>
            <div class="graph-canvas-container">
                <canvas class="graph-canvas" id="canvas-msg-rate"></canvas>
            </div>
            <div class="graph-stats">
                <span id="msg-rate-min">Min: --</span>
                <span id="msg-rate-max">Max: --</span>
            </div>
        </div>

        <div class="graph-card" id="card-aircraft">
            <h4>Aircraft Tracked</h4>
            <div class="graph-current-value" id="aircraft-value">--</div>
            <div class="graph-canvas-container">
                <canvas class="graph-canvas" id="canvas-aircraft"></canvas>
            </div>
            <div class="graph-stats">
                <span id="aircraft-min">Min: --</span>
                <span id="aircraft-max">Max: --</span>
            </div>
        </div>

        <div class="graph-card" id="card-signal">
            <h4>Signal Level</h4>
            <div class="graph-current-value" id="signal-value">-- dBFS</div>
            <div class="graph-canvas-container">
                <canvas class="graph-canvas" id="canvas-signal"></canvas>
            </div>
            <div class="graph-stats">
                <span id="signal-min">Min: --</span>
                <span id="signal-max">Max: --</span>
            </div>
        </div>
    </div>

    <div id="controls">
        <div class="control-group">
            <span class="control-label">Theme:</span>
            <select id="theme-select" onchange="changeTheme(this.value)">
                <option value="day">Day</option>
                <option value="night">Night</option>
                <option value="retro">Retro 80s</option>
            </select>
        </div>

        <div class="control-group">
            <span class="control-label">Units:</span>
            <select id="units-select" onchange="changeUnits(this.value)">
                <option value="imperial">Imperial (ft/kts)</option>
                <option value="metric">Metric (m/km/h)</option>
            </select>
        </div>

        <div class="control-group">
            <span class="control-label">Map:</span>
            <button onclick="mapZoomIn()">+</button>
            <button onclick="mapZoomOut()">-</button>
            <button onclick="panMap('up')">↑</button>
            <button onclick="panMap('down')">↓</button>
            <button onclick="panMap('left')">←</button>
            <button onclick="panMap('right')">→</button>
        </div>

        <div class="control-group">
            <span class="control-label">Camera:</span>
            <button onclick="cameraZoomIn()">Zoom+</button>
            <button onclick="cameraZoomOut()">Zoom-</button>
            <button onmousedown="startRotate('left')" onmouseup="stopRotate()" onmouseleave="stopRotate()">◄</button>
            <button onmousedown="startRotate('right')" onmouseup="stopRotate()" onmouseleave="stopRotate()">►</button>
        </div>

        <div class="control-group">
            <button onclick="resetCamera()">Reset</button>
            <button onclick="toggleAutoRotate()" id="btn-rotate">Auto Rotate</button>
            <span class="control-label">Trails:</span>
            <select id="trail-select" onchange="setTrailDuration(this.value)">
                <option value="0">Off</option>
                <option value="60">60 sec</option>
                <option value="120" selected>120 sec</option>
                <option value="240">240 sec</option>
            </select>
            <button onclick="toggleLabels()" id="btn-labels">Labels</button>
            <button onclick="toggleGraphs()" id="btn-graphs">Graphs</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Configuration
        const DATA_URL = '/dump1090/data/aircraft.json';
        const REFRESH_INTERVAL = 1000;
        const MAP_GROUND_SIZE = 400;
        const TILES_PER_SIDE = 6;
        const BASE_ALT_SCALE = 0.00001;

        // Cookie helper functions
        function setCookie(name, value, days = 365) {
            const expires = new Date(Date.now() + days * 864e5).toUTCString();
            document.cookie = name + '=' + encodeURIComponent(JSON.stringify(value)) + '; expires=' + expires + '; path=/; SameSite=Lax';
        }

        function getCookie(name) {
            const value = document.cookie.split('; ').find(row => row.startsWith(name + '='));
            if (value) {
                try {
                    return JSON.parse(decodeURIComponent(value.split('=')[1]));
                } catch (e) {
                    return null;
                }
            }
            return null;
        }

        function saveSettings() {
            const settings = {
                theme: currentTheme,
                units: currentUnits,
                showLabels: showLabels,
                trailDuration: trailDuration,
                autoRotate: autoRotate,
                showGraphs: showGraphs,
                graphsTimePeriod: graphsTimePeriod,
                altitudeScaleValue: Math.round(altitudeScale / BASE_ALT_SCALE)
            };
            setCookie('flightTrackerSettings', settings);
        }

        function loadSettings() {
            const settings = getCookie('flightTrackerSettings');
            if (settings) {
                if (settings.theme) currentTheme = settings.theme;
                if (settings.units) currentUnits = settings.units;
                if (settings.showLabels !== undefined) showLabels = settings.showLabels;
                if (settings.trailDuration !== undefined) {
                    trailDuration = settings.trailDuration;
                    showTrails = trailDuration > 0;
                } else if (settings.showTrails !== undefined) {
                    // Backward compatibility with old settings
                    showTrails = settings.showTrails;
                    trailDuration = showTrails ? 120 : 0;
                }
                if (settings.autoRotate !== undefined) autoRotate = settings.autoRotate;
                if (settings.showGraphs !== undefined) showGraphs = settings.showGraphs;
                if (settings.graphsTimePeriod !== undefined) graphsTimePeriod = settings.graphsTimePeriod;
                if (settings.altitudeScaleValue !== undefined) {
                    altitudeScale = settings.altitudeScaleValue * BASE_ALT_SCALE;
                }
            }
        }

        // State
        let scene, camera, renderer;
        let airplanes = new Map();
        let labels = [];
        let showLabels = true;
        let trailDuration = 120; // Trail duration in seconds (0 = off)
        let showTrails = true; // Derived from trailDuration > 0
        let autoRotate = false;
        let selectedPlane = null;
        let centerLat = 0, centerLon = 0;
        let centerInitialized = false;

        // Interpolation state
        const INTERPOLATION_DELAY = 2000; // 2 second delay
        const INTERPOLATION_FPS = 30;
        let aircraftDataBuffer = new Map(); // hex -> array of {timestamp, data}
        let lastInterpolationTime = 0;

        // Performance: Cached/reusable objects to avoid GC pressure
        const _raycaster = new THREE.Raycaster();
        const _mouseVec = new THREE.Vector2();
        const _tempPos = { x: 0, z: 0 };
        const _seenHexes = new Set();
        let _airplanesArray = []; // Cached array of airplane entries for iteration
        let _airplanesArrayDirty = true; // Flag to rebuild array when airplanes change

        // Performance: Label canvas pool for reuse
        const _labelCanvasPool = [];
        const _labelTexturePool = [];
        const MAX_LABEL_POOL_SIZE = 100;

        // Performance: Throttle flags
        let _lastTrailFilterTime = 0;
        const TRAIL_FILTER_INTERVAL = 500; // Filter trails every 500ms max

        // Performance: Tab visibility for power saving
        let _isTabVisible = true;

        // Map state
        let currentZoom = 9;
        const MIN_ZOOM = 6;
        const MAX_ZOOM = 12;
        let mapTiles = [];
        let tileCache = new Map();

        // Altitude scale
        let altitudeScale = 30 * BASE_ALT_SCALE;

        // Units: 'imperial' or 'metric'
        let currentUnits = 'imperial';

        // Theme: 'day', 'night', 'retro'
        let currentTheme = 'day';

        // Graphs panel state
        let showGraphs = false;
        let graphs1090Available = false;
        let statsDb = null;
        let graphsTimePeriod = 3600; // Default 1 hour in seconds
        let statsHistory = {
            messageRate: [],
            aircraftCount: [],
            signalLevel: []
        };
        const STATS_HISTORY_MAX = 172800; // 48 hours at 1s intervals
        const STATS_URL = '/dump1090/data/stats.json';
        const GRAPHS1090_CHECK_URL = '/graphs1090/';

        // Camera controls
        let cameraAngle = 0;
        let cameraHeight = 80;
        let cameraDistance = 150;
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };

        // ===========================================
        // GRAPHS1090 INTEGRATION & LOCAL STATS
        // ===========================================

        // Initialize IndexedDB for stats storage
        function initStatsDatabase() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open('FlightTrackerStats', 2);

                request.onerror = () => {
                    console.warn('IndexedDB not available, using memory only');
                    resolve(null);
                };

                request.onupgradeneeded = (event) => {
                    const db = event.target.result;

                    // Create object stores for each metric
                    if (!db.objectStoreNames.contains('messageRate')) {
                        const msgStore = db.createObjectStore('messageRate', { keyPath: 'timestamp' });
                        msgStore.createIndex('timestamp', 'timestamp', { unique: true });
                    }
                    if (!db.objectStoreNames.contains('aircraft')) {
                        const acStore = db.createObjectStore('aircraft', { keyPath: 'timestamp' });
                        acStore.createIndex('timestamp', 'timestamp', { unique: true });
                    }
                    if (!db.objectStoreNames.contains('signal')) {
                        const sigStore = db.createObjectStore('signal', { keyPath: 'timestamp' });
                        sigStore.createIndex('timestamp', 'timestamp', { unique: true });
                    }
                    // Trail history store - keyed by aircraft hex
                    if (!db.objectStoreNames.contains('trails')) {
                        const trailStore = db.createObjectStore('trails', { keyPath: 'hex' });
                        trailStore.createIndex('lastSeen', 'lastSeen', { unique: false });
                    }
                };

                request.onsuccess = (event) => {
                    statsDb = event.target.result;
                    loadStatsFromDb();
                    resolve(statsDb);
                };
            });
        }

        // Load historical stats from IndexedDB
        function loadStatsFromDb() {
            if (!statsDb) return;

            const now = Date.now();
            const cutoff = now - (STATS_HISTORY_MAX * 1000);

            ['messageRate', 'aircraft', 'signal'].forEach(storeName => {
                const transaction = statsDb.transaction([storeName], 'readonly');
                const store = transaction.objectStore(storeName);
                const request = store.openCursor();

                request.onsuccess = (event) => {
                    const cursor = event.target.result;
                    if (cursor) {
                        if (cursor.value.timestamp >= cutoff) {
                            if (storeName === 'messageRate') {
                                statsHistory.messageRate.push(cursor.value);
                            } else if (storeName === 'aircraft') {
                                statsHistory.aircraftCount.push({ timestamp: cursor.value.timestamp, value: cursor.value.count || cursor.value.tracked || 0 });
                            } else if (storeName === 'signal') {
                                statsHistory.signalLevel.push(cursor.value);
                            }
                        }
                        cursor.continue();
                    }
                };
            });
        }

        // Save stats to IndexedDB
        function saveStatsToDb(type, data) {
            if (!statsDb) return;

            const transaction = statsDb.transaction([type], 'readwrite');
            const store = transaction.objectStore(type);
            store.put(data);

            // Clean up old entries (keep last 24 hours)
            const cutoff = Date.now() - (24 * 60 * 60 * 1000);
            const deleteRequest = store.openCursor();
            deleteRequest.onsuccess = (event) => {
                const cursor = event.target.result;
                if (cursor) {
                    if (cursor.value.timestamp < cutoff) {
                        cursor.delete();
                    }
                    cursor.continue();
                }
            };
        }

        // Save trail history to IndexedDB
        function saveTrailToDb(hex, trailPoints, lat, lon) {
            if (!statsDb || !hex || trailPoints.length < 2) return;

            try {
                const transaction = statsDb.transaction(['trails'], 'readwrite');
                const store = transaction.objectStore('trails');
                store.put({
                    hex: hex,
                    points: trailPoints.slice(-100), // Keep last 100 points
                    lastSeen: Date.now(),
                    lastLat: lat,
                    lastLon: lon
                });
            } catch (e) {
                // Ignore DB errors
            }
        }

        // Load trail history from IndexedDB
        function loadTrailFromDb(hex, callback) {
            if (!statsDb || !hex) {
                callback(null);
                return;
            }

            try {
                const transaction = statsDb.transaction(['trails'], 'readonly');
                const store = transaction.objectStore('trails');
                const request = store.get(hex);

                request.onsuccess = (event) => {
                    const result = event.target.result;
                    // Only use trail if seen within last hour
                    if (result && (Date.now() - result.lastSeen) < 3600000) {
                        callback(result);
                    } else {
                        callback(null);
                    }
                };

                request.onerror = () => callback(null);
            } catch (e) {
                callback(null);
            }
        }

        // Clean up old trails from IndexedDB
        function cleanupOldTrails() {
            if (!statsDb) return;

            try {
                const cutoff = Date.now() - (24 * 60 * 60 * 1000); // 24 hours
                const transaction = statsDb.transaction(['trails'], 'readwrite');
                const store = transaction.objectStore('trails');
                const index = store.index('lastSeen');
                const range = IDBKeyRange.upperBound(cutoff);

                index.openCursor(range).onsuccess = (event) => {
                    const cursor = event.target.result;
                    if (cursor) {
                        cursor.delete();
                        cursor.continue();
                    }
                };
            } catch (e) {
                // Ignore errors
            }
        }

        // Check if graphs1090 is available
        async function checkGraphs1090() {
            try {
                const response = await fetch(GRAPHS1090_CHECK_URL, { method: 'HEAD', cache: 'no-store' });
                if (response.ok) {
                    graphs1090Available = true;
                    document.getElementById('graphs-status').textContent = 'graphs1090';
                    document.getElementById('graphs-status').classList.remove('local');
                    document.getElementById('graphs-status').classList.add('connected');
                    console.log('graphs1090 detected, using its database');
                    return true;
                }
            } catch (e) {
                // graphs1090 not available
            }

            graphs1090Available = false;
            document.getElementById('graphs-status').textContent = 'Local DB';
            document.getElementById('graphs-status').classList.remove('connected');
            document.getElementById('graphs-status').classList.add('local');
            console.log('graphs1090 not detected, using local database');
            return false;
        }

        // Fetch stats from dump1090 stats.json
        async function fetchStats() {
            const now = Date.now();

            // Always get current aircraft count from the UI
            const planeCountEl = document.getElementById('plane-count');
            const aircraftCount = planeCountEl ? (parseInt(planeCountEl.textContent) || 0) : 0;

            try {
                const response = await fetch(STATS_URL, { cache: 'no-store' });
                const data = await response.json();

                // Extract message rate from last1min
                let messageRate = 0;
                if (data.last1min && data.last1min.local) {
                    const local = data.last1min.local;
                    const accepted = local.accepted || [0, 0];
                    const totalAccepted = accepted.reduce((a, b) => a + b, 0);
                    // Calculate rate per second (last1min data spans ~60 seconds)
                    const duration = (data.last1min.end || now/1000) - (data.last1min.start || (now/1000 - 60));
                    messageRate = duration > 0 ? totalAccepted / duration : 0;
                }

                // Extract signal level
                let signalLevel = -50; // Default
                if (data.last1min && data.last1min.local) {
                    signalLevel = data.last1min.local.signal || -50;
                }

                // Store in history
                statsHistory.messageRate.push({ timestamp: now, value: messageRate });
                statsHistory.aircraftCount.push({ timestamp: now, value: aircraftCount });
                statsHistory.signalLevel.push({ timestamp: now, value: signalLevel });

                // Trim history
                if (statsHistory.messageRate.length > STATS_HISTORY_MAX) {
                    statsHistory.messageRate.shift();
                }
                if (statsHistory.aircraftCount.length > STATS_HISTORY_MAX) {
                    statsHistory.aircraftCount.shift();
                }
                if (statsHistory.signalLevel.length > STATS_HISTORY_MAX) {
                    statsHistory.signalLevel.shift();
                }

                // Save to IndexedDB
                saveStatsToDb('messageRate', { timestamp: now, value: messageRate });
                saveStatsToDb('aircraft', { timestamp: now, count: aircraftCount });
                saveStatsToDb('signal', { timestamp: now, value: signalLevel });

                // Update display
                updateGraphsDisplay();

            } catch (error) {
                // stats.json not available - still track aircraft count
                statsHistory.aircraftCount.push({ timestamp: now, value: aircraftCount });
                if (statsHistory.aircraftCount.length > STATS_HISTORY_MAX) {
                    statsHistory.aircraftCount.shift();
                }

                saveStatsToDb('aircraft', { timestamp: now, count: aircraftCount });
                updateGraphsDisplay();
            }
        }

        // Filter history data based on selected time period
        function filterHistoryByPeriod(historyArray) {
            const now = Date.now();
            const cutoff = now - (graphsTimePeriod * 1000);
            return historyArray.filter(d => d.timestamp >= cutoff);
        }

        // Update the graphs display
        function updateGraphsDisplay() {
            if (!showGraphs) return;

            const isRetro = currentTheme === 'retro';
            const lineColor = isRetro ? '#00ff00' : (currentTheme === 'night' ? '#00d4ff' : '#0088ff');
            const fillColor = isRetro ? 'rgba(0, 255, 0, 0.2)' : (currentTheme === 'night' ? 'rgba(0, 212, 255, 0.2)' : 'rgba(0, 136, 255, 0.2)');
            const secondLineColor = isRetro ? '#00cc00' : (currentTheme === 'night' ? '#ffaa00' : '#ff8800');

            // Filter data by selected time period
            const filteredMsgRate = filterHistoryByPeriod(statsHistory.messageRate);
            const filteredAircraftCount = filterHistoryByPeriod(statsHistory.aircraftCount);
            const filteredSignal = filterHistoryByPeriod(statsHistory.signalLevel);

            // Message Rate Graph
            if (filteredMsgRate.length > 0) {
                const latest = statsHistory.messageRate.length > 0 ?
                    statsHistory.messageRate[statsHistory.messageRate.length - 1].value : 0;
                document.getElementById('msg-rate-value').textContent = latest.toFixed(1) + ' msg/s';

                const values = filteredMsgRate.map(d => d.value);
                const min = Math.min(...values);
                const max = Math.max(...values);
                document.getElementById('msg-rate-min').textContent = 'Min: ' + min.toFixed(1);
                document.getElementById('msg-rate-max').textContent = 'Max: ' + max.toFixed(1);

                drawMiniGraph('canvas-msg-rate', values, lineColor, fillColor);
            }

            // Aircraft Count Graph
            if (filteredAircraftCount.length > 0) {
                const latest = statsHistory.aircraftCount.length > 0 ?
                    statsHistory.aircraftCount[statsHistory.aircraftCount.length - 1].value : 0;
                document.getElementById('aircraft-value').textContent = latest;

                const values = filteredAircraftCount.map(d => d.value);
                const min = Math.min(...values);
                const max = Math.max(...values);
                document.getElementById('aircraft-min').textContent = 'Min: ' + min;
                document.getElementById('aircraft-max').textContent = 'Max: ' + max;

                drawMiniGraph('canvas-aircraft', values, lineColor, fillColor);
            }

            // Signal Level Graph
            if (filteredSignal.length > 0) {
                const latest = statsHistory.signalLevel.length > 0 ?
                    statsHistory.signalLevel[statsHistory.signalLevel.length - 1].value : -50;
                document.getElementById('signal-value').textContent = latest.toFixed(1) + ' dBFS';

                const values = filteredSignal.map(d => d.value);
                const min = Math.min(...values);
                const max = Math.max(...values);
                document.getElementById('signal-min').textContent = 'Min: ' + min.toFixed(1) + ' dB';
                document.getElementById('signal-max').textContent = 'Max: ' + max.toFixed(1) + ' dB';

                // Signal is negative, so invert for better visualization
                const normalizedValues = values.map(v => -v);
                drawMiniGraph('canvas-signal', normalizedValues, lineColor, fillColor);
            }
        }

        // Draw a mini graph on canvas
        function drawMiniGraph(canvasId, values, lineColor, fillColor, values2 = null, lineColor2 = null) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            const rect = canvas.getBoundingClientRect();

            // Set actual canvas size for crisp rendering
            const dpr = window.devicePixelRatio || 1;
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);

            const width = rect.width;
            const height = rect.height;
            const padding = 2;

            ctx.clearRect(0, 0, width, height);

            if (values.length < 2) return;

            // Calculate combined min/max if two datasets
            let allValues = values;
            if (values2 && values2.length > 0) {
                allValues = [...values, ...values2];
            }

            const minVal = Math.min(...allValues);
            const maxVal = Math.max(...allValues);
            const range = maxVal - minVal || 1;

            // Draw helper function
            const drawLine = (data, color, fill) => {
                const stepX = (width - padding * 2) / (data.length - 1);

                ctx.beginPath();
                ctx.moveTo(padding, height - padding);

                for (let i = 0; i < data.length; i++) {
                    const x = padding + i * stepX;
                    const normalizedY = (data[i] - minVal) / range;
                    const y = height - padding - normalizedY * (height - padding * 2);

                    if (i === 0) {
                        ctx.lineTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }

                // Complete the fill path
                ctx.lineTo(width - padding, height - padding);
                ctx.closePath();

                ctx.fillStyle = fill;
                ctx.fill();

                // Draw the line on top
                ctx.beginPath();
                for (let i = 0; i < data.length; i++) {
                    const x = padding + i * stepX;
                    const normalizedY = (data[i] - minVal) / range;
                    const y = height - padding - normalizedY * (height - padding * 2);

                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }

                ctx.strokeStyle = color;
                ctx.lineWidth = 1.5;
                ctx.stroke();
            };

            // Draw primary data
            drawLine(values, lineColor, fillColor);

            // Draw secondary data if provided
            if (values2 && values2.length > 0 && lineColor2) {
                drawLine(values2, lineColor2, 'transparent');
            }
        }

        // Initialize graphs system
        async function initGraphsSystem() {
            await initStatsDatabase();
            await checkGraphs1090();

            // Clean up old trails
            cleanupOldTrails();

            // Start fetching stats
            fetchStats();
            setInterval(fetchStats, 1000);

            // Re-check graphs1090 periodically (every 5 minutes)
            setInterval(checkGraphs1090, 300000);

            // Clean up old trails periodically (every hour)
            setInterval(cleanupOldTrails, 3600000);
        }

        // Expose functions globally for onclick handlers
        window.setGraphsTimePeriod = function(seconds) {
            graphsTimePeriod = seconds;

            // Update button states
            document.querySelectorAll('.time-period-btn').forEach(btn => {
                btn.classList.toggle('active', parseInt(btn.dataset.period) === seconds);
            });

            // Refresh display
            updateGraphsDisplay();
            saveSettings();
        };

        window.toggleGraphs = function() {
            showGraphs = !showGraphs;
            const panel = document.getElementById('graphs-panel');
            const btn = document.getElementById('btn-graphs');

            if (showGraphs) {
                panel.classList.add('visible');
                btn.classList.add('active');
                updateGraphsDisplay();
            } else {
                panel.classList.remove('visible');
                btn.classList.remove('active');
            }

            saveSettings();
        };

        window.setTrailDuration = function(seconds) {
            trailDuration = parseInt(seconds) || 0;
            showTrails = trailDuration > 0;

            // Update select element
            document.getElementById('trail-select').value = trailDuration;

            // Update all existing plane trails visibility
            if (_airplanesArrayDirty) {
                _airplanesArray = Array.from(airplanes.values());
                _airplanesArrayDirty = false;
            }
            for (let i = 0, len = _airplanesArray.length; i < len; i++) {
                const plane = _airplanesArray[i];
                if (plane.userData.trail) {
                    plane.userData.trail.visible = showTrails;
                }
                if (!showTrails) {
                    plane.userData.trailPoints.length = 0;
                    if (plane.userData.trail) {
                        plane.userData.trail.geometry.setDrawRange(0, 0);
                    }
                }
            }

            saveSettings();
        };

        function init() {
            // Load saved settings from cookies
            loadSettings();

            // Apply loaded settings to UI
            document.body.className = 'theme-' + currentTheme;
            document.getElementById('theme-select').value = currentTheme;
            document.getElementById('units-select').value = currentUnits;

            // Apply altitude scale to slider
            const scaleValue = Math.round(altitudeScale / BASE_ALT_SCALE);
            document.getElementById('altitude-slider').value = scaleValue;
            document.getElementById('altitude-value').textContent = scaleValue + 'x';

            // Scene
            scene = new THREE.Scene();
            updateSceneBackground();

            // Camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
            updateCameraPosition();

            // Renderer - cap pixel ratio at 2 to reduce GPU load on high-DPI displays
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('container').appendChild(renderer.domElement);

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 100, 50);
            scene.add(directionalLight);

            // Ground placeholder
            createGroundPlaceholder();

            // Controls
            setupControls();

            // Window resize
            window.addEventListener('resize', onWindowResize);

            // Visibility change - pause rendering when tab is hidden
            document.addEventListener('visibilitychange', () => {
                _isTabVisible = !document.hidden;
            });

            // Mouse interaction
            renderer.domElement.addEventListener('click', onMouseClick);

            // Altitude slider
            const slider = document.getElementById('altitude-slider');
            slider.addEventListener('input', (e) => {
                const value = parseInt(e.target.value);
                altitudeScale = value * BASE_ALT_SCALE;
                document.getElementById('altitude-value').textContent = value + 'x';
                updateAllAircraftPositions();
                saveSettings();
            });

            // Start animation
            animate();

            // Fetch data
            fetchData();
            setInterval(fetchData, REFRESH_INTERVAL);

            // Initialize graphs system
            initGraphsSystem();

            // Apply graphs panel state from settings
            if (showGraphs) {
                document.getElementById('graphs-panel').classList.add('visible');
            }

            // Apply time period button state
            document.querySelectorAll('.time-period-btn').forEach(btn => {
                btn.classList.toggle('active', parseInt(btn.dataset.period) === graphsTimePeriod);
            });

            // Apply trail duration select state
            document.getElementById('trail-select').value = trailDuration;
        }

        function updateSceneBackground() {
            if (currentTheme === 'day') {
                scene.background = new THREE.Color(0x87CEEB);
                scene.fog = new THREE.Fog(0x87CEEB, 300, 800);
            } else if (currentTheme === 'night') {
                scene.background = new THREE.Color(0x0a0a1a);
                scene.fog = new THREE.Fog(0x0a0a1a, 300, 800);
            } else if (currentTheme === 'retro') {
                scene.background = new THREE.Color(0x000800);
                scene.fog = new THREE.Fog(0x000800, 300, 800);
            }
        }

        function changeTheme(theme) {
            currentTheme = theme;
            document.body.className = 'theme-' + theme;
            updateSceneBackground();

            // Clear tile cache for theme change to force reload with new style
            tileCache.clear();

            // Reload map tiles with appropriate style
            loadMapTiles();

            // Recreate all airplanes with new style (wireframe vs solid)
            recreateAllAirplanes();

            saveSettings();
        }

        function recreateAllAirplanes() {
            // Store current aircraft data
            const aircraftData = [];
            for (const [hex, plane] of airplanes.entries()) {
                aircraftData.push({...plane.userData});
                // Remove old plane and its trails/lines
                scene.remove(plane);
                if (plane.userData.trail) scene.remove(plane.userData.trail);
                if (plane.userData.altLine) scene.remove(plane.userData.altLine);
            }
            airplanes.clear();
            _airplanesArrayDirty = true;

            // Recreate with new theme style
            for (let i = 0; i < aircraftData.length; i++) {
                const data = aircraftData[i];
                if (!data.lat || !data.lon) continue;
                const plane = createAirplane(data);
                const pos = latLonToXZ(data.lat, data.lon);
                const alt = (data.altitude || 0) * altitudeScale;
                plane.position.set(pos.x, alt, pos.z);

                if (data.track !== undefined) {
                    plane.rotation.y = (-data.track * Math.PI / 180) + Math.PI;
                }

                updateAltitudeLine(plane);
                scene.add(plane);
                airplanes.set(data.hex, plane);
            }
            _airplanesArrayDirty = true;

            updateLabels();
        }

        function changeUnits(units) {
            currentUnits = units;
            updateLabels();
            if (selectedPlane) {
                selectPlane(selectedPlane);
            }
            saveSettings();
        }

        function formatAltitude(altFeet) {
            if (currentUnits === 'imperial') {
                return Math.round(altFeet).toLocaleString() + ' ft';
            } else {
                const meters = Math.round(altFeet * 0.3048);
                return meters.toLocaleString() + ' m';
            }
        }

        function formatSpeed(speedKnots) {
            if (currentUnits === 'imperial') {
                return Math.round(speedKnots) + ' kts';
            } else {
                const kmh = Math.round(speedKnots * 1.852);
                return kmh + ' km/h';
            }
        }

        function formatVertRate(rateFpm) {
            if (currentUnits === 'imperial') {
                return Math.round(rateFpm) + ' ft/min';
            } else {
                const mpm = Math.round(rateFpm * 0.3048);
                return mpm + ' m/min';
            }
        }

        function createGroundPlaceholder() {
            const geometry = new THREE.PlaneGeometry(MAP_GROUND_SIZE, MAP_GROUND_SIZE);
            const material = new THREE.MeshBasicMaterial({
                color: currentTheme === 'retro' ? 0x001100 : 0x1a4d1a,
                side: THREE.DoubleSide
            });
            const ground = new THREE.Mesh(geometry, material);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -0.1;
            ground.name = 'groundPlaceholder';
            scene.add(ground);
        }

        function getTileUrl(x, y, zoom) {
            if (currentTheme === 'retro') {
                // Use Stamen Toner Lite for retro theme - will be inverted to green
                return `https://tiles.stadiamaps.com/tiles/stamen_toner_lite/${zoom}/${x}/${y}.png`;
            } else if (currentTheme === 'night') {
                // Use CartoDB dark tiles for night theme
                return `https://a.basemaps.cartocdn.com/dark_all/${zoom}/${x}/${y}.png`;
            } else {
                // Standard OSM for day theme
                const servers = ['a', 'b', 'c'];
                const server = servers[Math.abs(x + y) % 3];
                return `https://${server}.tile.openstreetmap.org/${zoom}/${x}/${y}.png`;
            }
        }

        // Invert and colorize image for retro theme
        function invertToGreen(image) {
            const canvas = document.createElement('canvas');
            canvas.width = image.width;
            canvas.height = image.height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(image, 0, 0);

            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            for (let i = 0; i < data.length; i += 4) {
                // Get grayscale value (inverted)
                const gray = 255 - (data[i] * 0.299 + data[i+1] * 0.587 + data[i+2] * 0.114);
                // Convert to green
                data[i] = 0;           // R
                data[i+1] = gray;      // G
                data[i+2] = 0;         // B
                // Keep alpha
            }

            ctx.putImageData(imageData, 0, 0);
            return canvas;
        }

        function latLonToTile(lat, lon, zoom) {
            const n = Math.pow(2, zoom);
            const x = Math.floor((lon + 180) / 360 * n);
            const latRad = lat * Math.PI / 180;
            const y = Math.floor((1 - Math.log(Math.tan(latRad) + 1 / Math.cos(latRad)) / Math.PI) / 2 * n);
            return { x, y };
        }

        function tileToLatLon(x, y, zoom) {
            const n = Math.pow(2, zoom);
            const lon = x / n * 360 - 180;
            const latRad = Math.atan(Math.sinh(Math.PI * (1 - 2 * y / n)));
            const lat = latRad * 180 / Math.PI;
            return { lat, lon };
        }

        function loadMapTiles() {
            if (!centerInitialized) return;

            // Clear existing tiles
            mapTiles.forEach(tile => scene.remove(tile));
            mapTiles = [];

            const centerTile = latLonToTile(centerLat, centerLon, currentZoom);
            const halfTiles = Math.floor(TILES_PER_SIDE / 2);

            // Calculate bounds - tiles go from (centerTile - halfTiles) to (centerTile - halfTiles + TILES_PER_SIDE - 1)
            // So bounds are from tile (centerTile - halfTiles) top-left corner
            // to tile (centerTile - halfTiles + TILES_PER_SIDE) top-left corner (which is bottom-right of last tile)
            const startTileX = centerTile.x - halfTiles;
            const startTileY = centerTile.y - halfTiles;
            const topLeft = tileToLatLon(startTileX, startTileY, currentZoom);
            const bottomRight = tileToLatLon(startTileX + TILES_PER_SIDE, startTileY + TILES_PER_SIDE, currentZoom);

            window.mapBounds = {
                north: topLeft.lat,
                south: bottomRight.lat,
                east: bottomRight.lon,
                west: topLeft.lon
            };

            const tileSize = MAP_GROUND_SIZE / TILES_PER_SIDE;
            const loader = new THREE.TextureLoader();
            loader.crossOrigin = 'anonymous';

            for (let dy = 0; dy < TILES_PER_SIDE; dy++) {
                for (let dx = 0; dx < TILES_PER_SIDE; dx++) {
                    const tileX = centerTile.x - halfTiles + dx;
                    const tileY = centerTile.y - halfTiles + dy;
                    const cacheKey = `${currentTheme}-${currentZoom}-${tileX}-${tileY}`;

                    const geometry = new THREE.PlaneGeometry(tileSize, tileSize);
                    const material = new THREE.MeshBasicMaterial({
                        color: currentTheme === 'retro' ? 0x001100 : 0x1a4d1a,
                        side: THREE.DoubleSide
                    });

                    const tile = new THREE.Mesh(geometry, material);
                    tile.rotation.x = -Math.PI / 2;

                    const posX = (dx - halfTiles + 0.5) * tileSize;
                    const posZ = (dy - halfTiles + 0.5) * tileSize;
                    tile.position.set(posX, 0, posZ);

                    scene.add(tile);
                    mapTiles.push(tile);

                    // Load texture
                    if (tileCache.has(cacheKey)) {
                        material.map = tileCache.get(cacheKey);
                        material.color.setHex(0xffffff);
                        material.needsUpdate = true;
                    } else {
                        const url = getTileUrl(tileX, tileY, currentZoom);

                        if (currentTheme === 'retro') {
                            // Load image manually to invert colors
                            const img = new Image();
                            img.crossOrigin = 'anonymous';
                            img.onload = () => {
                                const invertedCanvas = invertToGreen(img);
                                const texture = new THREE.CanvasTexture(invertedCanvas);
                                material.map = texture;
                                material.color.setHex(0xffffff);
                                material.needsUpdate = true;
                                tileCache.set(cacheKey, texture);
                            };
                            img.src = url;
                        } else {
                            loader.load(url, (texture) => {
                                material.color.setHex(0xffffff);
                                material.map = texture;
                                material.needsUpdate = true;
                                tileCache.set(cacheKey, texture);
                            });
                        }
                    }
                }
            }

            document.getElementById('map-zoom').textContent = currentZoom;
            updateAllAircraftPositions();
        }

        function mapZoomIn() {
            if (currentZoom < MAX_ZOOM) {
                currentZoom++;
                loadMapTiles();
            }
        }

        function mapZoomOut() {
            if (currentZoom > MIN_ZOOM) {
                currentZoom--;
                loadMapTiles();
            }
        }

        // Map pan function
        function panMap(direction) {
            const zoomFactor = Math.pow(2, 12 - currentZoom);
            const panAmount = 0.05 * zoomFactor;

            switch(direction) {
                case 'up': centerLat += panAmount; break;
                case 'down': centerLat -= panAmount; break;
                case 'left': centerLon -= panAmount; break;
                case 'right': centerLon += panAmount; break;
            }

            document.getElementById('center-coords').textContent =
                `${centerLat.toFixed(2)}, ${centerLon.toFixed(2)}`;

            loadMapTiles();
        }

        function latLonToXZ(lat, lon) {
            if (!window.mapBounds) return { x: 0, z: 0 };
            const bounds = window.mapBounds;
            // X: longitude - West is negative X, East is positive X
            const x = ((lon - bounds.west) / (bounds.east - bounds.west) - 0.5) * MAP_GROUND_SIZE;
            // Z: latitude - North is negative Z, South is positive Z
            // (lat - north) is negative for points north of center, divided by (south - north) which is negative
            // Result: north points get negative Z, south points get positive Z
            const z = ((lat - bounds.north) / (bounds.south - bounds.north) - 0.5) * MAP_GROUND_SIZE;
            return { x, z };
        }

        function getAltitudeColor(altitude) {
            if (currentTheme === 'retro') {
                if (altitude < 5000) return 0x00ff00;
                if (altitude < 15000) return 0x00cc00;
                if (altitude < 30000) return 0x009900;
                return 0x006600;
            }
            if (altitude < 5000) return 0x00ff00;
            if (altitude < 15000) return 0xffff00;
            if (altitude < 30000) return 0xff8800;
            return 0xff0088;
        }

        function createAirplane(data) {
            const group = new THREE.Group();
            const color = getAltitudeColor(data.altitude || 0);
            const isRetro = currentTheme === 'retro';

            if (isRetro) {
                // WIREFRAME MODE for retro 80s theme
                const wireColor = 0x00ff00;
                const wireMat = new THREE.LineBasicMaterial({ color: wireColor });

                // Fuselage wireframe
                const fuselageGeom = new THREE.BoxGeometry(0.8, 0.6, 4);
                const fuselageEdges = new THREE.EdgesGeometry(fuselageGeom);
                const fuselageWire = new THREE.LineSegments(fuselageEdges, wireMat);
                group.add(fuselageWire);

                // Nose cone wireframe
                const noseGeom = new THREE.ConeGeometry(0.4, 1.2, 4);
                const noseEdges = new THREE.EdgesGeometry(noseGeom);
                const noseWire = new THREE.LineSegments(noseEdges, wireMat);
                noseWire.rotation.x = -Math.PI / 2;
                noseWire.position.z = 2.6;
                group.add(noseWire);

                // Wings wireframe
                const wingGeom = new THREE.BoxGeometry(6, 0.1, 1.5);
                const wingEdges = new THREE.EdgesGeometry(wingGeom);
                const wingWire = new THREE.LineSegments(wingEdges, wireMat);
                group.add(wingWire);

                // Tail fin wireframe
                const tailGeom = new THREE.BoxGeometry(0.1, 1.2, 0.8);
                const tailEdges = new THREE.EdgesGeometry(tailGeom);
                const tailWire = new THREE.LineSegments(tailEdges, wireMat);
                tailWire.position.set(0, 0.6, -1.8);
                group.add(tailWire);

                // Horizontal stabilizer wireframe
                const hStabGeom = new THREE.BoxGeometry(2.5, 0.1, 0.5);
                const hStabEdges = new THREE.EdgesGeometry(hStabGeom);
                const hStabWire = new THREE.LineSegments(hStabEdges, wireMat);
                hStabWire.position.set(0, 0, -1.8);
                group.add(hStabWire);

                // Blinking light
                const lightGeom = new THREE.SphereGeometry(0.2, 4, 4);
                const lightMat = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true });
                const positionLight = new THREE.Mesh(lightGeom, lightMat);
                positionLight.position.set(0, 0, 2.6);
                group.add(positionLight);

                group.userData = {
                    ...data,
                    noseMaterial: null,
                    positionLight: positionLight,
                    lightPhase: Math.random() * Math.PI * 2,
                    isWireframe: true
                };
            } else {
                // SOLID MODE for day/night themes
                const fuselageGeom = new THREE.CylinderGeometry(0.4, 0.6, 4, 8);
                const fuselageMat = new THREE.MeshPhongMaterial({ color: 0xffffff, emissive: 0x222222 });
                const fuselage = new THREE.Mesh(fuselageGeom, fuselageMat);
                fuselage.rotation.x = Math.PI / 2;
                group.add(fuselage);

                const noseGeom = new THREE.ConeGeometry(0.4, 1.2, 8);
                const noseMat = new THREE.MeshPhongMaterial({ color: color, emissive: color, emissiveIntensity: 0.3 });
                const nose = new THREE.Mesh(noseGeom, noseMat);
                nose.rotation.x = -Math.PI / 2;
                nose.position.z = 2.6;
                group.add(nose);

                const wingGeom = new THREE.BoxGeometry(5, 0.15, 1.5);
                const wingMat = new THREE.MeshPhongMaterial({ color: 0xcccccc, emissive: 0x333333 });
                const wings = new THREE.Mesh(wingGeom, wingMat);
                group.add(wings);

                const tailFinGeom = new THREE.BoxGeometry(0.15, 1.2, 1);
                const tailFin = new THREE.Mesh(tailFinGeom, wingMat);
                tailFin.position.set(0, 0.6, -1.8);
                group.add(tailFin);

                const hStabGeom = new THREE.BoxGeometry(2, 0.1, 0.6);
                const hStab = new THREE.Mesh(hStabGeom, wingMat);
                hStab.position.set(0, 0, -1.8);
                group.add(hStab);

                const engineGeom = new THREE.CylinderGeometry(0.25, 0.25, 0.8, 8);
                const engineMat = new THREE.MeshPhongMaterial({ color: 0x444444 });
                [-1.2, 1.2].forEach(xPos => {
                    const engine = new THREE.Mesh(engineGeom, engineMat);
                    engine.rotation.x = Math.PI / 2;
                    engine.position.set(xPos, -0.3, 0.2);
                    group.add(engine);
                });

                const lightGeom = new THREE.SphereGeometry(0.15, 8, 8);
                const lightMat = new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true });
                const positionLight = new THREE.Mesh(lightGeom, lightMat);
                positionLight.position.set(0, 0.3, -1.5);
                group.add(positionLight);

                group.userData = {
                    ...data,
                    noseMaterial: noseMat,
                    positionLight: positionLight,
                    lightPhase: Math.random() * Math.PI * 2,
                    isWireframe: false
                };
            }

            // Trail - DO NOT add to scene yet, will be managed separately
            // Trail points will be collected in userData.trailPoints
            group.userData.trail = null; // Will be created when needed
            group.userData.trailPoints = [];
            group.userData.trailMaterial = null;

            // Altitude line - also deferred
            group.userData.altLine = null;

            return group;
        }

        // Create trail line for a plane (only when it has points)
        function createTrailForPlane(plane) {
            if (plane.userData.trail) return; // Already has trail

            const isRetro = currentTheme === 'retro';
            const color = isRetro ? 0x00ff00 : getAltitudeColor(plane.userData.altitude || 0);

            const trailGeom = new THREE.BufferGeometry();
            const trailPositions = new Float32Array(300 * 3); // 100 points max
            trailGeom.setAttribute('position', new THREE.BufferAttribute(trailPositions, 3));
            trailGeom.setDrawRange(0, 0);

            const trailMat = new THREE.LineBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.8,
                depthTest: true,
                depthWrite: false,
                linewidth: 2
            });

            const trail = new THREE.Line(trailGeom, trailMat);
            trail.frustumCulled = false;
            trail.renderOrder = 999; // Render after most objects
            trail.visible = showTrails;
            scene.add(trail);

            plane.userData.trail = trail;
            plane.userData.trailMaterial = trailMat;
        }

        // Create altitude line for a plane
        function createAltLineForPlane(plane) {
            if (plane.userData.altLine) return;

            const isRetro = currentTheme === 'retro';
            const altLineGeom = new THREE.BufferGeometry();
            const altLinePositions = new Float32Array(6);
            altLineGeom.setAttribute('position', new THREE.BufferAttribute(altLinePositions, 3));
            altLineGeom.setDrawRange(0, 0);

            const altLineMat = new THREE.LineDashedMaterial({
                color: isRetro ? 0x00ff00 : 0x888888,
                dashSize: 2,
                gapSize: 1,
                transparent: true,
                opacity: 0.4
            });

            const altLine = new THREE.Line(altLineGeom, altLineMat);
            scene.add(altLine);

            plane.userData.altLine = altLine;
        }

        async function fetchData() {
            try {
                const response = await fetch(DATA_URL);
                const data = await response.json();
                const now = Date.now();

                if (data.aircraft && data.aircraft.length > 0) {
                    if (!centerInitialized) {
                        let sumLat = 0, sumLon = 0, count = 0;
                        data.aircraft.forEach(ac => {
                            if (ac.lat && ac.lon) {
                                sumLat += ac.lat;
                                sumLon += ac.lon;
                                count++;
                            }
                        });
                        if (count > 0) {
                            centerLat = sumLat / count;
                            centerLon = sumLon / count;
                            centerInitialized = true;
                            document.getElementById('center-coords').textContent =
                                `${centerLat.toFixed(2)}, ${centerLon.toFixed(2)}`;
                            loadMapTiles();
                        }
                    }

                    // Store data in buffer with timestamp
                    data.aircraft.forEach(ac => {
                        if (!ac.lat || !ac.lon) return;

                        if (!aircraftDataBuffer.has(ac.hex)) {
                            aircraftDataBuffer.set(ac.hex, []);
                        }

                        const buffer = aircraftDataBuffer.get(ac.hex);
                        buffer.push({ timestamp: now, data: {...ac} });

                        // Keep only last 5 seconds of data
                        while (buffer.length > 0 && buffer[0].timestamp < now - 5000) {
                            buffer.shift();
                        }
                    });

                    // Clean up old aircraft
                    const currentHexes = new Set(data.aircraft.map(ac => ac.hex));
                    for (const [hex, buffer] of aircraftDataBuffer.entries()) {
                        if (!currentHexes.has(hex) && buffer.length > 0) {
                            const lastEntry = buffer[buffer.length - 1];
                            if (now - lastEntry.timestamp > INTERPOLATION_DELAY + 2000) {
                                aircraftDataBuffer.delete(hex);
                            }
                        }
                    }

                    document.getElementById('plane-count').textContent = data.aircraft.length;
                    document.getElementById('last-update').textContent = new Date().toLocaleTimeString();
                }
            } catch (error) {
                console.error('Error fetching data:', error);
            }
        }

        // Linear interpolation
        function lerp(a, b, t) {
            return a + (b - a) * t;
        }

        // Angle interpolation (handles wraparound)
        function lerpAngle(a, b, t) {
            a = ((a % 360) + 360) % 360;
            b = ((b % 360) + 360) % 360;
            let diff = b - a;
            if (diff > 180) diff -= 360;
            if (diff < -180) diff += 360;
            return a + diff * t;
        }

        // Reusable object for interpolated data to avoid GC
        const _interpolatedData = {
            hex: '', lat: 0, lon: 0, altitude: 0, track: 0, gs: 0, baro_rate: 0, flight: '', squawk: ''
        };

        // Interpolation function - called at 30fps
        function interpolateAircraft() {
            const now = Date.now();
            const targetTime = now - INTERPOLATION_DELAY;

            // Reuse cached set instead of creating new one
            _seenHexes.clear();

            let planesChanged = false;

            for (const [hex, buffer] of aircraftDataBuffer.entries()) {
                if (buffer.length === 0) continue;

                // Find data points to interpolate between
                let before = null;
                let after = null;

                for (let i = 0; i < buffer.length; i++) {
                    if (buffer[i].timestamp <= targetTime) {
                        before = buffer[i];
                    } else {
                        after = buffer[i];
                        break;
                    }
                }

                if (!before && !after) continue;
                if (!before) before = after;
                if (!after) after = before;

                _seenHexes.add(hex);

                // Calculate interpolation factor
                let t = 0;
                if (before !== after && after.timestamp !== before.timestamp) {
                    t = (targetTime - before.timestamp) / (after.timestamp - before.timestamp);
                    t = Math.max(0, Math.min(1, t));
                }

                // Interpolate data - reuse object to avoid GC
                // Note: dump1090 uses 'gs' for ground speed, 'tas' for true airspeed, 'speed' sometimes
                const beforeSpeed = before.data.gs ?? before.data.speed ?? before.data.tas;
                const afterSpeed = after.data.gs ?? after.data.speed ?? after.data.tas;
                const beforeAlt = before.data.altitude ?? before.data.alt_baro ?? before.data.alt_geom ?? 0;
                const afterAlt = after.data.altitude ?? after.data.alt_baro ?? after.data.alt_geom ?? 0;
                // Support multiple vertical rate field names
                const beforeVertRate = before.data.baro_rate ?? before.data.geom_rate ?? before.data.vert_rate ?? 0;
                const afterVertRate = after.data.baro_rate ?? after.data.geom_rate ?? after.data.vert_rate ?? 0;

                // Populate reusable object
                _interpolatedData.hex = hex;
                _interpolatedData.lat = lerp(before.data.lat, after.data.lat, t);
                _interpolatedData.lon = lerp(before.data.lon, after.data.lon, t);
                _interpolatedData.altitude = lerp(beforeAlt, afterAlt, t);
                _interpolatedData.track = lerpAngle(before.data.track || 0, after.data.track || 0, t);
                _interpolatedData.gs = (beforeSpeed !== undefined && afterSpeed !== undefined) ? lerp(beforeSpeed, afterSpeed, t) : (afterSpeed ?? beforeSpeed);
                _interpolatedData.baro_rate = lerp(beforeVertRate, afterVertRate, t);
                _interpolatedData.flight = after.data.flight || before.data.flight || '';
                _interpolatedData.squawk = after.data.squawk || before.data.squawk || '';

                let plane = airplanes.get(hex);

                if (plane) {
                    // Update existing plane
                    const pos = latLonToXZ(_interpolatedData.lat, _interpolatedData.lon);
                    const alt = _interpolatedData.altitude * altitudeScale;

                    // Store previous position for trail BEFORE updating
                    const prevX = plane.position.x;
                    const prevY = plane.position.y;
                    const prevZ = plane.position.z;

                    // Update position FIRST
                    plane.position.set(pos.x, alt, pos.z);

                    // Update heading
                    if (_interpolatedData.track !== undefined) {
                        plane.rotation.y = (-_interpolatedData.track * Math.PI / 180) + Math.PI;
                    }

                    // Mark plane as initialized after first real position update
                    if (!plane.userData.positionInitialized) {
                        plane.userData.positionInitialized = true;
                        plane.userData.initTime = now;
                    }

                    // Add trail point using lat/lon coordinates (not world coords)
                    // This ensures trails remain valid when map bounds change
                    const timeSinceInit = now - (plane.userData.initTime || now);
                    if (showTrails && timeSinceInit > 500) {
                        if (now - (plane.userData.lastTrailTime || 0) > 100) {
                            plane.userData.lastTrailTime = now;

                            // Store as lat/lon/alt - these are stable coordinates
                            const lastPoint = plane.userData.trailPoints[plane.userData.trailPoints.length - 1];
                            const currentLat = plane.userData.lat;
                            const currentLon = plane.userData.lon;
                            const currentAlt = plane.userData.altitude;

                            // Only add if we have valid coordinates and position changed
                            if (currentLat && currentLon) {
                                const dominated = lastPoint &&
                                    Math.abs(lastPoint.lat - currentLat) < 0.0001 &&
                                    Math.abs(lastPoint.lon - currentLon) < 0.0001;

                                if (!dominated) {
                                    plane.userData.trailPoints.push({
                                        lat: currentLat,
                                        lon: currentLon,
                                        alt: currentAlt || 0,
                                        time: now
                                    });
                                    // Remove points older than trailDuration
                                    const cutoff = now - (trailDuration * 1000);
                                    while (plane.userData.trailPoints.length > 0 &&
                                           plane.userData.trailPoints[0].time < cutoff) {
                                        plane.userData.trailPoints.shift();
                                    }
                                    updateTrail(plane);
                                }
                            }
                        }
                    }

                    // Update altitude line
                    updateAltitudeLine(plane);

                    // Update colors
                    const newColor = getAltitudeColor(_interpolatedData.altitude);
                    if (plane.userData.noseMaterial) {
                        plane.userData.noseMaterial.color.setHex(newColor);
                        plane.userData.noseMaterial.emissive.setHex(newColor);
                    }
                    if (plane.userData.trailMaterial && currentTheme !== 'retro') {
                        plane.userData.trailMaterial.color.setHex(newColor);
                    }

                    // Update userData without creating new object
                    plane.userData.hex = _interpolatedData.hex;
                    plane.userData.lat = _interpolatedData.lat;
                    plane.userData.lon = _interpolatedData.lon;
                    plane.userData.altitude = _interpolatedData.altitude;
                    plane.userData.track = _interpolatedData.track;
                    plane.userData.gs = _interpolatedData.gs;
                    plane.userData.baro_rate = _interpolatedData.baro_rate;
                    plane.userData.flight = _interpolatedData.flight;
                    plane.userData.squawk = _interpolatedData.squawk;
                } else {
                    // Create new plane - need to copy data since we're reusing _interpolatedData
                    const newPlaneData = {
                        hex: _interpolatedData.hex,
                        lat: _interpolatedData.lat,
                        lon: _interpolatedData.lon,
                        altitude: _interpolatedData.altitude,
                        track: _interpolatedData.track,
                        gs: _interpolatedData.gs,
                        baro_rate: _interpolatedData.baro_rate,
                        flight: _interpolatedData.flight,
                        squawk: _interpolatedData.squawk
                    };

                    plane = createAirplane(newPlaneData);
                    const pos = latLonToXZ(newPlaneData.lat, newPlaneData.lon);
                    const alt = newPlaneData.altitude * altitudeScale;

                    // Set position immediately so plane never appears at origin
                    plane.position.set(pos.x, alt, pos.z);

                    if (newPlaneData.track !== undefined) {
                        plane.rotation.y = (-newPlaneData.track * Math.PI / 180) + Math.PI;
                    }

                    // Mark as initialized with current time - trails won't record for 500ms
                    plane.userData.positionInitialized = true;
                    plane.userData.initTime = now;

                    scene.add(plane);
                    airplanes.set(hex, plane);
                    planesChanged = true;

                    // Load trail history from DB
                    loadTrailFromDb(hex, (trailData) => {
                        if (trailData && trailData.points && trailData.points.length > 0 && showTrails) {
                            // Restore trail points
                            plane.userData.trailPoints = trailData.points.slice();
                            updateTrail(plane);
                        }
                    });

                    // Create altitude line after plane is positioned
                    createAltLineForPlane(plane);
                    updateAltitudeLine(plane);
                }
            }

            // Remove planes no longer in data
            for (const [hex, plane] of airplanes.entries()) {
                if (!_seenHexes.has(hex)) {
                    scene.remove(plane);
                    if (plane.userData.trail) scene.remove(plane.userData.trail);
                    if (plane.userData.altLine) scene.remove(plane.userData.altLine);
                    airplanes.delete(hex);
                    planesChanged = true;
                }
            }

            // Mark cached array as dirty if planes were added/removed
            if (planesChanged) {
                _airplanesArrayDirty = true;
            }
        }

        function updateAltitudeLine(plane) {
            if (!plane.userData.altLine) {
                createAltLineForPlane(plane);
            }

            const altLine = plane.userData.altLine;
            if (!altLine) return;

            // Only draw if plane has valid position
            const absX = plane.position.x < 0 ? -plane.position.x : plane.position.x;
            const absZ = plane.position.z < 0 ? -plane.position.z : plane.position.z;
            if (absX < 0.1 && absZ < 0.1) {
                altLine.geometry.setDrawRange(0, 0);
                return;
            }

            const positions = altLine.geometry.attributes.position.array;
            positions[0] = plane.position.x;
            positions[1] = plane.position.y;
            positions[2] = plane.position.z;
            positions[3] = plane.position.x;
            positions[4] = 0;
            positions[5] = plane.position.z;

            altLine.geometry.attributes.position.needsUpdate = true;
            altLine.geometry.setDrawRange(0, 2);

            // Throttle computeLineDistances - only recompute every 500ms
            const now = Date.now();
            if (!plane.userData._lastLineDistTime || now - plane.userData._lastLineDistTime > 500) {
                plane.userData._lastLineDistTime = now;
                altLine.computeLineDistances();
            }
        }

        function updateAllAircraftPositions() {
            // Use cached array
            if (_airplanesArrayDirty) {
                _airplanesArray = Array.from(airplanes.values());
                _airplanesArrayDirty = false;
            }
            for (let i = 0, len = _airplanesArray.length; i < len; i++) {
                const plane = _airplanesArray[i];
                if (plane.userData.lat && plane.userData.lon) {
                    const pos = latLonToXZ(plane.userData.lat, plane.userData.lon);
                    const alt = (plane.userData.altitude || 0) * altitudeScale;
                    plane.position.set(pos.x, alt, pos.z);
                    updateAltitudeLine(plane);
                }
            }
            updateLabels();
        }

        function updateTrail(plane) {
            const points = plane.userData.trailPoints;

            // Need at least 2 valid points to draw a trail
            if (points.length < 2) {
                if (plane.userData.trail) {
                    plane.userData.trail.geometry.setDrawRange(0, 0);
                }
                return;
            }

            // Create trail if needed
            if (!plane.userData.trail) {
                createTrailForPlane(plane);
            }

            const trail = plane.userData.trail;
            if (!trail) return;

            const positions = trail.geometry.attributes.position.array;

            // Convert lat/lon trail points to world coordinates
            let validCount = 0;
            const maxPoints = Math.min(points.length, 100);

            for (let i = 0; i < maxPoints; i++) {
                const pt = points[i];
                // Points are stored as {lat, lon, alt}
                if (pt.lat !== undefined && pt.lon !== undefined) {
                    const worldPos = latLonToXZ(pt.lat, pt.lon);
                    const alt = (pt.alt || 0) * altitudeScale;
                    const idx = validCount * 3;
                    positions[idx] = worldPos.x;
                    positions[idx + 1] = alt;
                    positions[idx + 2] = worldPos.z;
                    validCount++;
                }
            }

            // Add current plane position as the final point
            if (validCount < 100 && plane.userData.lat && plane.userData.lon) {
                const idx = validCount * 3;
                positions[idx] = plane.position.x;
                positions[idx + 1] = plane.position.y;
                positions[idx + 2] = plane.position.z;
                validCount++;
            }

            trail.geometry.attributes.position.needsUpdate = true;
            trail.geometry.setDrawRange(0, validCount);

            // Save trail to DB periodically (every 10 seconds)
            if (!plane.userData.lastTrailSave || Date.now() - plane.userData.lastTrailSave > 10000) {
                plane.userData.lastTrailSave = Date.now();
                saveTrailToDb(plane.userData.hex, plane.userData.trailPoints, plane.userData.lat, plane.userData.lon);
            }
        }

        // Get vertical speed arrow character and size
        // baro_rate is in ft/min, we need to convert to m/s for sizing
        // 2 m/s = 393.7 ft/min (minimum threshold)
        // 20 m/s = 3937 ft/min (maximum size)
        function getVerticalSpeedArrow(baroRate) {
            if (baroRate === undefined || baroRate === null) return null;

            // Convert ft/min to m/s (divide by 196.85)
            const vertSpeedMs = Math.abs(baroRate) / 196.85;

            // Ignore vertical speeds below 2 m/s
            if (vertSpeedMs < 2) return null;

            // Cap at 20 m/s for sizing
            const clampedSpeed = Math.min(vertSpeedMs, 20);

            // Scale arrow size: 2 m/s -> 16px, 20 m/s -> 48px (linear)
            const arrowSize = 16 + ((clampedSpeed - 2) / 18) * 32;

            const arrow = baroRate > 0 ? '↑' : '↓';
            const color = baroRate > 0 ? '#44ff44' : '#ff6644';

            return { arrow, size: arrowSize, color };
        }

        // Get a canvas from pool or create new one
        function _getPooledCanvas() {
            if (_labelCanvasPool.length > 0) {
                return _labelCanvasPool.pop();
            }
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 80;
            return canvas;
        }

        // Return canvas to pool
        function _returnCanvasToPool(canvas) {
            if (_labelCanvasPool.length < MAX_LABEL_POOL_SIZE) {
                _labelCanvasPool.push(canvas);
            }
        }

        // Render label content to canvas
        function _renderLabelToCanvas(ctx, plane) {
            // Clear canvas
            ctx.clearRect(0, 0, 256, 80);

            if (currentTheme === 'retro') {
                ctx.fillStyle = 'rgba(0, 20, 0, 0.9)';
                ctx.strokeStyle = '#00ff00';
                ctx.lineWidth = 2;
            } else {
                ctx.fillStyle = 'rgba(0, 20, 40, 0.85)';
            }
            ctx.beginPath();
            ctx.roundRect(0, 0, 256, 80, 8);
            ctx.fill();
            if (currentTheme === 'retro') ctx.stroke();

            ctx.fillStyle = currentTheme === 'retro' ? '#00ff00' : '#00ffff';
            ctx.font = 'bold 22px monospace';
            const callsign = plane.userData.flight || plane.userData.hex || 'Unknown';
            ctx.fillText(callsign.trim(), 10, 28);

            ctx.fillStyle = currentTheme === 'retro' ? '#00cc00' : '#88ff88';
            ctx.font = '16px monospace';
            ctx.fillText(formatAltitude(plane.userData.altitude || 0), 10, 50);

            if (plane.userData.gs !== undefined && plane.userData.gs !== null) {
                ctx.fillStyle = currentTheme === 'retro' ? '#00aa00' : '#ffaa00';
                ctx.fillText(formatSpeed(plane.userData.gs), 10, 70);
            }

            // Draw vertical speed arrow on the right side
            const arrowInfo = getVerticalSpeedArrow(plane.userData.baro_rate);
            if (arrowInfo) {
                ctx.fillStyle = currentTheme === 'retro' ? '#00ff00' : arrowInfo.color;
                ctx.font = `bold ${Math.round(arrowInfo.size)}px sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(arrowInfo.arrow, 230, 40);
                ctx.textAlign = 'left';
                ctx.textBaseline = 'alphabetic';
            }
        }

        function updateLabels() {
            // Return old canvases to pool and collect sprites for reuse
            const oldSprites = [];
            for (let i = 0; i < labels.length; i++) {
                const label = labels[i];
                scene.remove(label);
                // Return canvas to pool if it exists
                if (label.material && label.material.map && label.material.map.image) {
                    _returnCanvasToPool(label.material.map.image);
                }
                oldSprites.push(label);
            }
            labels.length = 0;

            // Clear label references from planes
            if (_airplanesArrayDirty) {
                _airplanesArray = Array.from(airplanes.values());
                _airplanesArrayDirty = false;
            }
            for (let i = 0; i < _airplanesArray.length; i++) {
                _airplanesArray[i].userData.label = null;
            }

            if (!showLabels) return;

            let spriteIndex = 0;
            for (let i = 0; i < _airplanesArray.length; i++) {
                const plane = _airplanesArray[i];
                const canvas = _getPooledCanvas();
                const ctx = canvas.getContext('2d');

                _renderLabelToCanvas(ctx, plane);

                let sprite;
                if (spriteIndex < oldSprites.length) {
                    // Reuse existing sprite
                    sprite = oldSprites[spriteIndex];
                    sprite.material.map.image = canvas;
                    sprite.material.map.needsUpdate = true;
                } else {
                    // Create new sprite
                    const texture = new THREE.CanvasTexture(canvas);
                    const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
                    sprite = new THREE.Sprite(material);
                    sprite.scale.set(15, 4.7, 1);
                }
                spriteIndex++;

                sprite.position.copy(plane.position);
                sprite.position.y += 8;

                // Store reference to label on the plane for correct position updates
                plane.userData.label = sprite;

                scene.add(sprite);
                labels.push(sprite);
            }

            // Dispose unused old sprites
            for (let i = spriteIndex; i < oldSprites.length; i++) {
                const sprite = oldSprites[i];
                if (sprite.material) {
                    if (sprite.material.map) sprite.material.map.dispose();
                    sprite.material.dispose();
                }
            }
        }

        // Camera controls
        function setupControls() {
            renderer.domElement.addEventListener('mousedown', (e) => {
                isDragging = true;
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });

            renderer.domElement.addEventListener('mousemove', (e) => {
                if (!isDragging) return;

                const deltaX = e.clientX - previousMousePosition.x;
                const deltaY = e.clientY - previousMousePosition.y;

                cameraAngle += deltaX * 0.01;
                cameraHeight = Math.max(10, Math.min(300, cameraHeight - deltaY * 0.5));

                updateCameraPosition();
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });

            renderer.domElement.addEventListener('mouseup', () => isDragging = false);
            renderer.domElement.addEventListener('mouseleave', () => isDragging = false);

            renderer.domElement.addEventListener('wheel', (e) => {
                cameraDistance = Math.max(30, Math.min(500, cameraDistance + e.deltaY * 0.2));
                updateCameraPosition();
            });
        }

        function updateCameraPosition() {
            camera.position.x = Math.sin(cameraAngle) * cameraDistance;
            camera.position.z = Math.cos(cameraAngle) * cameraDistance;
            camera.position.y = cameraHeight;
            camera.lookAt(0, cameraHeight * 0.2, 0);
        }

        function resetCamera() {
            cameraAngle = 0;
            cameraHeight = 80;
            cameraDistance = 150;
            updateCameraPosition();
        }

        function cameraZoomIn() {
            cameraDistance = Math.max(30, cameraDistance - 20);
            updateCameraPosition();
        }

        function cameraZoomOut() {
            cameraDistance = Math.min(500, cameraDistance + 20);
            updateCameraPosition();
        }

        // Smooth rotation
        let rotateDirection = null;
        let rotateInterval = null;

        function startRotate(direction) {
            rotateDirection = direction;
            if (rotateInterval) clearInterval(rotateInterval);
            rotateInterval = setInterval(() => {
                if (rotateDirection === 'left') {
                    cameraAngle -= 0.02;
                } else if (rotateDirection === 'right') {
                    cameraAngle += 0.02;
                }
                updateCameraPosition();
            }, 16);
        }

        function stopRotate() {
            rotateDirection = null;
            if (rotateInterval) {
                clearInterval(rotateInterval);
                rotateInterval = null;
            }
        }

        function toggleAutoRotate() {
            autoRotate = !autoRotate;
            document.getElementById('btn-rotate').classList.toggle('active', autoRotate);
            saveSettings();
        }

        function toggleLabels() {
            showLabels = !showLabels;
            document.getElementById('btn-labels').classList.toggle('active', showLabels);
            updateLabels();
            saveSettings();
        }

        function onMouseClick(event) {
            // Reuse cached objects to avoid GC pressure
            _mouseVec.x = (event.clientX / window.innerWidth) * 2 - 1;
            _mouseVec.y = -(event.clientY / window.innerHeight) * 2 + 1;

            _raycaster.setFromCamera(_mouseVec, camera);

            // Use cached array if available
            if (_airplanesArrayDirty) {
                _airplanesArray = Array.from(airplanes.values());
                _airplanesArrayDirty = false;
            }
            const intersects = _raycaster.intersectObjects(_airplanesArray, true);

            if (intersects.length > 0) {
                let plane = intersects[0].object;
                while (plane.parent && !plane.userData.hex) {
                    plane = plane.parent;
                }
                if (plane.userData.hex) {
                    selectPlane(plane);
                }
            } else {
                deselectPlane();
            }
        }

        function selectPlane(plane) {
            selectedPlane = plane;
            const panel = document.getElementById('selected-plane');
            panel.style.display = 'block';

            document.getElementById('sel-callsign').textContent = plane.userData.flight || plane.userData.hex || '--';
            document.getElementById('sel-altitude').textContent = formatAltitude(plane.userData.altitude || 0);
            document.getElementById('sel-speed').textContent = (plane.userData.gs !== undefined && plane.userData.gs !== null) ? formatSpeed(plane.userData.gs) : '--';
            document.getElementById('sel-track').textContent = (plane.userData.track || '--') + '°';
            document.getElementById('sel-vertrate').textContent = plane.userData.baro_rate ? formatVertRate(plane.userData.baro_rate) : '--';
            document.getElementById('sel-squawk').textContent = plane.userData.squawk || '--';
            document.getElementById('sel-position').textContent =
                `${(plane.userData.lat || 0).toFixed(4)}°, ${(plane.userData.lon || 0).toFixed(4)}°`;
        }

        function deselectPlane() {
            selectedPlane = null;
            document.getElementById('selected-plane').style.display = 'none';
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        let time = 0;
        let lastLabelUpdate = 0;
        const INTERPOLATION_INTERVAL = 1000 / INTERPOLATION_FPS;

        function animate() {
            requestAnimationFrame(animate);

            // Skip rendering when tab is not visible to save CPU/power
            if (!_isTabVisible) return;

            const now = Date.now();
            time += 0.016;

            // Run interpolation at 30fps
            if (now - lastInterpolationTime >= INTERPOLATION_INTERVAL) {
                lastInterpolationTime = now;
                interpolateAircraft();
            }

            if (autoRotate) {
                cameraAngle += 0.002;
                updateCameraPosition();
            }

            // Update cached array if needed
            if (_airplanesArrayDirty) {
                _airplanesArray = Array.from(airplanes.values());
                _airplanesArrayDirty = false;
            }

            const needsLabelRedraw = now - lastLabelUpdate > 1000;
            const updateLabelPositions = !needsLabelRedraw && showLabels;

            // Single combined loop for lights and label positions
            for (let i = 0, len = _airplanesArray.length; i < len; i++) {
                const plane = _airplanesArray[i];

                // Animate position lights
                if (plane.userData.positionLight) {
                    plane.userData.lightPhase += 0.08;
                    const brightness = Math.sin(plane.userData.lightPhase) > 0.7 ? 1 : 0.2;
                    plane.userData.positionLight.material.opacity = brightness;
                }

                // Update label positions between full redraws
                if (updateLabelPositions && plane.userData.label) {
                    plane.userData.label.position.x = plane.position.x;
                    plane.userData.label.position.y = plane.position.y + 8;
                    plane.userData.label.position.z = plane.position.z;
                }
            }

            // Update labels periodically - redraw every 1 second to update speed/altitude
            if (needsLabelRedraw) {
                lastLabelUpdate = now;
                updateLabels();

                if (selectedPlane && airplanes.has(selectedPlane.userData.hex)) {
                    selectPlane(airplanes.get(selectedPlane.userData.hex));
                }
            }

            renderer.render(scene, camera);
        }

        // Initialize
        init();

        // Set button states based on loaded settings
        document.getElementById('btn-labels').classList.toggle('active', showLabels);
        document.getElementById('btn-rotate').classList.toggle('active', autoRotate);
        document.getElementById('btn-graphs').classList.toggle('active', showGraphs);
    </script>
</body>
</html>
