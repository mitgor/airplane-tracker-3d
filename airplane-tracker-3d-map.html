<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Airplane Tracker with Map</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            transition: background 0.3s ease;
        }
        body.theme-day {
            background: #87CEEB;
            color: #333;
        }
        body.theme-night {
            background: #0a0a1a;
            color: #fff;
        }
        body.theme-retro {
            background: #000800;
            color: #00ff00;
        }
        #container {
            width: 100vw;
            height: 100vh;
        }
        .data-mode-badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.7em;
            font-weight: bold;
            letter-spacing: 1px;
        }
        .data-mode-local {
            background: rgba(0, 180, 0, 0.3);
            color: #00ff88;
            border: 1px solid rgba(0, 180, 0, 0.5);
        }
        .data-mode-global {
            background: rgba(0, 120, 255, 0.3);
            color: #66bbff;
            border: 1px solid rgba(0, 120, 255, 0.5);
        }
        /* Airport Search */
        #airport-search-panel {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            width: 320px;
        }
        #airport-search-input {
            width: 100%;
            padding: 10px 14px;
            border-radius: 8px;
            border: 1px solid rgba(100,100,100,0.4);
            font-size: 14px;
            outline: none;
            backdrop-filter: blur(10px);
        }
        .theme-day #airport-search-input { background: rgba(255,255,255,0.9); color: #333; }
        .theme-night #airport-search-input { background: rgba(0,20,40,0.9); color: #fff; border-color: rgba(0,150,255,0.3); }
        .theme-retro #airport-search-input { background: rgba(0,20,0,0.9); color: #00ff00; border-color: #00ff00; font-family: monospace; }
        #airport-results {
            display: none;
            max-height: 300px;
            overflow-y: auto;
            border-radius: 0 0 8px 8px;
            margin-top: 2px;
        }
        .theme-day #airport-results { background: rgba(255,255,255,0.95); }
        .theme-night #airport-results { background: rgba(0,20,40,0.95); border: 1px solid rgba(0,150,255,0.3); }
        .theme-retro #airport-results { background: rgba(0,20,0,0.95); border: 1px solid #00ff00; }
        .airport-result-item {
            padding: 8px 14px;
            cursor: pointer;
            border-bottom: 1px solid rgba(100,100,100,0.2);
            font-size: 13px;
        }
        .airport-result-item:hover { background: rgba(100,150,255,0.15); }
        .airport-result-item .airport-code { font-weight: bold; margin-right: 6px; }
        .airport-result-item .airport-dist { float: right; opacity: 0.6; font-size: 0.85em; }
        #info-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 20px;
            border-radius: 12px;
            min-width: 280px;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }
        .theme-day #info-panel {
            background: rgba(255, 255, 255, 0.85);
            border: 1px solid rgba(0, 100, 200, 0.3);
        }
        .theme-night #info-panel {
            background: rgba(0, 20, 40, 0.85);
            border: 1px solid rgba(0, 150, 255, 0.3);
        }
        .theme-retro #info-panel {
            background: rgba(0, 20, 0, 0.9);
            border: 1px solid #00ff00;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.3);
        }
        #info-panel h2 {
            margin-bottom: 15px;
            font-size: 1.4em;
        }
        .theme-day #info-panel h2 { color: #0066cc; }
        .theme-night #info-panel h2 { color: #00d4ff; }
        .theme-retro #info-panel h2 { color: #00ff00; text-shadow: 0 0 10px #00ff00; }

        .stat {
            margin: 8px 0;
            font-size: 0.95em;
        }
        .stat-label {
            opacity: 0.7;
        }
        .stat-value {
            font-weight: bold;
        }
        .theme-day .stat-value { color: #00aa44; }
        .theme-night .stat-value { color: #00ff88; }
        .theme-retro .stat-value { color: #00ff00; text-shadow: 0 0 5px #00ff00; }

        #selected-plane {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 20px;
            border-radius: 12px;
            min-width: 300px;
            display: none;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }
        .theme-day #selected-plane {
            background: rgba(255, 255, 255, 0.85);
            border: 1px solid rgba(255, 150, 0, 0.3);
        }
        .theme-night #selected-plane {
            background: rgba(0, 20, 40, 0.85);
            border: 1px solid rgba(255, 150, 0, 0.3);
        }
        .theme-retro #selected-plane {
            background: rgba(0, 20, 0, 0.9);
            border: 1px solid #00ff00;
        }
        #selected-plane h3 {
            margin-bottom: 15px;
        }
        .theme-day #selected-plane h3 { color: #cc6600; }
        .theme-night #selected-plane h3 { color: #ffaa00; }
        .theme-retro #selected-plane h3 { color: #00ff00; }

        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 15px 25px;
            border-radius: 30px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(10px);
            max-width: 95vw;
            transition: all 0.3s ease;
        }
        .theme-day #controls {
            background: rgba(255, 255, 255, 0.85);
        }
        .theme-night #controls {
            background: rgba(0, 20, 40, 0.85);
        }
        .theme-retro #controls {
            background: rgba(0, 20, 0, 0.9);
            border: 1px solid #00ff00;
        }

        button {
            border: none;
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.85em;
            transition: all 0.3s ease;
        }
        .theme-day button {
            background: linear-gradient(135deg, #0088ff, #0066cc);
            color: #fff;
        }
        .theme-night button {
            background: linear-gradient(135deg, #0066cc, #0044aa);
            color: #fff;
        }
        .theme-retro button {
            background: transparent;
            color: #00ff00;
            border: 1px solid #00ff00;
        }
        button:hover {
            transform: scale(1.05);
        }
        .theme-retro button:hover {
            background: rgba(0, 255, 0, 0.2);
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
        }
        button.active {
            background: #00aa00 !important;
        }
        .theme-retro button.active {
            background: rgba(0, 255, 0, 0.3) !important;
        }

        .control-group {
            display: flex;
            gap: 5px;
            align-items: center;
            padding: 0 10px;
            border-right: 1px solid rgba(128, 128, 128, 0.3);
        }
        .control-group:last-child {
            border-right: none;
        }
        .control-label {
            font-size: 0.75em;
            opacity: 0.7;
            margin-right: 5px;
        }

        /* Trail controls - inline in controls */
        .trail-control {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .trail-control input[type="range"] {
            width: 60px;
            height: 6px;
            cursor: pointer;
        }
        #trail-length-value {
            font-size: 0.75em;
            min-width: 25px;
        }

        /* Altitude slider - inline in controls */
        .altitude-control {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        #altitude-slider {
            width: 80px;
            height: 6px;
            cursor: pointer;
        }
        #altitude-value {
            font-weight: bold;
            font-size: 0.8em;
            min-width: 35px;
        }

        /* Graphs Panel Styles */
        #graphs-panel {
            position: absolute;
            right: 20px;
            top: 20px;
            width: 320px;
            max-height: calc(100vh - 120px);
            overflow-y: auto;
            padding: 15px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            display: none;
        }
        #graphs-panel.visible {
            display: block;
        }
        .theme-day #graphs-panel {
            background: rgba(255, 255, 255, 0.92);
            border: 1px solid rgba(0, 100, 200, 0.3);
        }
        .theme-night #graphs-panel {
            background: rgba(0, 20, 40, 0.92);
            border: 1px solid rgba(0, 150, 255, 0.3);
        }
        .theme-retro #graphs-panel {
            background: rgba(0, 20, 0, 0.95);
            border: 1px solid #00ff00;
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.3);
        }

        #graphs-panel h3 {
            margin-bottom: 12px;
            font-size: 1.1em;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .theme-day #graphs-panel h3 { color: #0066cc; }
        .theme-night #graphs-panel h3 { color: #00d4ff; }
        .theme-retro #graphs-panel h3 { color: #00ff00; text-shadow: 0 0 10px #00ff00; }

        .time-period-selector {
            display: flex;
            gap: 4px;
            margin-bottom: 12px;
            flex-wrap: wrap;
        }
        .time-period-btn {
            flex: 1;
            min-width: 45px;
            padding: 6px 8px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8em;
            font-weight: 500;
            transition: all 0.2s ease;
        }
        .theme-day .time-period-btn {
            background: rgba(0, 100, 200, 0.15);
            color: #0066cc;
        }
        .theme-day .time-period-btn:hover {
            background: rgba(0, 100, 200, 0.25);
        }
        .theme-day .time-period-btn.active {
            background: #0088ff;
            color: #fff;
        }
        .theme-night .time-period-btn {
            background: rgba(0, 150, 255, 0.2);
            color: #00d4ff;
        }
        .theme-night .time-period-btn:hover {
            background: rgba(0, 150, 255, 0.35);
        }
        .theme-night .time-period-btn.active {
            background: #0088ff;
            color: #fff;
        }
        .theme-retro .time-period-btn {
            background: rgba(0, 255, 0, 0.1);
            color: #00ff00;
            border: 1px solid rgba(0, 255, 0, 0.3);
        }
        .theme-retro .time-period-btn:hover {
            background: rgba(0, 255, 0, 0.2);
            box-shadow: 0 0 5px rgba(0, 255, 0, 0.3);
        }
        .theme-retro .time-period-btn.active {
            background: rgba(0, 255, 0, 0.3);
            border-color: #00ff00;
            box-shadow: 0 0 8px rgba(0, 255, 0, 0.5);
        }

        .graphs1090-status {
            font-size: 0.7em;
            padding: 2px 8px;
            border-radius: 10px;
            font-weight: normal;
        }
        .graphs1090-status.connected {
            background: rgba(0, 200, 100, 0.3);
            color: #00cc66;
        }
        .graphs1090-status.local {
            background: rgba(255, 150, 0, 0.3);
            color: #ffaa00;
        }

        .graph-card {
            margin-bottom: 12px;
            padding: 10px;
            border-radius: 8px;
            transition: all 0.3s ease;
        }
        .theme-day .graph-card {
            background: rgba(0, 100, 200, 0.1);
        }
        .theme-night .graph-card {
            background: rgba(0, 100, 200, 0.2);
        }
        .theme-retro .graph-card {
            background: rgba(0, 255, 0, 0.1);
            border: 1px solid rgba(0, 255, 0, 0.3);
        }

        .graph-card h4 {
            font-size: 0.85em;
            margin-bottom: 8px;
            opacity: 0.9;
        }

        .graph-current-value {
            font-size: 1.5em;
            font-weight: bold;
            margin-bottom: 8px;
        }
        .theme-day .graph-current-value { color: #0088ff; }
        .theme-night .graph-current-value { color: #00d4ff; }
        .theme-retro .graph-current-value { color: #00ff00; text-shadow: 0 0 8px #00ff00; }

        .graph-canvas-container {
            width: 100%;
            height: 60px;
            border-radius: 4px;
            overflow: hidden;
        }
        .theme-day .graph-canvas-container {
            background: rgba(0, 0, 0, 0.05);
        }
        .theme-night .graph-canvas-container {
            background: rgba(0, 0, 0, 0.3);
        }
        .theme-retro .graph-canvas-container {
            background: rgba(0, 50, 0, 0.5);
        }

        .graph-canvas {
            width: 100%;
            height: 100%;
        }

        .graph-stats {
            display: flex;
            justify-content: space-between;
            font-size: 0.75em;
            margin-top: 6px;
            opacity: 0.7;
        }

        #graphs-panel::-webkit-scrollbar {
            width: 6px;
        }
        #graphs-panel::-webkit-scrollbar-track {
            background: transparent;
        }
        .theme-day #graphs-panel::-webkit-scrollbar-thumb {
            background: rgba(0, 100, 200, 0.3);
            border-radius: 3px;
        }
        .theme-night #graphs-panel::-webkit-scrollbar-thumb {
            background: rgba(0, 150, 255, 0.3);
            border-radius: 3px;
        }
        .theme-retro #graphs-panel::-webkit-scrollbar-thumb {
            background: rgba(0, 255, 0, 0.3);
            border-radius: 3px;
        }

        select {
            padding: 6px 10px;
            border-radius: 15px;
            cursor: pointer;
            font-size: 0.85em;
        }
        .theme-day select {
            background: #fff;
            border: 1px solid #ccc;
            color: #333;
        }
        .theme-night select {
            background: #1a3a5a;
            border: 1px solid #0066cc;
            color: #fff;
        }
        .theme-retro select {
            background: #001a00;
            border: 1px solid #00ff00;
            color: #00ff00;
        }

        /* Keyboard Shortcuts Help Overlay */
        #keyboard-help {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 10000;
        }
        #keyboard-help.visible {
            display: flex;
        }
        #keyboard-help-content {
            background: rgba(20, 40, 60, 0.95);
            border-radius: 16px;
            padding: 30px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            border: 1px solid rgba(0, 150, 255, 0.3);
        }
        .theme-retro #keyboard-help-content {
            background: rgba(0, 20, 0, 0.95);
            border-color: #00ff00;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
        }
        #keyboard-help h2 {
            margin-bottom: 20px;
            color: #00d4ff;
            text-align: center;
        }
        .theme-retro #keyboard-help h2 {
            color: #00ff00;
            text-shadow: 0 0 10px #00ff00;
        }
        .shortcut-group {
            margin-bottom: 20px;
        }
        .shortcut-group h3 {
            color: #88ccff;
            margin-bottom: 10px;
            font-size: 0.95em;
            border-bottom: 1px solid rgba(100, 150, 200, 0.3);
            padding-bottom: 5px;
        }
        .theme-retro .shortcut-group h3 {
            color: #00cc00;
            border-color: rgba(0, 255, 0, 0.3);
        }
        .shortcut-row {
            display: flex;
            justify-content: space-between;
            padding: 6px 0;
            font-size: 0.9em;
        }
        .shortcut-key {
            background: rgba(0, 100, 200, 0.3);
            padding: 3px 10px;
            border-radius: 4px;
            font-family: monospace;
            font-weight: bold;
            min-width: 60px;
            text-align: center;
        }
        .theme-retro .shortcut-key {
            background: rgba(0, 255, 0, 0.2);
            color: #00ff00;
        }
        .shortcut-desc {
            color: #ccc;
        }
        .theme-retro .shortcut-desc {
            color: #00cc00;
        }
        #keyboard-help .close-hint {
            text-align: center;
            margin-top: 20px;
            opacity: 0.6;
            font-size: 0.85em;
        }

        /* Enhanced Stats - integrated into info panel */
        #stats-section {
            display: none;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(128, 128, 128, 0.3);
        }
        #stats-section.visible {
            display: block;
        }
        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }
        .stats-item {
            padding: 10px;
            border-radius: 8px;
            text-align: center;
        }
        .theme-day .stats-item { background: rgba(0, 100, 200, 0.1); }
        .theme-night .stats-item { background: rgba(0, 100, 200, 0.2); }
        .theme-retro .stats-item { background: rgba(0, 255, 0, 0.1); border: 1px solid rgba(0, 255, 0, 0.3); }
        .stats-item .value {
            font-size: 1.4em;
            font-weight: bold;
            display: block;
        }
        .theme-day .stats-item .value { color: #0088ff; }
        .theme-night .stats-item .value { color: #00d4ff; }
        .theme-retro .stats-item .value { color: #00ff00; text-shadow: 0 0 5px #00ff00; }
        .stats-item .label {
            font-size: 0.75em;
            opacity: 0.7;
        }
        .coverage-map {
            width: 100%;
            height: 120px;
            border-radius: 8px;
            margin-bottom: 15px;
        }
        .theme-day .coverage-map { background: rgba(0, 0, 0, 0.05); }
        .theme-night .coverage-map { background: rgba(0, 0, 0, 0.3); }
        .theme-retro .coverage-map { background: rgba(0, 50, 0, 0.5); border: 1px solid rgba(0, 255, 0, 0.3); }
        .altitude-distribution {
            margin-top: 10px;
        }
        .altitude-bar {
            display: flex;
            align-items: center;
            margin: 4px 0;
            font-size: 0.75em;
        }
        .altitude-bar .label {
            width: 60px;
            text-align: right;
            margin-right: 8px;
        }
        .altitude-bar .bar {
            flex: 1;
            height: 12px;
            border-radius: 3px;
            position: relative;
        }
        .theme-day .altitude-bar .bar { background: rgba(0, 100, 200, 0.2); }
        .theme-night .altitude-bar .bar { background: rgba(0, 100, 200, 0.3); }
        .theme-retro .altitude-bar .bar { background: rgba(0, 255, 0, 0.15); }
        .altitude-bar .fill {
            height: 100%;
            border-radius: 3px;
            transition: width 0.3s ease;
        }
        .altitude-bar .count {
            width: 30px;
            text-align: right;
            margin-left: 8px;
            font-weight: bold;
        }

        /* Aircraft Info Enrichment Panel */
        #aircraft-enriched-info {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(128, 128, 128, 0.3);
            display: none;
        }
        #aircraft-enriched-info.visible {
            display: block;
        }
        .enriched-row {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
            font-size: 0.85em;
        }
        .enriched-label {
            opacity: 0.7;
        }
        .enriched-value {
            font-weight: 500;
        }
        #aircraft-photo {
            width: 100%;
            max-height: 120px;
            object-fit: cover;
            border-radius: 8px;
            margin-top: 10px;
            display: none;
        }
        .enriched-loading {
            text-align: center;
            padding: 10px;
            opacity: 0.6;
            font-size: 0.85em;
        }
        .external-links {
            margin-top: 10px;
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        .external-link {
            font-size: 0.75em;
            padding: 4px 8px;
            border-radius: 4px;
            text-decoration: none;
            transition: all 0.2s;
        }
        .theme-day .external-link {
            background: rgba(0, 100, 200, 0.15);
            color: #0066cc;
        }
        .theme-night .external-link {
            background: rgba(0, 150, 255, 0.2);
            color: #00d4ff;
        }
        .theme-retro .external-link {
            background: rgba(0, 255, 0, 0.15);
            color: #00ff00;
            border: 1px solid rgba(0, 255, 0, 0.3);
        }
        .external-link:hover {
            transform: scale(1.05);
        }

        /* Mobile Touch Optimization */
        @media (max-width: 768px) {
            #controls {
                padding: 10px 15px;
                gap: 6px;
                bottom: 10px;
            }
            .control-group {
                padding: 0 6px;
            }
            button {
                padding: 10px 14px;
                font-size: 0.9em;
                min-height: 44px;
            }
            select {
                padding: 10px 12px;
                font-size: 0.9em;
                min-height: 44px;
            }
            #info-panel {
                top: 10px;
                left: 10px;
                padding: 12px;
                min-width: 200px;
                font-size: 0.9em;
            }
            #selected-plane {
                top: 10px;
                right: 10px;
                padding: 12px;
                min-width: 220px;
                max-width: 45vw;
            }
            #graphs-panel {
                right: 10px;
                width: 280px;
                max-height: calc(100vh - 100px);
            }
            #altitude-slider {
                width: 60px;
            }
            .control-label {
                display: none;
            }
        }

        @media (max-width: 480px) {
            #controls {
                flex-direction: row;
                flex-wrap: wrap;
                justify-content: center;
            }
            .control-group {
                border-right: none;
                border-bottom: 1px solid rgba(128, 128, 128, 0.2);
                padding: 5px;
                width: 100%;
                justify-content: center;
            }
            .control-group:last-child {
                border-bottom: none;
            }
            #info-panel h2 {
                font-size: 1.1em;
            }
            #selected-plane {
                max-width: 60vw;
            }
        }

        /* Touch feedback */
        @media (hover: none) and (pointer: coarse) {
            button:active, select:active {
                transform: scale(0.95);
                opacity: 0.8;
            }
        }
    </style>
</head>
<body class="theme-retro">
    <div id="container"></div>

    <div id="info-panel">
        <h2>3D Flight Tracker</h2>
        <div class="stat">
            <span class="stat-label">Aircraft Tracked:</span>
            <span class="stat-value" id="plane-count">0</span>
        </div>
        <div class="stat">
            <span class="stat-label">Last Update:</span>
            <span class="stat-value" id="last-update">--:--:--</span>
        </div>
        <div class="stat">
            <span class="stat-label">Center:</span>
            <span class="stat-value" id="center-coords">--</span>
        </div>
        <div class="stat">
            <span class="stat-label">Map Zoom:</span>
            <span class="stat-value" id="map-zoom">9</span>
        </div>
        <!-- Expandable Stats Section -->
        <div id="stats-section">
            <div class="stats-grid">
                <div class="stats-item">
                    <span class="value" id="stats-total-tracked">0</span>
                    <span class="label">Unique (24h)</span>
                </div>
                <div class="stats-item">
                    <span class="value" id="stats-max-concurrent">0</span>
                    <span class="label">Max Concurrent</span>
                </div>
                <div class="stats-item">
                    <span class="value" id="stats-avg-altitude">0</span>
                    <span class="label">Avg Altitude</span>
                </div>
                <div class="stats-item">
                    <span class="value" id="stats-data-quality">--%</span>
                    <span class="label">Data Quality</span>
                </div>
            </div>
            <h4 style="margin-bottom: 8px; font-size: 0.8em; opacity: 0.8;">Coverage Heatmap</h4>
            <canvas class="coverage-map" id="coverage-canvas"></canvas>
            <h4 style="margin-bottom: 8px; font-size: 0.8em; opacity: 0.8;">Altitude Distribution</h4>
            <div class="altitude-distribution" id="altitude-distribution">
                <div class="altitude-bar">
                    <span class="label">&lt;5k ft</span>
                    <div class="bar"><div class="fill" id="alt-bar-0" style="width: 0%; background: #00ff00;"></div></div>
                    <span class="count" id="alt-count-0">0</span>
                </div>
                <div class="altitude-bar">
                    <span class="label">5-15k ft</span>
                    <div class="bar"><div class="fill" id="alt-bar-1" style="width: 0%; background: #88ff00;"></div></div>
                    <span class="count" id="alt-count-1">0</span>
                </div>
                <div class="altitude-bar">
                    <span class="label">15-30k ft</span>
                    <div class="bar"><div class="fill" id="alt-bar-2" style="width: 0%; background: #ffff00;"></div></div>
                    <span class="count" id="alt-count-2">0</span>
                </div>
                <div class="altitude-bar">
                    <span class="label">30-40k ft</span>
                    <div class="bar"><div class="fill" id="alt-bar-3" style="width: 0%; background: #ff8800;"></div></div>
                    <span class="count" id="alt-count-3">0</span>
                </div>
                <div class="altitude-bar">
                    <span class="label">&gt;40k ft</span>
                    <div class="bar"><div class="fill" id="alt-bar-4" style="width: 0%; background: #ff0088;"></div></div>
                    <span class="count" id="alt-count-4">0</span>
                </div>
            </div>
            <h4 style="margin: 12px 0 8px 0; font-size: 0.8em; opacity: 0.8;">Top Airlines</h4>
            <div id="top-aircraft-types" style="font-size: 0.8em;"></div>
        </div>
    </div>

    <div id="selected-plane">
        <h3>Selected Aircraft</h3>
        <div class="stat">
            <span class="stat-label">Callsign:</span>
            <span class="stat-value" id="sel-callsign">--</span>
        </div>
        <div class="stat">
            <span class="stat-label">Altitude:</span>
            <span class="stat-value" id="sel-altitude">--</span>
        </div>
        <div class="stat">
            <span class="stat-label">Speed:</span>
            <span class="stat-value" id="sel-speed">--</span>
        </div>
        <div class="stat">
            <span class="stat-label">Track:</span>
            <span class="stat-value" id="sel-track">--</span>
        </div>
        <div class="stat">
            <span class="stat-label">Vert Rate:</span>
            <span class="stat-value" id="sel-vertrate">--</span>
        </div>
        <div class="stat">
            <span class="stat-label">Squawk:</span>
            <span class="stat-value" id="sel-squawk">--</span>
        </div>
        <div class="stat">
            <span class="stat-label">Position:</span>
            <span class="stat-value" id="sel-position">--</span>
        </div>
        <!-- Aircraft Enriched Information -->
        <div id="aircraft-enriched-info">
            <div class="enriched-loading" id="enriched-loading">Loading aircraft info...</div>
            <div id="enriched-data" style="display:none;">
                <div class="enriched-row">
                    <span class="enriched-label">Registration:</span>
                    <span class="enriched-value" id="sel-registration">--</span>
                </div>
                <div class="enriched-row">
                    <span class="enriched-label">Aircraft:</span>
                    <span class="enriched-value" id="sel-aircraft-type">--</span>
                </div>
                <div class="enriched-row">
                    <span class="enriched-label">Operator:</span>
                    <span class="enriched-value" id="sel-operator">--</span>
                </div>
                <div class="enriched-row">
                    <span class="enriched-label">Origin:</span>
                    <span class="enriched-value" id="sel-origin">--</span>
                </div>
                <div class="enriched-row">
                    <span class="enriched-label">Destination:</span>
                    <span class="enriched-value" id="sel-destination">--</span>
                </div>
                <img id="aircraft-photo" alt="Aircraft" />
                <div class="external-links">
                    <a class="external-link" id="link-flightaware" href="#" target="_blank">FlightAware</a>
                    <a class="external-link" id="link-fr24" href="#" target="_blank">FR24</a>
                    <a class="external-link" id="link-adsbx" href="#" target="_blank">ADSB-X</a>
                </div>
            </div>
        </div>
    </div>

    <div id="graphs-panel">
        <h3>ADS-B Statistics <span class="graphs1090-status local" id="graphs-status">Local DB</span></h3>

        <div class="time-period-selector">
            <button class="time-period-btn active" onclick="setGraphsTimePeriod(3600)" data-period="3600">1h</button>
            <button class="time-period-btn" onclick="setGraphsTimePeriod(7200)" data-period="7200">2h</button>
            <button class="time-period-btn" onclick="setGraphsTimePeriod(28800)" data-period="28800">8h</button>
            <button class="time-period-btn" onclick="setGraphsTimePeriod(86400)" data-period="86400">24h</button>
            <button class="time-period-btn" onclick="setGraphsTimePeriod(172800)" data-period="172800">48h</button>
        </div>

        <div class="graph-card" id="card-message-rate">
            <h4>Message Rate</h4>
            <div class="graph-current-value" id="msg-rate-value">-- msg/s</div>
            <div class="graph-canvas-container">
                <canvas class="graph-canvas" id="canvas-msg-rate"></canvas>
            </div>
            <div class="graph-stats">
                <span id="msg-rate-min">Min: --</span>
                <span id="msg-rate-max">Max: --</span>
            </div>
        </div>

        <div class="graph-card" id="card-aircraft">
            <h4>Aircraft Tracked</h4>
            <div class="graph-current-value" id="aircraft-value">--</div>
            <div class="graph-canvas-container">
                <canvas class="graph-canvas" id="canvas-aircraft"></canvas>
            </div>
            <div class="graph-stats">
                <span id="aircraft-min">Min: --</span>
                <span id="aircraft-max">Max: --</span>
            </div>
        </div>

        <div class="graph-card" id="card-signal">
            <h4>Signal Level</h4>
            <div class="graph-current-value" id="signal-value">-- dBFS</div>
            <div class="graph-canvas-container">
                <canvas class="graph-canvas" id="canvas-signal"></canvas>
            </div>
            <div class="graph-stats">
                <span id="signal-min">Min: --</span>
                <span id="signal-max">Max: --</span>
            </div>
        </div>
    </div>

    <div id="controls">
        <div class="control-group">
            <span class="control-label">Source:</span>
            <select id="data-mode-select" onchange="changeDataMode(this.value)">
                <option value="local">Local (dump1090)</option>
                <option value="global">Global (API)</option>
            </select>
            <span id="data-mode-indicator" class="data-mode-badge data-mode-local">LOCAL</span>
        </div>

        <div class="control-group">
            <span class="control-label">Theme:</span>
            <select id="theme-select" onchange="changeTheme(this.value)">
                <option value="day">Day</option>
                <option value="night">Night</option>
                <option value="retro" selected>Retro 80s</option>
            </select>
        </div>

        <div class="control-group">
            <span class="control-label">Units:</span>
            <select id="units-select" onchange="changeUnits(this.value)">
                <option value="imperial">Imperial (ft/kts)</option>
                <option value="metric">Metric (m/km/h)</option>
            </select>
        </div>

        <div class="control-group">
            <span class="control-label">Map:</span>
            <button onclick="mapZoomIn()">+</button>
            <button onclick="mapZoomOut()">-</button>
            <button onclick="panMap('up')">↑</button>
            <button onclick="panMap('down')">↓</button>
            <button onclick="panMap('left')">←</button>
            <button onclick="panMap('right')">→</button>
        </div>

        <div class="control-group">
            <span class="control-label">Camera:</span>
            <button onclick="cameraZoomIn()">Zoom+</button>
            <button onclick="cameraZoomOut()">Zoom-</button>
            <button onmousedown="startRotate('left')" onmouseup="stopRotate()" onmouseleave="stopRotate()">◄</button>
            <button onmousedown="startRotate('right')" onmouseup="stopRotate()" onmouseleave="stopRotate()">►</button>
        </div>

        <div class="control-group">
            <button onclick="resetCamera()">Reset</button>
            <button onclick="toggleAutoRotate()" id="btn-rotate">Auto Rotate</button>
            <button onclick="toggleLabels()" id="btn-labels">Labels</button>
            <button onclick="toggleGraphs()" id="btn-graphs">Graphs</button>
            <button onclick="toggleStats()" id="btn-stats">Stats</button>
            <button onclick="toggleTerrain()" id="btn-terrain" class="active">Terrain</button>
        </div>

        <div class="control-group trail-control">
            <button onclick="toggleTrails()" id="btn-trails">Trails</button>
            <span class="control-label">Length:</span>
            <input type="range" id="trail-length-slider" min="50" max="500" value="200" oninput="setTrailLength(this.value)">
            <span id="trail-length-value">200</span>
            <span class="control-label">Width:</span>
            <input type="range" id="trail-thickness-slider" min="1" max="5" value="2" oninput="setTrailThickness(this.value)">
            <button onclick="clearAllTrails()" title="Clear all trails">Clear</button>
        </div>

        <div class="control-group altitude-control">
            <span class="control-label">Alt:</span>
            <input type="range" id="altitude-slider" min="100" max="30000" value="100" step="100">
            <span id="altitude-value">1x</span>
        </div>

        <div class="control-group">
            <button onclick="toggleKeyboardHelp()" id="btn-help" title="Keyboard Shortcuts">?</button>
        </div>
    </div>

    <!-- Airport Search -->
    <div id="airport-search-panel">
        <input type="text" id="airport-search-input" placeholder="Search airports (name, IATA, ICAO)..." autocomplete="off">
        <div id="airport-results"></div>
    </div>

    <!-- Keyboard Help Overlay -->
    <div id="keyboard-help">
        <div id="keyboard-help-content">
            <h2>Keyboard Shortcuts</h2>
            <div class="shortcut-group">
                <h3>Navigation</h3>
                <div class="shortcut-row"><span class="shortcut-key">↑↓←→</span><span class="shortcut-desc">Pan map</span></div>
                <div class="shortcut-row"><span class="shortcut-key">+ / =</span><span class="shortcut-desc">Zoom camera in</span></div>
                <div class="shortcut-row"><span class="shortcut-key">- / _</span><span class="shortcut-desc">Zoom camera out</span></div>
                <div class="shortcut-row"><span class="shortcut-key">[ / ]</span><span class="shortcut-desc">Rotate camera left/right</span></div>
                <div class="shortcut-row"><span class="shortcut-key">R</span><span class="shortcut-desc">Reset camera view</span></div>
                <div class="shortcut-row"><span class="shortcut-key">M + / M -</span><span class="shortcut-desc">Map zoom in/out</span></div>
            </div>
            <div class="shortcut-group">
                <h3>Display</h3>
                <div class="shortcut-row"><span class="shortcut-key">L</span><span class="shortcut-desc">Toggle labels</span></div>
                <div class="shortcut-row"><span class="shortcut-key">G</span><span class="shortcut-desc">Toggle graphs</span></div>
                <div class="shortcut-row"><span class="shortcut-key">A</span><span class="shortcut-desc">Toggle auto-rotate</span></div>
                <div class="shortcut-row"><span class="shortcut-key">T</span><span class="shortcut-desc">Toggle trails</span></div>
                <div class="shortcut-row"><span class="shortcut-key">C</span><span class="shortcut-desc">Clear all trails</span></div>
                <div class="shortcut-row"><span class="shortcut-key">S</span><span class="shortcut-desc">Toggle stats panel</span></div>
                <div class="shortcut-row"><span class="shortcut-key">1 / 2 / 3</span><span class="shortcut-desc">Switch theme (Day/Night/Retro)</span></div>
            </div>
            <div class="shortcut-group">
                <h3>Selection</h3>
                <div class="shortcut-row"><span class="shortcut-key">Tab</span><span class="shortcut-desc">Select next aircraft</span></div>
                <div class="shortcut-row"><span class="shortcut-key">Shift+Tab</span><span class="shortcut-desc">Select previous aircraft</span></div>
                <div class="shortcut-row"><span class="shortcut-key">Escape</span><span class="shortcut-desc">Deselect / Close panels</span></div>
                <div class="shortcut-row"><span class="shortcut-key">F</span><span class="shortcut-desc">Follow selected aircraft</span></div>
            </div>
            <p class="close-hint">Press <strong>?</strong> or <strong>Escape</strong> to close</p>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Configuration
        const DATA_URL = '/dump1090/data/aircraft.json';
        const REFRESH_INTERVAL = 1000;
        const MAP_GROUND_SIZE = 800;
        const TILES_PER_SIDE = 10;
        // Altitude scale: 1x-300x range, reduced by 30x (new 300x = old 10x effect)
        const BASE_ALT_SCALE = 0.000000333;

        // ===========================================
        // DATA SOURCE ABSTRACTION
        // ===========================================
        const GLOBAL_REFRESH_INTERVAL = 5000; // 5 seconds for global APIs
        const GLOBAL_RADIUS = 250; // nautical miles

        const DataSource = {
            mode: 'local', // 'local' or 'global'
            currentProvider: 0,
            lastFetchTime: 0,
            providers: [
                {
                    name: 'airplanes.live',
                    url: (lat, lon, radius) => `https://api.airplanes.live/v2/point/${lat}/${lon}/${radius}`,
                    available: null
                },
                {
                    name: 'adsb.lol',
                    url: (lat, lon, radius) => `https://api.adsb.lol/v2/point/${lat}/${lon}/${radius}`,
                    available: null
                }
            ],

            normalize(data) {
                if (!data || !data.ac) return { aircraft: [] };
                return {
                    aircraft: data.ac.filter(ac => ac.lat && ac.lon).map(ac => ({
                        hex: ac.hex || '',
                        flight: (ac.flight || '').trim(),
                        lat: ac.lat,
                        lon: ac.lon,
                        altitude: ac.alt_baro === 'ground' ? 0 : (ac.alt_baro || ac.alt_geom || 0),
                        track: ac.track || 0,
                        gs: ac.gs || 0,
                        baro_rate: ac.baro_rate || ac.geom_rate || 0,
                        squawk: ac.squawk || '',
                        category: ac.category || '',
                        r: ac.r || '',
                        t: ac.t || ''
                    }))
                };
            },

            async fetchGlobal(lat, lon) {
                for (let attempt = 0; attempt < this.providers.length; attempt++) {
                    const idx = (this.currentProvider + attempt) % this.providers.length;
                    const provider = this.providers[idx];
                    try {
                        const response = await fetch(provider.url(lat, lon, GLOBAL_RADIUS));
                        if (response.ok) {
                            const data = await response.json();
                            this.currentProvider = idx;
                            provider.available = true;
                            return this.normalize(data);
                        }
                    } catch (e) {
                        provider.available = false;
                    }
                }
                return { aircraft: [] };
            },

            setMode(newMode) {
                if (this.mode === newMode) return;
                this.mode = newMode;
                // Clear existing aircraft when switching modes
                for (const [hex, plane] of airplanes.entries()) {
                    scene.remove(plane);
                    if (plane.userData.trail) scene.remove(plane.userData.trail);
                    if (plane.userData.altLine) scene.remove(plane.userData.altLine);
                }
                airplanes.clear();
                aircraftDataBuffer.clear();
                _airplanesArrayDirty = true;
                // Reset refresh interval
                if (window._dataFetchInterval) {
                    clearInterval(window._dataFetchInterval);
                }
                const interval = newMode === 'global' ? GLOBAL_REFRESH_INTERVAL : REFRESH_INTERVAL;
                // For global mode without center, set a default
                if (newMode === 'global' && !centerInitialized) {
                    centerLat = 40.7128;
                    centerLon = -74.0060;
                    centerInitialized = true;
                    document.getElementById('center-coords').textContent =
                        `${centerLat.toFixed(2)}, ${centerLon.toFixed(2)}`;
                    loadMapTiles();
                }
                fetchData();
                window._dataFetchInterval = setInterval(fetchData, interval);
                // Update UI indicator
                const indicator = document.getElementById('data-mode-indicator');
                if (indicator) {
                    indicator.textContent = newMode === 'global' ? 'GLOBAL' : 'LOCAL';
                    indicator.className = 'data-mode-badge data-mode-' + newMode;
                }
                saveSettings();
            }
        };

        // ===========================================
        // AIRPORT DATABASE & SEARCH
        // ===========================================
        const AIRPORTS_CSV_URL = 'https://davidmegginson.github.io/ourairports-data/airports.csv';
        const AIRPORT_LABEL_DISTANCE_LARGE = 500;  // Show large airports within this distance
        const AIRPORT_LABEL_DISTANCE_MEDIUM = 250; // Show medium airports within this distance
        const MAX_VISIBLE_AIRPORT_LABELS = 40;

        const AirportDB = {
            airports: [],
            byICAO: new Map(),
            byIATA: new Map(),
            loaded: false,
            loading: false,
            airportLabels: [],       // THREE.Sprite objects in scene
            airportLabelPool: [],    // Recycled sprite objects

            async load() {
                if (this.loaded || this.loading) return;
                this.loading = true;
                try {
                    const response = await fetch(AIRPORTS_CSV_URL);
                    const text = await response.text();
                    this.parseCSV(text);
                    this.loaded = true;
                    console.log(`Airport DB loaded: ${this.airports.length} airports`);
                    this.updateLabels();
                } catch (e) {
                    console.warn('Failed to load airport data:', e);
                } finally {
                    this.loading = false;
                }
            },

            parseCSV(text) {
                const lines = text.split('\n');
                const header = lines[0].split(',').map(h => h.replace(/"/g, '').trim());
                const idxType = header.indexOf('type');
                const idxName = header.indexOf('name');
                const idxLat = header.indexOf('latitude_deg');
                const idxLon = header.indexOf('longitude_deg');
                const idxElev = header.indexOf('elevation_ft');
                const idxMuni = header.indexOf('municipality');
                const idxICAO = header.indexOf('ident');
                const idxIATA = header.indexOf('iata_code');
                const idxCountry = header.indexOf('iso_country');

                for (let i = 1; i < lines.length; i++) {
                    const fields = this._parseCSVLine(lines[i]);
                    if (fields.length < header.length) continue;
                    const type = fields[idxType];
                    // Only keep large and medium airports
                    if (type !== 'large_airport' && type !== 'medium_airport') continue;
                    const lat = parseFloat(fields[idxLat]);
                    const lon = parseFloat(fields[idxLon]);
                    if (isNaN(lat) || isNaN(lon)) continue;

                    const airport = {
                        type: type,
                        name: fields[idxName],
                        lat: lat,
                        lon: lon,
                        elevation: parseInt(fields[idxElev]) || 0,
                        municipality: fields[idxMuni] || '',
                        icao: fields[idxICAO] || '',
                        iata: fields[idxIATA] || '',
                        country: fields[idxCountry] || ''
                    };

                    this.airports.push(airport);
                    if (airport.icao) this.byICAO.set(airport.icao.toUpperCase(), airport);
                    if (airport.iata) this.byIATA.set(airport.iata.toUpperCase(), airport);
                }
            },

            _parseCSVLine(line) {
                const fields = [];
                let current = '';
                let inQuotes = false;
                for (let i = 0; i < line.length; i++) {
                    const ch = line[i];
                    if (ch === '"') {
                        inQuotes = !inQuotes;
                    } else if (ch === ',' && !inQuotes) {
                        fields.push(current.trim());
                        current = '';
                    } else {
                        current += ch;
                    }
                }
                fields.push(current.trim());
                return fields;
            },

            search(query, limit = 20) {
                if (!this.loaded) return [];
                const q = query.toUpperCase().trim();
                if (!q) return [];

                const results = [];
                // Exact IATA/ICAO match first
                if (q.length <= 4) {
                    const exact = this.byIATA.get(q) || this.byICAO.get(q);
                    if (exact) results.push(exact);
                }
                // Fuzzy name/city search
                for (let i = 0; i < this.airports.length && results.length < limit; i++) {
                    const a = this.airports[i];
                    if (results.includes(a)) continue;
                    if (a.name.toUpperCase().includes(q) ||
                        a.municipality.toUpperCase().includes(q) ||
                        a.iata.toUpperCase().includes(q) ||
                        a.icao.toUpperCase().includes(q)) {
                        results.push(a);
                    }
                }
                return results;
            },

            nearby(lat, lon, limit = 20) {
                if (!this.loaded) return [];
                return this.airports
                    .map(a => {
                        const dlat = a.lat - lat;
                        const dlon = (a.lon - lon) * Math.cos(lat * Math.PI / 180);
                        return { ...a, dist: Math.sqrt(dlat * dlat + dlon * dlon) * 111.32 };
                    })
                    .sort((a, b) => a.dist - b.dist)
                    .slice(0, limit);
            },

            flyTo(airport) {
                if (!airport) return;
                // Determine zoom level based on airport type
                const targetZoom = airport.type === 'large_airport' ? 10 : 11;
                startMapTransition(airport.lat, airport.lon, targetZoom);
            },

            updateLabels() {
                if (!this.loaded || !scene || !window.mapBounds) return;

                const bounds = window.mapBounds;
                const camDist = cameraDistance || 150;

                // Find airports within current view bounds (with padding)
                const padLat = (bounds.north - bounds.south) * 0.1;
                const padLon = (bounds.east - bounds.west) * 0.1;

                const visible = [];
                for (let i = 0; i < this.airports.length; i++) {
                    const a = this.airports[i];
                    if (a.lat < bounds.south - padLat || a.lat > bounds.north + padLat) continue;
                    if (a.lon < bounds.west - padLon || a.lon > bounds.east + padLon) continue;

                    // Distance-based filtering
                    const maxDist = a.type === 'large_airport' ? AIRPORT_LABEL_DISTANCE_LARGE : AIRPORT_LABEL_DISTANCE_MEDIUM;
                    const pos = latLonToXZ(a.lat, a.lon);
                    const dx = pos.x - (camera ? camera.position.x : 0);
                    const dz = pos.z - (camera ? camera.position.z : 0);
                    const dist = Math.sqrt(dx * dx + dz * dz);
                    if (dist > maxDist) continue;

                    visible.push({ airport: a, pos: pos, dist: dist });
                }

                // Sort by size then distance, limit count
                visible.sort((a, b) => {
                    if (a.airport.type !== b.airport.type) {
                        return a.airport.type === 'large_airport' ? -1 : 1;
                    }
                    return a.dist - b.dist;
                });
                const toShow = visible.slice(0, MAX_VISIBLE_AIRPORT_LABELS);

                // Remove old labels
                for (let i = 0; i < this.airportLabels.length; i++) {
                    scene.remove(this.airportLabels[i]);
                    this.airportLabelPool.push(this.airportLabels[i]);
                }
                this.airportLabels = [];

                // Create/reuse labels for visible airports
                for (let i = 0; i < toShow.length; i++) {
                    const item = toShow[i];
                    const a = item.airport;
                    const label = this._getOrCreateLabel(a);
                    label.position.set(item.pos.x, 0.5, item.pos.z);

                    // Scale based on airport type and distance
                    const baseScale = a.type === 'large_airport' ? 18 : 12;
                    const distScale = Math.max(0.4, 1 - item.dist / 500);
                    label.scale.set(baseScale * distScale, baseScale * distScale * 0.3, 1);

                    scene.add(label);
                    this.airportLabels.push(label);
                }
                _needsRender = true;
            },

            _getOrCreateLabel(airport) {
                let sprite;
                if (this.airportLabelPool.length > 0) {
                    sprite = this.airportLabelPool.pop();
                } else {
                    const spriteMat = new THREE.SpriteMaterial({ depthTest: false, transparent: true });
                    sprite = new THREE.Sprite(spriteMat);
                }

                // Render label text to canvas
                const canvas = document.createElement('canvas');
                canvas.width = 512;
                canvas.height = 128;
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, 512, 128);

                const isRetro = currentTheme === 'retro';
                const isNight = currentTheme === 'night';
                const code = airport.iata || airport.icao;
                const city = airport.municipality || airport.name;

                // Background
                ctx.fillStyle = isRetro ? 'rgba(0,20,0,0.7)' : isNight ? 'rgba(0,15,30,0.7)' : 'rgba(255,255,255,0.7)';
                ctx.fillRect(0, 0, 512, 128);

                // Code text
                ctx.font = 'bold 48px monospace';
                ctx.fillStyle = isRetro ? '#00ff00' : isNight ? '#66bbff' : '#0066cc';
                ctx.textAlign = 'center';
                ctx.fillText(code, 256, 50);

                // City text
                ctx.font = '28px sans-serif';
                ctx.fillStyle = isRetro ? '#00cc00' : isNight ? '#88ccff' : '#444444';
                ctx.fillText(city.substring(0, 25), 256, 100);

                const texture = new THREE.CanvasTexture(canvas);
                sprite.material.map = texture;
                sprite.material.needsUpdate = true;
                sprite.renderOrder = 1;
                return sprite;
            }
        };

        // Airport search UI handlers
        function initAirportSearch() {
            const input = document.getElementById('airport-search-input');
            const results = document.getElementById('airport-results');
            if (!input || !results) return;

            let searchTimeout = null;

            input.addEventListener('input', () => {
                clearTimeout(searchTimeout);
                searchTimeout = setTimeout(() => {
                    const query = input.value.trim();
                    if (query.length < 2) {
                        results.style.display = 'none';
                        return;
                    }

                    let items;
                    if (query === '') {
                        items = AirportDB.nearby(centerLat, centerLon, 15);
                    } else {
                        items = AirportDB.search(query, 15);
                    }

                    if (items.length === 0) {
                        results.innerHTML = '<div class="airport-result-item" style="opacity:0.5">No airports found</div>';
                        results.style.display = 'block';
                        return;
                    }

                    results.innerHTML = items.map(a => {
                        const code = a.iata ? `${a.iata}/${a.icao}` : a.icao;
                        const distStr = a.dist !== undefined ? `${Math.round(a.dist)} km` : '';
                        return `<div class="airport-result-item" data-icao="${a.icao}" data-lat="${a.lat}" data-lon="${a.lon}" data-type="${a.type}">
                            <span class="airport-code">${code}</span>
                            ${a.municipality ? a.municipality + ' - ' : ''}${a.name}
                            ${distStr ? `<span class="airport-dist">${distStr}</span>` : ''}
                        </div>`;
                    }).join('');
                    results.style.display = 'block';
                }, 150);
            });

            input.addEventListener('focus', () => {
                if (input.value.trim().length >= 2) {
                    results.style.display = 'block';
                }
            });

            results.addEventListener('click', (e) => {
                const item = e.target.closest('.airport-result-item');
                if (!item) return;
                const lat = parseFloat(item.dataset.lat);
                const lon = parseFloat(item.dataset.lon);
                const type = item.dataset.type;
                if (isNaN(lat) || isNaN(lon)) return;
                AirportDB.flyTo({ lat, lon, type });
                input.value = '';
                results.style.display = 'none';
            });

            // Close results when clicking outside
            document.addEventListener('click', (e) => {
                if (!e.target.closest('#airport-search-panel')) {
                    results.style.display = 'none';
                }
            });

            // Show nearby airports when input is focused and empty
            input.addEventListener('focus', () => {
                if (input.value.trim() === '' && AirportDB.loaded) {
                    const nearby = AirportDB.nearby(centerLat, centerLon, 15);
                    if (nearby.length > 0) {
                        results.innerHTML = '<div style="padding:6px 14px;font-size:11px;opacity:0.5;font-weight:bold">NEARBY AIRPORTS</div>' +
                            nearby.map(a => {
                                const code = a.iata ? `${a.iata}/${a.icao}` : a.icao;
                                return `<div class="airport-result-item" data-icao="${a.icao}" data-lat="${a.lat}" data-lon="${a.lon}" data-type="${a.type}">
                                    <span class="airport-code">${code}</span>
                                    ${a.municipality ? a.municipality + ' - ' : ''}${a.name}
                                    <span class="airport-dist">${Math.round(a.dist)} km</span>
                                </div>`;
                            }).join('');
                        results.style.display = 'block';
                    }
                }
            });
        }

        // ===========================================
        // TERRAIN ELEVATION
        // ===========================================
        const TERRAIN_SEGMENTS = 32; // 32x32 grid per tile
        const TERRAIN_SCALE_FACTOR = 0.008; // Elevation to scene units multiplier
        const MAX_TERRAIN_TILES = 100;
        let terrainEnabled = true;
        let terrainTiles = [];  // Active terrain meshes in scene
        let terrainCache = new Map(); // cacheKey -> {mesh, elevations}
        let terrainLoading = new Set(); // Currently loading tile keys

        const TerrainSystem = {
            getSatelliteUrl(tileX, tileY, zoom) {
                // ArcGIS World Imagery - note y/x order
                return `https://services.arcgisonline.com/arcgis/rest/services/World_Imagery/MapServer/tile/${zoom}/${tileY}/${tileX}`;
            },

            getElevationUrl(tileX, tileY, zoom) {
                // AWS S3 Terrarium tiles (free, no auth)
                return `https://s3.amazonaws.com/elevation-tiles-prod/terrarium/${zoom}/${tileX}/${tileY}.png`;
            },

            async loadTerrainForTile(tileX, tileY, zoom, posX, posZ, tileSize) {
                const cacheKey = `terrain-${zoom}-${tileX}-${tileY}`;
                if (terrainCache.has(cacheKey)) {
                    const cached = terrainCache.get(cacheKey);
                    if (!cached.mesh.parent) {
                        cached.mesh.position.set(posX, 0, posZ);
                        scene.add(cached.mesh);
                    }
                    return cached;
                }
                if (terrainLoading.has(cacheKey)) return null;
                terrainLoading.add(cacheKey);

                try {
                    // Load elevation tile
                    const elevations = await this._loadElevationTile(tileX, tileY, zoom);
                    if (!elevations) {
                        terrainLoading.delete(cacheKey);
                        return null;
                    }

                    // Create terrain mesh with displaced vertices
                    const geometry = new THREE.PlaneGeometry(tileSize, tileSize, TERRAIN_SEGMENTS, TERRAIN_SEGMENTS);
                    const positions = geometry.attributes.position.array;

                    for (let iy = 0; iy <= TERRAIN_SEGMENTS; iy++) {
                        for (let ix = 0; ix <= TERRAIN_SEGMENTS; ix++) {
                            const vertIdx = (iy * (TERRAIN_SEGMENTS + 1) + ix) * 3;
                            const ex = Math.floor(ix / TERRAIN_SEGMENTS * 255);
                            const ey = Math.floor(iy / TERRAIN_SEGMENTS * 255);
                            const elevation = elevations[ey * 256 + ex];
                            // PlaneGeometry default is XY plane, Z is up
                            // We'll rotate it to XZ, so set Z for displacement
                            positions[vertIdx + 2] = Math.max(0, elevation) * TERRAIN_SCALE_FACTOR;
                        }
                    }
                    geometry.computeVertexNormals();

                    // Load satellite/map texture for terrain surface
                    const texture = await this._loadTerrainTexture(tileX, tileY, zoom);
                    const isRetro = currentTheme === 'retro';
                    const isNight = currentTheme === 'night';

                    let material;
                    if (texture) {
                        material = new THREE.MeshLambertMaterial({
                            map: texture,
                            side: THREE.DoubleSide
                        });
                        if (isNight) {
                            material.color.setHex(0x8888aa); // Dim satellite for night
                        }
                    } else {
                        material = new THREE.MeshLambertMaterial({
                            color: isRetro ? 0x003300 : isNight ? 0x1a2a3a : 0x4a8a4a,
                            wireframe: isRetro,
                            side: THREE.DoubleSide
                        });
                    }

                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.rotation.x = -Math.PI / 2;
                    mesh.position.set(posX, 0, posZ);
                    mesh.userData.terrainKey = cacheKey;
                    mesh.renderOrder = -1;

                    scene.add(mesh);

                    const entry = { mesh, elevations };
                    terrainCache.set(cacheKey, entry);
                    terrainTiles.push(mesh);
                    terrainLoading.delete(cacheKey);

                    // Enforce cache limit
                    if (terrainCache.size > MAX_TERRAIN_TILES) {
                        const keysToRemove = [];
                        let count = 0;
                        for (const k of terrainCache.keys()) {
                            if (count++ < 20) keysToRemove.push(k);
                            else break;
                        }
                        for (const k of keysToRemove) {
                            const old = terrainCache.get(k);
                            if (old && old.mesh) {
                                scene.remove(old.mesh);
                                old.mesh.geometry.dispose();
                                if (old.mesh.material.map) old.mesh.material.map.dispose();
                                old.mesh.material.dispose();
                            }
                            terrainCache.delete(k);
                        }
                    }

                    _needsRender = true;
                    return entry;
                } catch (e) {
                    terrainLoading.delete(cacheKey);
                    return null;
                }
            },

            _loadElevationTile(tileX, tileY, zoom) {
                return new Promise((resolve) => {
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    img.onload = () => {
                        try {
                            const canvas = document.createElement('canvas');
                            canvas.width = canvas.height = 256;
                            const ctx = canvas.getContext('2d');
                            ctx.drawImage(img, 0, 0);
                            const imageData = ctx.getImageData(0, 0, 256, 256);
                            const elevations = new Float32Array(256 * 256);
                            for (let i = 0; i < imageData.data.length; i += 4) {
                                const r = imageData.data[i];
                                const g = imageData.data[i + 1];
                                const b = imageData.data[i + 2];
                                elevations[i / 4] = (r * 256 + g + b / 256) - 32768;
                            }
                            resolve(elevations);
                        } catch (e) {
                            // CORS or canvas tainted error
                            resolve(null);
                        }
                    };
                    img.onerror = () => resolve(null);
                    img.src = this.getElevationUrl(tileX, tileY, zoom);
                });
            },

            _loadTerrainTexture(tileX, tileY, zoom) {
                return new Promise((resolve) => {
                    const isRetro = currentTheme === 'retro';
                    if (isRetro) {
                        // For retro theme, use the existing green-tinted map tiles
                        const url = getTileUrl(tileX, tileY, zoom);
                        const img = new Image();
                        img.crossOrigin = 'anonymous';
                        img.onload = () => {
                            const invertedCanvas = invertToGreen(img);
                            resolve(new THREE.CanvasTexture(invertedCanvas));
                        };
                        img.onerror = () => resolve(null);
                        img.src = url;
                    } else if (currentTheme === 'night') {
                        // Night: use CartoDB dark tiles
                        const url = getTileUrl(tileX, tileY, zoom);
                        const loader = new THREE.TextureLoader();
                        loader.crossOrigin = 'anonymous';
                        loader.load(url, (tex) => resolve(tex), undefined, () => resolve(null));
                    } else {
                        // Day: use ArcGIS satellite imagery
                        const url = this.getSatelliteUrl(tileX, tileY, zoom);
                        const loader = new THREE.TextureLoader();
                        loader.crossOrigin = 'anonymous';
                        loader.load(url, (tex) => resolve(tex), undefined, () => resolve(null));
                    }
                });
            },

            loadTerrainTiles() {
                if (!terrainEnabled || !centerInitialized) return;

                const centerTile = latLonToTile(centerLat, centerLon, currentZoom);
                const halfTiles = Math.floor(TILES_PER_SIDE / 2);
                const tileSize = MAP_GROUND_SIZE / TILES_PER_SIDE;

                // Remove terrain meshes not in current view
                const newTerrain = [];
                for (let i = 0; i < terrainTiles.length; i++) {
                    const mesh = terrainTiles[i];
                    // Check if tile is still in view by position
                    const dx = Math.abs(mesh.position.x);
                    const dz = Math.abs(mesh.position.z);
                    if (dx > MAP_GROUND_SIZE * 0.6 || dz > MAP_GROUND_SIZE * 0.6) {
                        scene.remove(mesh);
                    } else {
                        newTerrain.push(mesh);
                    }
                }
                terrainTiles = newTerrain;

                // Load terrain for visible tiles
                for (let dy = 0; dy < TILES_PER_SIDE; dy++) {
                    for (let dx = 0; dx < TILES_PER_SIDE; dx++) {
                        const tileX = centerTile.x - halfTiles + dx;
                        const tileY = centerTile.y - halfTiles + dy;
                        const posX = (dx - halfTiles + 0.5) * tileSize;
                        const posZ = (dy - halfTiles + 0.5) * tileSize;
                        this.loadTerrainForTile(tileX, tileY, currentZoom, posX, posZ, tileSize);
                    }
                }
            },

            getElevationAt(lat, lon) {
                // Get elevation at a specific lat/lon from cached terrain data
                if (!window.mapBounds) return 0;
                const bounds = window.mapBounds;
                const normX = (lon - bounds.west) / (bounds.east - bounds.west);
                const normY = (lat - bounds.north) / (bounds.south - bounds.north);
                if (normX < 0 || normX > 1 || normY < 0 || normY > 1) return 0;

                const centerTile = latLonToTile(centerLat, centerLon, currentZoom);
                const halfTiles = Math.floor(TILES_PER_SIDE / 2);
                const tileX = Math.floor(normX * TILES_PER_SIDE) + centerTile.x - halfTiles;
                const tileY = Math.floor(normY * TILES_PER_SIDE) + centerTile.y - halfTiles;
                const cacheKey = `terrain-${currentZoom}-${tileX}-${tileY}`;
                const cached = terrainCache.get(cacheKey);
                if (!cached || !cached.elevations) return 0;

                // Sample elevation
                const localX = (normX * TILES_PER_SIDE) % 1;
                const localY = (normY * TILES_PER_SIDE) % 1;
                const ex = Math.floor(localX * 255);
                const ey = Math.floor(localY * 255);
                return (cached.elevations[ey * 256 + ex] || 0) * TERRAIN_SCALE_FACTOR;
            }
        };

        // Cookie helper functions
        function setCookie(name, value, days = 365) {
            const expires = new Date(Date.now() + days * 864e5).toUTCString();
            document.cookie = name + '=' + encodeURIComponent(JSON.stringify(value)) + '; expires=' + expires + '; path=/; SameSite=Lax';
        }

        function getCookie(name) {
            const value = document.cookie.split('; ').find(row => row.startsWith(name + '='));
            if (value) {
                try {
                    return JSON.parse(decodeURIComponent(value.split('=')[1]));
                } catch (e) {
                    return null;
                }
            }
            return null;
        }

        function saveSettings() {
            const settings = {
                theme: currentTheme,
                units: currentUnits,
                showLabels: showLabels,
                trailEnabled: trailEnabled,
                trailMaxLength: trailMaxLength,
                trailThickness: trailThickness,
                trailColorMode: trailColorMode,
                autoRotate: autoRotate,
                showGraphs: showGraphs,
                graphsTimePeriod: graphsTimePeriod,
                altitudeScaleValue: Math.round(altitudeScale / BASE_ALT_SCALE),
                dataMode: DataSource.mode,
                terrainEnabled: terrainEnabled
            };
            setCookie('flightTrackerSettings', settings);
        }

        function loadSettings() {
            const settings = getCookie('flightTrackerSettings');
            if (settings) {
                if (settings.theme) currentTheme = settings.theme;
                if (settings.units) currentUnits = settings.units;
                if (settings.showLabels !== undefined) showLabels = settings.showLabels;
                if (settings.trailEnabled !== undefined) trailEnabled = settings.trailEnabled;
                if (settings.trailMaxLength !== undefined) trailMaxLength = settings.trailMaxLength;
                if (settings.trailThickness !== undefined) trailThickness = settings.trailThickness;
                if (settings.trailColorMode !== undefined) trailColorMode = settings.trailColorMode;
                if (settings.autoRotate !== undefined) autoRotate = settings.autoRotate;
                if (settings.showGraphs !== undefined) showGraphs = settings.showGraphs;
                if (settings.graphsTimePeriod !== undefined) graphsTimePeriod = settings.graphsTimePeriod;
                if (settings.altitudeScaleValue !== undefined) {
                    // Internal scale: 100-30000 (displayed as 1x-300x)
                    let newScale = settings.altitudeScaleValue;
                    // Clamp to valid range
                    newScale = Math.max(100, Math.min(30000, newScale));
                    altitudeScale = newScale * BASE_ALT_SCALE;
                }
                if (settings.dataMode) DataSource.mode = settings.dataMode;
                if (settings.terrainEnabled !== undefined) terrainEnabled = settings.terrainEnabled;
            }
        }

        // State
        let scene, camera, renderer;
        let airplanes = new Map();
        let labels = [];
        let showLabels = true;
        let autoRotate = false;
        let selectedPlane = null;
        let centerLat = 0, centerLon = 0;
        let centerInitialized = false;

        // Trail settings (airloom-style)
        let trailEnabled = true;
        let trailMaxLength = 200; // Max trail points
        let trailThickness = 2; // Line thickness (1-5)
        let trailColorMode = 'altitude'; // 'altitude' or 'speed'

        // Interpolation state
        const INTERPOLATION_DELAY = 2000; // 2 second delay
        const INTERPOLATION_FPS = 30;
        let aircraftDataBuffer = new Map(); // hex -> array of {timestamp, data}
        let lastInterpolationTime = 0;

        // Performance: Cached/reusable objects to avoid GC pressure
        const _raycaster = new THREE.Raycaster();
        const _mouseVec = new THREE.Vector2();
        const _tempPos = { x: 0, z: 0 };
        const _seenHexes = new Set();
        let _airplanesArray = []; // Cached array of airplane entries for iteration
        let _airplanesArrayDirty = true; // Flag to rebuild array when airplanes change

        // Performance: Label canvas pool for reuse
        const _labelCanvasPool = [];
        const _labelTexturePool = [];
        const MAX_LABEL_POOL_SIZE = 100;

        // Performance: Shared geometry instances (created once, reused for all aircraft)
        let _sharedGeometries = null;

        // Glow effect texture and material (sprite-based glow like airloom)
        let _glowTexture = null;
        let _glowMaterialRetro = null;
        let _glowMaterialDay = null;

        // Performance: Material pools
        const _materialPool = {
            wireframe: [],
            phong: [],
            basic: []
        };
        const MAX_MATERIAL_POOL_SIZE = 50;

        // Performance: Trail geometry pool
        const _trailGeometryPool = [];
        const MAX_TRAIL_POOL_SIZE = 50;

        // Performance: Distance-based LOD thresholds
        const LOD_DISTANCE_FAR = 400; // Distance for simplified rendering
        const LOD_DISTANCE_CULL = 700; // Distance for label culling

        // Performance: Batch update flags
        let _trailUpdateQueue = [];
        let _lastBatchTrailUpdate = 0;
        const BATCH_TRAIL_INTERVAL = 50; // Batch trail updates every 50ms

        // Performance: Throttle flags
        let _lastTrailFilterTime = 0;
        const TRAIL_FILTER_INTERVAL = 500; // Filter trails every 500ms max

        // Performance: Tab visibility for power saving
        let _isTabVisible = true;

        // Performance: Render on demand flag
        let _needsRender = true;
        let _renderThrottleTime = 0;
        const RENDER_THROTTLE_MS = 16; // Cap at ~60fps

        // Map state
        let currentZoom = 9;
        const MIN_ZOOM = 6;
        const MAX_ZOOM = 12;
        let mapTiles = [];
        let tileCache = new Map();
        const MAX_TILE_CACHE_SIZE = 300; // Limit texture cache memory (increased for larger map)

        // Smooth map transition state
        let mapTransition = {
            active: false,
            startLat: 0,
            startLon: 0,
            targetLat: 0,
            targetLon: 0,
            startZoom: 9,
            targetZoom: 9,
            startTime: 0,
            duration: 300, // ms
            easing: (t) => t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2 // easeInOutCubic
        };

        // Tile preloading state
        let preloadedTiles = new Map(); // cache key -> {texture, loading}
        let preloadQueue = [];
        let preloadInProgress = 0;
        const MAX_CONCURRENT_PRELOADS = 4;

        // Altitude scale
        let altitudeScale = 30 * BASE_ALT_SCALE;

        // Units: 'imperial' or 'metric'
        let currentUnits = 'imperial';

        // Theme: 'day', 'night', 'retro'
        let currentTheme = 'retro';

        // Graphs panel state
        let showGraphs = false;
        let graphs1090Available = false;
        let statsDb = null;
        let graphsTimePeriod = 3600; // Default 1 hour in seconds
        let statsHistory = {
            messageRate: [],
            aircraftCount: [],
            signalLevel: []
        };
        const STATS_HISTORY_MAX = 172800; // 48 hours at 1s intervals
        const STATS_URL = '/dump1090/data/stats.json';
        const GRAPHS1090_CHECK_URL = '/graphs1090/';

        // Camera controls
        let cameraAngle = 0;
        let cameraHeight = 80;
        let cameraDistance = 150;
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };

        // Follow mode
        let followSelectedPlane = false;

        // Stats panel state (integrated in info-panel)
        let showStats = false;
        let uniqueAircraftSeen = new Set();
        let maxConcurrentAircraft = 0;
        let coverageHeatmap = new Array(20 * 20).fill(0); // 20x20 grid
        let aircraftTypeStats = new Map();

        // Aircraft information cache
        let aircraftInfoCache = new Map();
        let enrichmentApiAvailable = null; // null = unknown, true/false after check

        // Touch gesture state
        let touchStartDistance = 0;
        let touchStartAngle = 0;
        let lastTouchCenter = { x: 0, y: 0 };
        let isTwoFingerGesture = false;

        // ===========================================
        // GRAPHS1090 INTEGRATION & LOCAL STATS
        // ===========================================

        // Initialize IndexedDB for stats storage
        function initStatsDatabase() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open('FlightTrackerStats', 2);

                request.onerror = () => {
                    console.warn('IndexedDB not available, using memory only');
                    resolve(null);
                };

                request.onupgradeneeded = (event) => {
                    const db = event.target.result;

                    // Create object stores for each metric
                    if (!db.objectStoreNames.contains('messageRate')) {
                        const msgStore = db.createObjectStore('messageRate', { keyPath: 'timestamp' });
                        msgStore.createIndex('timestamp', 'timestamp', { unique: true });
                    }
                    if (!db.objectStoreNames.contains('aircraft')) {
                        const acStore = db.createObjectStore('aircraft', { keyPath: 'timestamp' });
                        acStore.createIndex('timestamp', 'timestamp', { unique: true });
                    }
                    if (!db.objectStoreNames.contains('signal')) {
                        const sigStore = db.createObjectStore('signal', { keyPath: 'timestamp' });
                        sigStore.createIndex('timestamp', 'timestamp', { unique: true });
                    }
                    // Trail history store - keyed by aircraft hex
                    if (!db.objectStoreNames.contains('trails')) {
                        const trailStore = db.createObjectStore('trails', { keyPath: 'hex' });
                        trailStore.createIndex('lastSeen', 'lastSeen', { unique: false });
                    }
                };

                request.onsuccess = (event) => {
                    statsDb = event.target.result;
                    loadStatsFromDb();
                    resolve(statsDb);
                };
            });
        }

        // Load historical stats from IndexedDB
        function loadStatsFromDb() {
            if (!statsDb) return;

            const now = Date.now();
            const cutoff = now - (STATS_HISTORY_MAX * 1000);

            ['messageRate', 'aircraft', 'signal'].forEach(storeName => {
                const transaction = statsDb.transaction([storeName], 'readonly');
                const store = transaction.objectStore(storeName);
                const request = store.openCursor();

                request.onsuccess = (event) => {
                    const cursor = event.target.result;
                    if (cursor) {
                        if (cursor.value.timestamp >= cutoff) {
                            if (storeName === 'messageRate') {
                                statsHistory.messageRate.push(cursor.value);
                            } else if (storeName === 'aircraft') {
                                statsHistory.aircraftCount.push({ timestamp: cursor.value.timestamp, value: cursor.value.count || cursor.value.tracked || 0 });
                            } else if (storeName === 'signal') {
                                statsHistory.signalLevel.push(cursor.value);
                            }
                        }
                        cursor.continue();
                    }
                };
            });
        }

        // Save stats to IndexedDB
        function saveStatsToDb(type, data) {
            if (!statsDb) return;

            const transaction = statsDb.transaction([type], 'readwrite');
            const store = transaction.objectStore(type);
            store.put(data);

            // Clean up old entries (keep last 24 hours)
            const cutoff = Date.now() - (24 * 60 * 60 * 1000);
            const deleteRequest = store.openCursor();
            deleteRequest.onsuccess = (event) => {
                const cursor = event.target.result;
                if (cursor) {
                    if (cursor.value.timestamp < cutoff) {
                        cursor.delete();
                    }
                    cursor.continue();
                }
            };
        }

        // Save trail history to IndexedDB
        function saveTrailToDb(hex, trailPoints, lat, lon) {
            if (!statsDb || !hex || trailPoints.length < 2) return;

            try {
                const transaction = statsDb.transaction(['trails'], 'readwrite');
                const store = transaction.objectStore('trails');
                store.put({
                    hex: hex,
                    points: trailPoints.slice(-100), // Keep last 100 points
                    lastSeen: Date.now(),
                    lastLat: lat,
                    lastLon: lon
                });
            } catch (e) {
                // Ignore DB errors
            }
        }

        // Load trail history from IndexedDB
        function loadTrailFromDb(hex, callback) {
            if (!statsDb || !hex) {
                callback(null);
                return;
            }

            try {
                const transaction = statsDb.transaction(['trails'], 'readonly');
                const store = transaction.objectStore('trails');
                const request = store.get(hex);

                request.onsuccess = (event) => {
                    const result = event.target.result;
                    // Only use trail if seen within last hour
                    if (result && (Date.now() - result.lastSeen) < 3600000) {
                        callback(result);
                    } else {
                        callback(null);
                    }
                };

                request.onerror = () => callback(null);
            } catch (e) {
                callback(null);
            }
        }

        // Clean up old trails from IndexedDB
        function cleanupOldTrails() {
            if (!statsDb) return;

            try {
                const cutoff = Date.now() - (24 * 60 * 60 * 1000); // 24 hours
                const transaction = statsDb.transaction(['trails'], 'readwrite');
                const store = transaction.objectStore('trails');
                const index = store.index('lastSeen');
                const range = IDBKeyRange.upperBound(cutoff);

                index.openCursor(range).onsuccess = (event) => {
                    const cursor = event.target.result;
                    if (cursor) {
                        cursor.delete();
                        cursor.continue();
                    }
                };
            } catch (e) {
                // Ignore errors
            }
        }

        // Check if graphs1090 is available
        async function checkGraphs1090() {
            try {
                const response = await fetch(GRAPHS1090_CHECK_URL, { method: 'HEAD', cache: 'no-store' });
                if (response.ok) {
                    graphs1090Available = true;
                    document.getElementById('graphs-status').textContent = 'graphs1090';
                    document.getElementById('graphs-status').classList.remove('local');
                    document.getElementById('graphs-status').classList.add('connected');
                    console.log('graphs1090 detected, using its database');
                    return true;
                }
            } catch (e) {
                // graphs1090 not available
            }

            graphs1090Available = false;
            document.getElementById('graphs-status').textContent = 'Local DB';
            document.getElementById('graphs-status').classList.remove('connected');
            document.getElementById('graphs-status').classList.add('local');
            console.log('graphs1090 not detected, using local database');
            return false;
        }

        // Fetch stats from dump1090 stats.json
        async function fetchStats() {
            const now = Date.now();

            // Always get current aircraft count from the UI
            const planeCountEl = document.getElementById('plane-count');
            const aircraftCount = planeCountEl ? (parseInt(planeCountEl.textContent) || 0) : 0;

            try {
                const response = await fetch(STATS_URL, { cache: 'no-store' });
                const data = await response.json();

                // Extract message rate from last1min
                let messageRate = 0;
                if (data.last1min && data.last1min.local) {
                    const local = data.last1min.local;
                    const accepted = local.accepted || [0, 0];
                    const totalAccepted = accepted.reduce((a, b) => a + b, 0);
                    // Calculate rate per second (last1min data spans ~60 seconds)
                    const duration = (data.last1min.end || now/1000) - (data.last1min.start || (now/1000 - 60));
                    messageRate = duration > 0 ? totalAccepted / duration : 0;
                }

                // Extract signal level
                let signalLevel = -50; // Default
                if (data.last1min && data.last1min.local) {
                    signalLevel = data.last1min.local.signal || -50;
                }

                // Store in history
                statsHistory.messageRate.push({ timestamp: now, value: messageRate });
                statsHistory.aircraftCount.push({ timestamp: now, value: aircraftCount });
                statsHistory.signalLevel.push({ timestamp: now, value: signalLevel });

                // Trim history
                if (statsHistory.messageRate.length > STATS_HISTORY_MAX) {
                    statsHistory.messageRate.shift();
                }
                if (statsHistory.aircraftCount.length > STATS_HISTORY_MAX) {
                    statsHistory.aircraftCount.shift();
                }
                if (statsHistory.signalLevel.length > STATS_HISTORY_MAX) {
                    statsHistory.signalLevel.shift();
                }

                // Save to IndexedDB
                saveStatsToDb('messageRate', { timestamp: now, value: messageRate });
                saveStatsToDb('aircraft', { timestamp: now, count: aircraftCount });
                saveStatsToDb('signal', { timestamp: now, value: signalLevel });

                // Update display
                updateGraphsDisplay();

            } catch (error) {
                // stats.json not available - still track aircraft count
                statsHistory.aircraftCount.push({ timestamp: now, value: aircraftCount });
                if (statsHistory.aircraftCount.length > STATS_HISTORY_MAX) {
                    statsHistory.aircraftCount.shift();
                }

                saveStatsToDb('aircraft', { timestamp: now, count: aircraftCount });
                updateGraphsDisplay();
            }
        }

        // Filter history data based on selected time period
        function filterHistoryByPeriod(historyArray) {
            const now = Date.now();
            const cutoff = now - (graphsTimePeriod * 1000);
            return historyArray.filter(d => d.timestamp >= cutoff);
        }

        // Update the graphs display
        function updateGraphsDisplay() {
            if (!showGraphs) return;

            const isRetro = currentTheme === 'retro';
            const lineColor = isRetro ? '#00ff00' : (currentTheme === 'night' ? '#00d4ff' : '#0088ff');
            const fillColor = isRetro ? 'rgba(0, 255, 0, 0.2)' : (currentTheme === 'night' ? 'rgba(0, 212, 255, 0.2)' : 'rgba(0, 136, 255, 0.2)');
            const secondLineColor = isRetro ? '#00cc00' : (currentTheme === 'night' ? '#ffaa00' : '#ff8800');

            // Filter data by selected time period
            const filteredMsgRate = filterHistoryByPeriod(statsHistory.messageRate);
            const filteredAircraftCount = filterHistoryByPeriod(statsHistory.aircraftCount);
            const filteredSignal = filterHistoryByPeriod(statsHistory.signalLevel);

            // Message Rate Graph
            if (filteredMsgRate.length > 0) {
                const latest = statsHistory.messageRate.length > 0 ?
                    statsHistory.messageRate[statsHistory.messageRate.length - 1].value : 0;
                document.getElementById('msg-rate-value').textContent = latest.toFixed(1) + ' msg/s';

                const values = filteredMsgRate.map(d => d.value);
                const min = Math.min(...values);
                const max = Math.max(...values);
                document.getElementById('msg-rate-min').textContent = 'Min: ' + min.toFixed(1);
                document.getElementById('msg-rate-max').textContent = 'Max: ' + max.toFixed(1);

                drawMiniGraph('canvas-msg-rate', values, lineColor, fillColor);
            }

            // Aircraft Count Graph
            if (filteredAircraftCount.length > 0) {
                const latest = statsHistory.aircraftCount.length > 0 ?
                    statsHistory.aircraftCount[statsHistory.aircraftCount.length - 1].value : 0;
                document.getElementById('aircraft-value').textContent = latest;

                const values = filteredAircraftCount.map(d => d.value);
                const min = Math.min(...values);
                const max = Math.max(...values);
                document.getElementById('aircraft-min').textContent = 'Min: ' + min;
                document.getElementById('aircraft-max').textContent = 'Max: ' + max;

                drawMiniGraph('canvas-aircraft', values, lineColor, fillColor);
            }

            // Signal Level Graph
            if (filteredSignal.length > 0) {
                const latest = statsHistory.signalLevel.length > 0 ?
                    statsHistory.signalLevel[statsHistory.signalLevel.length - 1].value : -50;
                document.getElementById('signal-value').textContent = latest.toFixed(1) + ' dBFS';

                const values = filteredSignal.map(d => d.value);
                const min = Math.min(...values);
                const max = Math.max(...values);
                document.getElementById('signal-min').textContent = 'Min: ' + min.toFixed(1) + ' dB';
                document.getElementById('signal-max').textContent = 'Max: ' + max.toFixed(1) + ' dB';

                // Signal is negative, so invert for better visualization
                const normalizedValues = values.map(v => -v);
                drawMiniGraph('canvas-signal', normalizedValues, lineColor, fillColor);
            }
        }

        // Draw a mini graph on canvas
        function drawMiniGraph(canvasId, values, lineColor, fillColor, values2 = null, lineColor2 = null) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            const rect = canvas.getBoundingClientRect();

            // Set actual canvas size for crisp rendering
            const dpr = window.devicePixelRatio || 1;
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);

            const width = rect.width;
            const height = rect.height;
            const padding = 2;

            ctx.clearRect(0, 0, width, height);

            if (values.length < 2) return;

            // Calculate combined min/max if two datasets
            let allValues = values;
            if (values2 && values2.length > 0) {
                allValues = [...values, ...values2];
            }

            const minVal = Math.min(...allValues);
            const maxVal = Math.max(...allValues);
            const range = maxVal - minVal || 1;

            // Draw helper function
            const drawLine = (data, color, fill) => {
                const stepX = (width - padding * 2) / (data.length - 1);

                ctx.beginPath();
                ctx.moveTo(padding, height - padding);

                for (let i = 0; i < data.length; i++) {
                    const x = padding + i * stepX;
                    const normalizedY = (data[i] - minVal) / range;
                    const y = height - padding - normalizedY * (height - padding * 2);

                    if (i === 0) {
                        ctx.lineTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }

                // Complete the fill path
                ctx.lineTo(width - padding, height - padding);
                ctx.closePath();

                ctx.fillStyle = fill;
                ctx.fill();

                // Draw the line on top
                ctx.beginPath();
                for (let i = 0; i < data.length; i++) {
                    const x = padding + i * stepX;
                    const normalizedY = (data[i] - minVal) / range;
                    const y = height - padding - normalizedY * (height - padding * 2);

                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }

                ctx.strokeStyle = color;
                ctx.lineWidth = 1.5;
                ctx.stroke();
            };

            // Draw primary data
            drawLine(values, lineColor, fillColor);

            // Draw secondary data if provided
            if (values2 && values2.length > 0 && lineColor2) {
                drawLine(values2, lineColor2, 'transparent');
            }
        }

        // Initialize graphs system
        async function initGraphsSystem() {
            await initStatsDatabase();
            await checkGraphs1090();

            // Clean up old trails
            cleanupOldTrails();

            // Start fetching stats
            fetchStats();
            setInterval(fetchStats, 1000);

            // Re-check graphs1090 periodically (every 5 minutes)
            setInterval(checkGraphs1090, 300000);

            // Clean up old trails periodically (every hour)
            setInterval(cleanupOldTrails, 3600000);
        }

        // Expose functions globally for onclick handlers
        window.setGraphsTimePeriod = function(seconds) {
            graphsTimePeriod = seconds;

            // Update button states
            document.querySelectorAll('.time-period-btn').forEach(btn => {
                btn.classList.toggle('active', parseInt(btn.dataset.period) === seconds);
            });

            // Refresh display
            updateGraphsDisplay();
            saveSettings();
        };

        window.toggleGraphs = function() {
            showGraphs = !showGraphs;
            const panel = document.getElementById('graphs-panel');
            const btn = document.getElementById('btn-graphs');

            if (showGraphs) {
                panel.classList.add('visible');
                btn.classList.add('active');
                updateGraphsDisplay();
            } else {
                panel.classList.remove('visible');
                btn.classList.remove('active');
            }

            saveSettings();
        };

        // Trail control functions (airloom-style)
        window.toggleTrails = function() {
            trailEnabled = !trailEnabled;
            document.getElementById('btn-trails').classList.toggle('active', trailEnabled);

            // Update all existing plane trails visibility
            if (_airplanesArrayDirty) {
                _airplanesArray = Array.from(airplanes.values());
                _airplanesArrayDirty = false;
            }
            for (let i = 0, len = _airplanesArray.length; i < len; i++) {
                const plane = _airplanesArray[i];
                if (plane.userData.trail) {
                    plane.userData.trail.visible = trailEnabled;
                }
            }
            saveSettings();
            _needsRender = true;
        };

        window.setTrailLength = function(length) {
            trailMaxLength = parseInt(length) || 200;
            document.getElementById('trail-length-value').textContent = trailMaxLength;

            // Trim existing trails if needed
            if (_airplanesArrayDirty) {
                _airplanesArray = Array.from(airplanes.values());
                _airplanesArrayDirty = false;
            }
            for (let i = 0, len = _airplanesArray.length; i < len; i++) {
                const plane = _airplanesArray[i];
                if (plane.userData.trailPoints && plane.userData.trailPoints.length > trailMaxLength) {
                    plane.userData.trailPoints = plane.userData.trailPoints.slice(-trailMaxLength);
                    updateTrail(plane);
                }
            }
            saveSettings();
        };

        window.setTrailThickness = function(thickness) {
            trailThickness = parseInt(thickness) || 2;

            // Update all trail materials
            if (_airplanesArrayDirty) {
                _airplanesArray = Array.from(airplanes.values());
                _airplanesArrayDirty = false;
            }
            for (let i = 0, len = _airplanesArray.length; i < len; i++) {
                const plane = _airplanesArray[i];
                if (plane.userData.trailMaterial) {
                    plane.userData.trailMaterial.linewidth = trailThickness;
                    plane.userData.trailMaterial.needsUpdate = true;
                }
            }
            saveSettings();
            _needsRender = true;
        };

        window.clearAllTrails = function() {
            if (_airplanesArrayDirty) {
                _airplanesArray = Array.from(airplanes.values());
                _airplanesArrayDirty = false;
            }
            for (let i = 0, len = _airplanesArray.length; i < len; i++) {
                const plane = _airplanesArray[i];
                plane.userData.trailPoints = [];
                if (plane.userData.trail) {
                    plane.userData.trail.geometry.setDrawRange(0, 0);
                }
            }
            _needsRender = true;
        };

        function init() {
            // Load saved settings from cookies
            loadSettings();

            // Apply loaded settings to UI
            document.body.className = 'theme-' + currentTheme;
            document.getElementById('theme-select').value = currentTheme;
            document.getElementById('units-select').value = currentUnits;

            // Apply altitude scale to slider (1x-300x, internal 100-30000)
            const scaleValue = Math.round(altitudeScale / BASE_ALT_SCALE);
            document.getElementById('altitude-slider').value = scaleValue;
            document.getElementById('altitude-value').textContent = Math.round(scaleValue / 100) + 'x';

            // Apply trail settings to UI
            document.getElementById('btn-trails').classList.toggle('active', trailEnabled);
            document.getElementById('trail-length-slider').value = trailMaxLength;
            document.getElementById('trail-length-value').textContent = trailMaxLength;
            document.getElementById('trail-thickness-slider').value = trailThickness;

            // Initialize shared geometry pools
            initSharedGeometries();

            // Scene
            scene = new THREE.Scene();
            updateSceneBackground();

            // Camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
            updateCameraPosition();

            // Renderer - cap pixel ratio at 2 to reduce GPU load on high-DPI displays
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('container').appendChild(renderer.domElement);

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 100, 50);
            scene.add(directionalLight);

            // Ground placeholder
            createGroundPlaceholder();

            // Controls
            setupControls();

            // Window resize
            window.addEventListener('resize', onWindowResize);

            // Visibility change - pause rendering when tab is hidden
            document.addEventListener('visibilitychange', () => {
                _isTabVisible = !document.hidden;
            });

            // Mouse interaction
            renderer.domElement.addEventListener('click', onMouseClick);

            // Touch gestures for mobile
            setupTouchControls();

            // Keyboard shortcuts
            setupKeyboardShortcuts();

            // Altitude slider (internal 100-30000, displayed as 1x-300x)
            const slider = document.getElementById('altitude-slider');
            slider.addEventListener('input', (e) => {
                const value = parseInt(e.target.value);
                altitudeScale = value * BASE_ALT_SCALE;
                document.getElementById('altitude-value').textContent = Math.round(value / 100) + 'x';
                updateAllAircraftPositions();
                saveSettings();
            });

            // Apply data mode to UI
            const dataModeSelect = document.getElementById('data-mode-select');
            if (dataModeSelect) dataModeSelect.value = DataSource.mode;
            const indicator = document.getElementById('data-mode-indicator');
            if (indicator) {
                indicator.textContent = DataSource.mode === 'global' ? 'GLOBAL' : 'LOCAL';
                indicator.className = 'data-mode-badge data-mode-' + DataSource.mode;
            }

            // For global mode, set default center if not initialized
            if (DataSource.mode === 'global' && !centerInitialized) {
                centerLat = 40.7128;
                centerLon = -74.0060;
                centerInitialized = true;
                document.getElementById('center-coords').textContent =
                    `${centerLat.toFixed(2)}, ${centerLon.toFixed(2)}`;
            }

            // Start animation
            animate();

            // Fetch data with mode-appropriate interval
            const fetchInterval = DataSource.mode === 'global' ? GLOBAL_REFRESH_INTERVAL : REFRESH_INTERVAL;
            fetchData();
            window._dataFetchInterval = setInterval(fetchData, fetchInterval);

            // Initialize graphs system
            initGraphsSystem();

            // Initialize airport search and load data asynchronously
            initAirportSearch();
            AirportDB.load();

            // Apply graphs panel state from settings
            if (showGraphs) {
                document.getElementById('graphs-panel').classList.add('visible');
            }

            // Apply time period button state
            document.querySelectorAll('.time-period-btn').forEach(btn => {
                btn.classList.toggle('active', parseInt(btn.dataset.period) === graphsTimePeriod);
            });

            // Apply trail settings state
            document.getElementById('btn-trails').classList.toggle('active', trailEnabled);
            document.getElementById('trail-length-slider').value = trailMaxLength;
            document.getElementById('trail-length-value').textContent = trailMaxLength;
            document.getElementById('trail-thickness-slider').value = trailThickness;
        }

        function updateSceneBackground() {
            if (currentTheme === 'day') {
                scene.background = new THREE.Color(0x87CEEB);
                scene.fog = new THREE.Fog(0x87CEEB, 500, 1200);
            } else if (currentTheme === 'night') {
                scene.background = new THREE.Color(0x0a0a1a);
                scene.fog = new THREE.Fog(0x0a0a1a, 500, 1200);
            } else if (currentTheme === 'retro') {
                scene.background = new THREE.Color(0x000800);
                scene.fog = new THREE.Fog(0x000800, 500, 1200);
            }
        }

        function changeDataMode(mode) {
            DataSource.setMode(mode);
        }

        function changeTheme(theme) {
            currentTheme = theme;
            document.body.className = 'theme-' + theme;
            updateSceneBackground();

            // Clear tile cache for theme change to force reload with new style
            tileCache.clear();

            // Reload map tiles with appropriate style
            loadMapTiles();

            // Recreate all airplanes with new style (wireframe vs solid)
            recreateAllAirplanes();

            saveSettings();
        }

        function recreateAllAirplanes() {
            // Store current aircraft data
            const aircraftData = [];
            for (const [hex, plane] of airplanes.entries()) {
                aircraftData.push({...plane.userData});
                // Remove old plane and its trails/lines
                scene.remove(plane);
                if (plane.userData.trail) scene.remove(plane.userData.trail);
                if (plane.userData.altLine) scene.remove(plane.userData.altLine);
            }
            airplanes.clear();
            _airplanesArrayDirty = true;

            // Recreate with new theme style
            for (let i = 0; i < aircraftData.length; i++) {
                const data = aircraftData[i];
                if (!data.lat || !data.lon) continue;
                const plane = createAirplane(data);
                const pos = latLonToXZ(data.lat, data.lon);
                const alt = (data.altitude || 0) * altitudeScale;
                plane.position.set(pos.x, alt, pos.z);

                if (data.track !== undefined) {
                    plane.rotation.y = (-data.track * Math.PI / 180) + Math.PI;
                }

                updateAltitudeLine(plane);
                scene.add(plane);
                airplanes.set(data.hex, plane);
            }
            _airplanesArrayDirty = true;

            updateLabels();
        }

        function changeUnits(units) {
            currentUnits = units;
            updateLabels();
            if (selectedPlane) {
                selectPlane(selectedPlane);
            }
            saveSettings();
        }

        function formatAltitude(altFeet) {
            if (currentUnits === 'imperial') {
                return Math.round(altFeet).toLocaleString() + ' ft';
            } else {
                const meters = Math.round(altFeet * 0.3048);
                return meters.toLocaleString() + ' m';
            }
        }

        function formatSpeed(speedKnots) {
            if (currentUnits === 'imperial') {
                return Math.round(speedKnots) + ' kts';
            } else {
                const kmh = Math.round(speedKnots * 1.852);
                return kmh + ' km/h';
            }
        }

        function formatVertRate(rateFpm) {
            if (currentUnits === 'imperial') {
                return Math.round(rateFpm) + ' ft/min';
            } else {
                const mpm = Math.round(rateFpm * 0.3048);
                return mpm + ' m/min';
            }
        }

        function createGroundPlaceholder() {
            const geometry = new THREE.PlaneGeometry(MAP_GROUND_SIZE, MAP_GROUND_SIZE);
            const material = new THREE.MeshBasicMaterial({
                color: currentTheme === 'retro' ? 0x001100 : 0x1a4d1a,
                side: THREE.DoubleSide
            });
            const ground = new THREE.Mesh(geometry, material);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -0.1;
            ground.name = 'groundPlaceholder';
            scene.add(ground);
        }

        function getTileUrl(x, y, zoom) {
            if (currentTheme === 'retro') {
                // Use Stamen Toner Lite for retro theme - will be inverted to green
                return `https://tiles.stadiamaps.com/tiles/stamen_toner_lite/${zoom}/${x}/${y}.png`;
            } else if (currentTheme === 'night') {
                // Use CartoDB dark tiles for night theme
                return `https://a.basemaps.cartocdn.com/dark_all/${zoom}/${x}/${y}.png`;
            } else {
                // Standard OSM for day theme
                const servers = ['a', 'b', 'c'];
                const server = servers[Math.abs(x + y) % 3];
                return `https://${server}.tile.openstreetmap.org/${zoom}/${x}/${y}.png`;
            }
        }

        // Invert and colorize image for retro theme
        function invertToGreen(image) {
            const canvas = document.createElement('canvas');
            canvas.width = image.width;
            canvas.height = image.height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(image, 0, 0);

            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            for (let i = 0; i < data.length; i += 4) {
                // Get grayscale value (inverted)
                const gray = 255 - (data[i] * 0.299 + data[i+1] * 0.587 + data[i+2] * 0.114);
                // Convert to green
                data[i] = 0;           // R
                data[i+1] = gray;      // G
                data[i+2] = 0;         // B
                // Keep alpha
            }

            ctx.putImageData(imageData, 0, 0);
            return canvas;
        }

        // Initialize shared geometries (called once at startup)
        function initSharedGeometries() {
            if (_sharedGeometries) return;

            _sharedGeometries = {
                // Wireframe geometries (retro theme)
                wire: {
                    fuselage: new THREE.EdgesGeometry(new THREE.BoxGeometry(0.8, 0.6, 4)),
                    nose: new THREE.EdgesGeometry(new THREE.ConeGeometry(0.4, 1.2, 4)),
                    wing: new THREE.EdgesGeometry(new THREE.BoxGeometry(6, 0.1, 1.5)),
                    tail: new THREE.EdgesGeometry(new THREE.BoxGeometry(0.1, 1.2, 0.8)),
                    hStab: new THREE.EdgesGeometry(new THREE.BoxGeometry(2.5, 0.1, 0.5)),
                    light: new THREE.SphereGeometry(0.2, 4, 4),
                    // Helicopter rotor
                    rotor: new THREE.EdgesGeometry(new THREE.BoxGeometry(8, 0.05, 0.3)),
                    rotorMast: new THREE.EdgesGeometry(new THREE.CylinderGeometry(0.1, 0.1, 0.5, 4)),
                    // Small aircraft (prop plane)
                    smallFuselage: new THREE.EdgesGeometry(new THREE.BoxGeometry(0.5, 0.4, 2.5)),
                    smallWing: new THREE.EdgesGeometry(new THREE.BoxGeometry(5, 0.08, 0.8)),
                    propeller: new THREE.EdgesGeometry(new THREE.BoxGeometry(0.1, 1.5, 0.1)),
                    // Wide-body
                    wideFuselage: new THREE.EdgesGeometry(new THREE.BoxGeometry(1.2, 0.9, 5.5)),
                    wideWing: new THREE.EdgesGeometry(new THREE.BoxGeometry(9, 0.12, 2))
                },
                // Solid geometries (day/night themes)
                solid: {
                    fuselage: new THREE.CylinderGeometry(0.4, 0.6, 4, 8),
                    nose: new THREE.ConeGeometry(0.4, 1.2, 8),
                    wing: new THREE.BoxGeometry(5, 0.15, 1.5),
                    tailFin: new THREE.BoxGeometry(0.15, 1.2, 1),
                    hStab: new THREE.BoxGeometry(2, 0.1, 0.6),
                    engine: new THREE.CylinderGeometry(0.25, 0.25, 0.8, 8),
                    light: new THREE.SphereGeometry(0.15, 8, 8),
                    // Helicopter
                    heliFuselage: new THREE.CylinderGeometry(0.4, 0.5, 2.5, 8),
                    heliCabin: new THREE.SphereGeometry(0.6, 8, 6),
                    heliTail: new THREE.CylinderGeometry(0.15, 0.1, 2.5, 6),
                    rotor: new THREE.BoxGeometry(6, 0.05, 0.2),
                    tailRotor: new THREE.BoxGeometry(0.05, 1.2, 0.15),
                    // Small aircraft
                    smallFuselage: new THREE.CylinderGeometry(0.25, 0.35, 2.5, 8),
                    smallWing: new THREE.BoxGeometry(4, 0.08, 0.8),
                    propeller: new THREE.BoxGeometry(0.08, 1.2, 0.08),
                    // Wide-body
                    wideFuselage: new THREE.CylinderGeometry(0.7, 0.8, 5.5, 10),
                    wideNose: new THREE.ConeGeometry(0.7, 1.5, 10),
                    wideWing: new THREE.BoxGeometry(8, 0.2, 2.2),
                    wideEngine: new THREE.CylinderGeometry(0.4, 0.4, 1.2, 8),
                    // Military (angular)
                    milFuselage: new THREE.BoxGeometry(0.6, 0.4, 4.5),
                    milWing: new THREE.BufferGeometry(), // Will be created as triangle
                    milTail: new THREE.BoxGeometry(0.08, 0.8, 0.6)
                },
                // LOD geometries (simplified for distant aircraft)
                lod: {
                    plane: new THREE.BoxGeometry(2, 0.5, 4),
                    light: new THREE.SphereGeometry(0.3, 4, 4)
                },
                // Shared tile geometry
                tile: new THREE.PlaneGeometry(MAP_GROUND_SIZE / TILES_PER_SIDE, MAP_GROUND_SIZE / TILES_PER_SIDE)
            };

            // Create military delta wing geometry
            const milWingVerts = new Float32Array([
                0, 0, -2,    // back center
                -3, 0, 1,   // left front
                3, 0, 1,    // right front
            ]);
            _sharedGeometries.solid.milWing = new THREE.BufferGeometry();
            _sharedGeometries.solid.milWing.setAttribute('position', new THREE.BufferAttribute(milWingVerts, 3));
            _sharedGeometries.solid.milWing.computeVertexNormals();

            // Initialize glow texture for aircraft
            initGlowTexture();
        }

        // Create glow texture for aircraft (sprite-based approach like airloom)
        function initGlowTexture() {
            if (_glowTexture) return;

            // Create radial gradient canvas texture
            const size = 64;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');

            // Create radial gradient: bright center fading to transparent edges
            const gradient = ctx.createRadialGradient(
                size / 2, size / 2, 0,
                size / 2, size / 2, size / 2
            );
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
            gradient.addColorStop(0.3, 'rgba(255, 255, 255, 0.5)');
            gradient.addColorStop(0.7, 'rgba(255, 255, 255, 0.1)');
            gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, size, size);

            _glowTexture = new THREE.CanvasTexture(canvas);
            _glowTexture.needsUpdate = true;
        }

        // Create glow sprite for an aircraft
        function createGlowSprite(color, isRetro) {
            if (!_glowTexture) initGlowTexture();

            const glowMaterial = new THREE.SpriteMaterial({
                map: _glowTexture,
                color: color,
                transparent: true,
                opacity: 0.4,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                sizeAttenuation: true
            });

            const glowSprite = new THREE.Sprite(glowMaterial);
            // Scale to 2.5x aircraft size for visible glow effect
            glowSprite.scale.set(8, 8, 1);
            return glowSprite;
        }

        // Get pooled material or create new one
        function getPooledMaterial(type, options) {
            const pool = _materialPool[type];
            if (pool && pool.length > 0) {
                const mat = pool.pop();
                // Reset material properties
                if (options.color !== undefined) mat.color.setHex(options.color);
                if (options.emissive !== undefined && mat.emissive) mat.emissive.setHex(options.emissive);
                if (options.opacity !== undefined) mat.opacity = options.opacity;
                if (options.transparent !== undefined) mat.transparent = options.transparent;
                mat.needsUpdate = true;
                return mat;
            }
            // Create new material
            switch (type) {
                case 'wireframe':
                    return new THREE.LineBasicMaterial(options);
                case 'phong':
                    return new THREE.MeshPhongMaterial(options);
                case 'basic':
                    return new THREE.MeshBasicMaterial(options);
                default:
                    return new THREE.MeshBasicMaterial(options);
            }
        }

        // Return material to pool
        function returnMaterialToPool(type, material) {
            const pool = _materialPool[type];
            if (pool && pool.length < MAX_MATERIAL_POOL_SIZE) {
                pool.push(material);
            } else {
                material.dispose();
            }
        }

        // Tile cache management with size limiting
        function addToTileCache(key, texture) {
            // Enforce cache size limit using LRU-like behavior
            if (tileCache.size >= MAX_TILE_CACHE_SIZE) {
                // Remove oldest entries (first 20% of cache)
                const keysToRemove = [];
                let count = 0;
                const removeCount = Math.floor(MAX_TILE_CACHE_SIZE * 0.2);
                for (const k of tileCache.keys()) {
                    if (count++ < removeCount) {
                        keysToRemove.push(k);
                    } else {
                        break;
                    }
                }
                for (const k of keysToRemove) {
                    const tex = tileCache.get(k);
                    if (tex && tex.dispose) tex.dispose();
                    tileCache.delete(k);
                }
            }
            tileCache.set(key, texture);
        }

        function latLonToTile(lat, lon, zoom) {
            const n = Math.pow(2, zoom);
            const x = Math.floor((lon + 180) / 360 * n);
            const latRad = lat * Math.PI / 180;
            const y = Math.floor((1 - Math.log(Math.tan(latRad) + 1 / Math.cos(latRad)) / Math.PI) / 2 * n);
            return { x, y };
        }

        function tileToLatLon(x, y, zoom) {
            const n = Math.pow(2, zoom);
            const lon = x / n * 360 - 180;
            const latRad = Math.atan(Math.sinh(Math.PI * (1 - 2 * y / n)));
            const lat = latRad * 180 / Math.PI;
            return { lat, lon };
        }

        // Preload tiles for adjacent areas
        function preloadAdjacentTiles() {
            if (!centerInitialized) return;

            const centerTile = latLonToTile(centerLat, centerLon, currentZoom);
            const halfTiles = Math.floor(TILES_PER_SIDE / 2);

            // Preload one tile beyond visible area in each direction
            const preloadRange = halfTiles + 1;

            for (let dy = -preloadRange; dy <= preloadRange; dy++) {
                for (let dx = -preloadRange; dx <= preloadRange; dx++) {
                    // Skip tiles that are already visible
                    if (Math.abs(dx) <= halfTiles && Math.abs(dy) <= halfTiles) continue;

                    const tileX = centerTile.x + dx;
                    const tileY = centerTile.y + dy;
                    const cacheKey = `${currentTheme}-${currentZoom}-${tileX}-${tileY}`;

                    // Skip if already cached or in preload queue
                    if (tileCache.has(cacheKey) || preloadedTiles.has(cacheKey)) continue;

                    preloadQueue.push({ tileX, tileY, cacheKey, zoom: currentZoom, theme: currentTheme });
                }
            }

            // Also preload adjacent zoom levels
            [currentZoom - 1, currentZoom + 1].forEach(zoom => {
                if (zoom < MIN_ZOOM || zoom > MAX_ZOOM) return;
                const ct = latLonToTile(centerLat, centerLon, zoom);
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        const tileX = ct.x + dx;
                        const tileY = ct.y + dy;
                        const cacheKey = `${currentTheme}-${zoom}-${tileX}-${tileY}`;
                        if (!tileCache.has(cacheKey) && !preloadedTiles.has(cacheKey)) {
                            preloadQueue.push({ tileX, tileY, cacheKey, zoom, theme: currentTheme });
                        }
                    }
                }
            });

            processPreloadQueue();
        }

        // Process preload queue with concurrency limit
        function processPreloadQueue() {
            while (preloadInProgress < MAX_CONCURRENT_PRELOADS && preloadQueue.length > 0) {
                const item = preloadQueue.shift();
                if (tileCache.has(item.cacheKey) || preloadedTiles.has(item.cacheKey)) continue;

                preloadInProgress++;
                preloadedTiles.set(item.cacheKey, { loading: true });

                const url = getTileUrl(item.tileX, item.tileY, item.zoom);

                if (item.theme === 'retro') {
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    img.onload = () => {
                        const invertedCanvas = invertToGreen(img);
                        const texture = new THREE.CanvasTexture(invertedCanvas);
                        addToTileCache(item.cacheKey, texture);
                        preloadedTiles.delete(item.cacheKey);
                        preloadInProgress--;
                        processPreloadQueue();
                    };
                    img.onerror = () => {
                        preloadedTiles.delete(item.cacheKey);
                        preloadInProgress--;
                        processPreloadQueue();
                    };
                    img.src = url;
                } else {
                    const loader = new THREE.TextureLoader();
                    loader.crossOrigin = 'anonymous';
                    loader.load(url,
                        (texture) => {
                            addToTileCache(item.cacheKey, texture);
                            preloadedTiles.delete(item.cacheKey);
                            preloadInProgress--;
                            processPreloadQueue();
                        },
                        undefined,
                        () => {
                            preloadedTiles.delete(item.cacheKey);
                            preloadInProgress--;
                            processPreloadQueue();
                        }
                    );
                }
            }
        }

        function loadMapTiles() {
            if (!centerInitialized) return;

            // Initialize shared geometries if needed
            initSharedGeometries();

            const centerTile = latLonToTile(centerLat, centerLon, currentZoom);
            const halfTiles = Math.floor(TILES_PER_SIDE / 2);
            const startTileX = centerTile.x - halfTiles;
            const startTileY = centerTile.y - halfTiles;
            const topLeft = tileToLatLon(startTileX, startTileY, currentZoom);
            const bottomRight = tileToLatLon(startTileX + TILES_PER_SIDE, startTileY + TILES_PER_SIDE, currentZoom);

            window.mapBounds = {
                north: topLeft.lat,
                south: bottomRight.lat,
                east: bottomRight.lon,
                west: topLeft.lon
            };

            const tileSize = MAP_GROUND_SIZE / TILES_PER_SIDE;

            // Build map of existing tiles by their tile coordinates
            const existingTiles = new Map();
            mapTiles.forEach(tile => {
                if (tile.userData.tileKey) {
                    existingTiles.set(tile.userData.tileKey, tile);
                }
            });

            const newMapTiles = [];
            const tilesToRemove = new Set(existingTiles.keys());

            for (let dy = 0; dy < TILES_PER_SIDE; dy++) {
                for (let dx = 0; dx < TILES_PER_SIDE; dx++) {
                    const tileX = centerTile.x - halfTiles + dx;
                    const tileY = centerTile.y - halfTiles + dy;
                    const cacheKey = `${currentTheme}-${currentZoom}-${tileX}-${tileY}`;
                    const tileKey = `${currentZoom}-${tileX}-${tileY}`;

                    const posX = (dx - halfTiles + 0.5) * tileSize;
                    const posZ = (dy - halfTiles + 0.5) * tileSize;

                    let tile;

                    // Reuse existing tile if same coordinates
                    if (existingTiles.has(tileKey)) {
                        tile = existingTiles.get(tileKey);
                        tilesToRemove.delete(tileKey);
                        // Update position (might change due to different grid position)
                        tile.position.set(posX, 0, posZ);
                    } else {
                        // Create new tile using shared geometry
                        const geometry = _sharedGeometries.tile;
                        const material = new THREE.MeshBasicMaterial({
                            color: currentTheme === 'retro' ? 0x001100 : 0x1a4d1a,
                            side: THREE.DoubleSide,
                            transparent: true,
                            opacity: 0 // Start transparent for fade-in
                        });

                        tile = new THREE.Mesh(geometry, material);
                        tile.rotation.x = -Math.PI / 2;
                        tile.position.set(posX, 0, posZ);
                        tile.userData.tileKey = tileKey;
                        tile.userData.fadeIn = true;
                        tile.userData.fadeStart = Date.now();
                        scene.add(tile);
                    }

                    newMapTiles.push(tile);

                    // Load or apply texture
                    const material = tile.material;
                    if (tileCache.has(cacheKey)) {
                        material.map = tileCache.get(cacheKey);
                        material.color.setHex(0xffffff);
                        if (!tile.userData.fadeIn) material.opacity = 1;
                        material.needsUpdate = true;
                    } else {
                        // Load texture with fade-in effect
                        loadTileTexture(tileX, tileY, currentZoom, cacheKey, material, tile);
                    }
                }
            }

            // Remove tiles that are no longer needed with fade-out
            for (const tileKey of tilesToRemove) {
                const tile = existingTiles.get(tileKey);
                if (tile) {
                    // Quick fade out and remove
                    tile.userData.fadeOut = true;
                    tile.userData.fadeStart = Date.now();
                    setTimeout(() => {
                        scene.remove(tile);
                        if (tile.material && tile.material !== _sharedGeometries.tile) {
                            tile.material.dispose();
                        }
                    }, 150);
                }
            }

            mapTiles = newMapTiles;
            document.getElementById('map-zoom').textContent = currentZoom;

            // Trigger preloading of adjacent tiles
            setTimeout(preloadAdjacentTiles, 100);

            _needsRender = true;
            updateAllAircraftPositions();

            // Update airport labels when map changes
            if (AirportDB.loaded) {
                AirportDB.updateLabels();
            }

            // Load terrain tiles alongside map tiles
            if (terrainEnabled) {
                TerrainSystem.loadTerrainTiles();
            }
        }

        // Load tile texture with error handling
        function loadTileTexture(tileX, tileY, zoom, cacheKey, material, tile) {
            const url = getTileUrl(tileX, tileY, zoom);

            if (currentTheme === 'retro') {
                const img = new Image();
                img.crossOrigin = 'anonymous';
                img.onload = () => {
                    const invertedCanvas = invertToGreen(img);
                    const texture = new THREE.CanvasTexture(invertedCanvas);
                    material.map = texture;
                    material.color.setHex(0xffffff);
                    material.needsUpdate = true;
                    addToTileCache(cacheKey, texture);
                    tile.userData.textureLoaded = true;
                    _needsRender = true;
                };
                img.onerror = () => {
                    console.warn('Failed to load tile:', url);
                };
                img.src = url;
            } else {
                const loader = new THREE.TextureLoader();
                loader.crossOrigin = 'anonymous';
                loader.load(url,
                    (texture) => {
                        material.color.setHex(0xffffff);
                        material.map = texture;
                        material.needsUpdate = true;
                        addToTileCache(cacheKey, texture);
                        tile.userData.textureLoaded = true;
                        _needsRender = true;
                    },
                    undefined,
                    () => {
                        console.warn('Failed to load tile:', url);
                    }
                );
            }
        }

        function mapZoomIn() {
            if (currentZoom < MAX_ZOOM && !mapTransition.active) {
                startMapTransition(centerLat, centerLon, currentZoom + 1);
            }
        }

        function mapZoomOut() {
            if (currentZoom > MIN_ZOOM && !mapTransition.active) {
                startMapTransition(centerLat, centerLon, currentZoom - 1);
            }
        }

        // Start smooth map transition
        function startMapTransition(targetLat, targetLon, targetZoom) {
            mapTransition.startLat = centerLat;
            mapTransition.startLon = centerLon;
            mapTransition.startZoom = currentZoom;
            mapTransition.targetLat = targetLat;
            mapTransition.targetLon = targetLon;
            mapTransition.targetZoom = targetZoom;
            mapTransition.startTime = Date.now();
            mapTransition.active = true;
            _needsRender = true;
        }

        // Update map transition (called from animate loop)
        function updateMapTransition() {
            if (!mapTransition.active) return false;

            const elapsed = Date.now() - mapTransition.startTime;
            const progress = Math.min(elapsed / mapTransition.duration, 1);
            const easedProgress = mapTransition.easing(progress);

            // Interpolate position
            centerLat = mapTransition.startLat + (mapTransition.targetLat - mapTransition.startLat) * easedProgress;
            centerLon = mapTransition.startLon + (mapTransition.targetLon - mapTransition.startLon) * easedProgress;

            // Update zoom at midpoint for smoother visual effect
            if (progress > 0.3 && currentZoom !== mapTransition.targetZoom) {
                currentZoom = mapTransition.targetZoom;
                loadMapTiles();
            }

            // Update display
            document.getElementById('center-coords').textContent =
                `${centerLat.toFixed(2)}, ${centerLon.toFixed(2)}`;

            // Update map bounds and aircraft positions smoothly
            if (progress < 1) {
                updateMapBoundsSmooth();
                updateAllAircraftPositions();
            }

            if (progress >= 1) {
                mapTransition.active = false;
                centerLat = mapTransition.targetLat;
                centerLon = mapTransition.targetLon;
                currentZoom = mapTransition.targetZoom;
                loadMapTiles();
            }

            return mapTransition.active;
        }

        // Update map bounds during smooth transition
        function updateMapBoundsSmooth() {
            const centerTile = latLonToTile(centerLat, centerLon, currentZoom);
            const halfTiles = Math.floor(TILES_PER_SIDE / 2);
            const startTileX = centerTile.x - halfTiles;
            const startTileY = centerTile.y - halfTiles;
            const topLeft = tileToLatLon(startTileX, startTileY, currentZoom);
            const bottomRight = tileToLatLon(startTileX + TILES_PER_SIDE, startTileY + TILES_PER_SIDE, currentZoom);

            window.mapBounds = {
                north: topLeft.lat,
                south: bottomRight.lat,
                east: bottomRight.lon,
                west: topLeft.lon
            };
        }

        // Map pan function with smooth transition
        function panMap(direction) {
            if (mapTransition.active) return; // Ignore while transitioning

            const zoomFactor = Math.pow(2, 12 - currentZoom);
            const panAmount = 0.05 * zoomFactor;

            let targetLat = centerLat;
            let targetLon = centerLon;

            switch(direction) {
                case 'up': targetLat += panAmount; break;
                case 'down': targetLat -= panAmount; break;
                case 'left': targetLon -= panAmount; break;
                case 'right': targetLon += panAmount; break;
            }

            startMapTransition(targetLat, targetLon, currentZoom);
        }

        function latLonToXZ(lat, lon) {
            if (!window.mapBounds) return { x: 0, z: 0 };
            const bounds = window.mapBounds;
            // X: longitude - West is negative X, East is positive X
            const x = ((lon - bounds.west) / (bounds.east - bounds.west) - 0.5) * MAP_GROUND_SIZE;
            // Z: latitude - North is negative Z, South is positive Z
            // (lat - north) is negative for points north of center, divided by (south - north) which is negative
            // Result: north points get negative Z, south points get positive Z
            const z = ((lat - bounds.north) / (bounds.south - bounds.north) - 0.5) * MAP_GROUND_SIZE;
            return { x, z };
        }

        function getAltitudeColor(altitude) {
            if (currentTheme === 'retro') {
                if (altitude < 5000) return 0x00ff00;
                if (altitude < 15000) return 0x00cc00;
                if (altitude < 30000) return 0x009900;
                return 0x006600;
            }
            if (altitude < 5000) return 0x00ff00;
            if (altitude < 15000) return 0xffff00;
            if (altitude < 30000) return 0xff8800;
            return 0xff0088;
        }

        function createAirplane(data) {
            // Ensure shared geometries are initialized
            if (!_sharedGeometries) initSharedGeometries();

            const group = new THREE.Group();
            const color = getAltitudeColor(data.altitude || 0);
            const isRetro = currentTheme === 'retro';
            const category = getAircraftCategory(data);

            if (isRetro) {
                // WIREFRAME MODE for retro 80s theme
                const wireMat = getPooledMaterial('wireframe', { color: 0x00ff00 });
                let positionLight;

                if (category === 'helicopter') {
                    // Helicopter wireframe
                    const cabin = new THREE.LineSegments(_sharedGeometries.wire.fuselage, wireMat);
                    cabin.scale.set(0.8, 0.8, 0.6);
                    group.add(cabin);

                    const tail = new THREE.LineSegments(_sharedGeometries.wire.fuselage, wireMat.clone());
                    tail.scale.set(0.2, 0.2, 1.2);
                    tail.position.set(0, 0, -1.5);
                    group.add(tail);

                    const mainRotor = new THREE.LineSegments(_sharedGeometries.wire.rotor, wireMat.clone());
                    mainRotor.position.set(0, 0.5, 0);
                    mainRotor.userData.isRotor = true;
                    group.add(mainRotor);

                    const tailRotor = new THREE.LineSegments(_sharedGeometries.wire.rotor, wireMat.clone());
                    tailRotor.scale.set(0.3, 1, 0.3);
                    tailRotor.rotation.z = Math.PI / 2;
                    tailRotor.position.set(0.3, 0, -2.2);
                    group.add(tailRotor);

                    const lightMat = getPooledMaterial('basic', { color: 0x00ff00, transparent: true });
                    positionLight = new THREE.Mesh(_sharedGeometries.wire.light, lightMat);
                    positionLight.position.set(0, 0.8, 0);
                    group.add(positionLight);
                } else if (category === 'small') {
                    // Small prop plane wireframe
                    const fuselageWire = new THREE.LineSegments(_sharedGeometries.wire.smallFuselage, wireMat);
                    group.add(fuselageWire);

                    const wingWire = new THREE.LineSegments(_sharedGeometries.wire.smallWing, wireMat.clone());
                    group.add(wingWire);

                    const propWire = new THREE.LineSegments(_sharedGeometries.wire.propeller, wireMat.clone());
                    propWire.position.set(0, 0, 1.5);
                    propWire.userData.isProp = true;
                    group.add(propWire);

                    const tailWire = new THREE.LineSegments(_sharedGeometries.wire.tail, wireMat.clone());
                    tailWire.scale.set(0.8, 0.6, 0.6);
                    tailWire.position.set(0, 0.3, -1.2);
                    group.add(tailWire);

                    const lightMat = getPooledMaterial('basic', { color: 0x00ff00, transparent: true });
                    positionLight = new THREE.Mesh(_sharedGeometries.wire.light, lightMat);
                    positionLight.position.set(0, 0, 1.5);
                    group.add(positionLight);
                } else if (category === 'widebody') {
                    // Wide-body wireframe
                    const fuselageWire = new THREE.LineSegments(_sharedGeometries.wire.wideFuselage, wireMat);
                    group.add(fuselageWire);

                    const noseWire = new THREE.LineSegments(_sharedGeometries.wire.nose, wireMat.clone());
                    noseWire.scale.set(1.4, 1.4, 1.2);
                    noseWire.rotation.x = -Math.PI / 2;
                    noseWire.position.z = 3.5;
                    group.add(noseWire);

                    const wingWire = new THREE.LineSegments(_sharedGeometries.wire.wideWing, wireMat.clone());
                    group.add(wingWire);

                    const tailWire = new THREE.LineSegments(_sharedGeometries.wire.tail, wireMat.clone());
                    tailWire.scale.set(1.2, 1.5, 1.2);
                    tailWire.position.set(0, 0.8, -2.5);
                    group.add(tailWire);

                    const lightMat = getPooledMaterial('basic', { color: 0x00ff00, transparent: true });
                    positionLight = new THREE.Mesh(_sharedGeometries.wire.light, lightMat);
                    positionLight.position.set(0, 0, 3.5);
                    group.add(positionLight);
                } else {
                    // Default jet wireframe (narrow-body, regional, military)
                    const fuselageWire = new THREE.LineSegments(_sharedGeometries.wire.fuselage, wireMat);
                    group.add(fuselageWire);

                    const noseWire = new THREE.LineSegments(_sharedGeometries.wire.nose, wireMat.clone());
                    noseWire.rotation.x = -Math.PI / 2;
                    noseWire.position.z = 2.6;
                    group.add(noseWire);

                    const wingWire = new THREE.LineSegments(_sharedGeometries.wire.wing, wireMat.clone());
                    if (category === 'military') {
                        wingWire.scale.set(0.8, 1, 1.5); // Swept wings
                    }
                    group.add(wingWire);

                    const tailWire = new THREE.LineSegments(_sharedGeometries.wire.tail, wireMat.clone());
                    tailWire.position.set(0, 0.6, -1.8);
                    group.add(tailWire);

                    const hStabWire = new THREE.LineSegments(_sharedGeometries.wire.hStab, wireMat.clone());
                    hStabWire.position.set(0, 0, -1.8);
                    group.add(hStabWire);

                    const lightMat = getPooledMaterial('basic', { color: 0x00ff00, transparent: true });
                    positionLight = new THREE.Mesh(_sharedGeometries.wire.light, lightMat);
                    positionLight.position.set(0, 0, 2.6);
                    group.add(positionLight);
                }

                // Add glow sprite (retro green glow)
                const glowSprite = createGlowSprite(0x00ff00, true);
                glowSprite.position.set(0, 0, 0);
                group.add(glowSprite);

                group.userData = {
                    ...data,
                    category: category,
                    noseMaterial: null,
                    positionLight: positionLight,
                    glowSprite: glowSprite,
                    lightPhase: Math.random() * Math.PI * 2,
                    isWireframe: true
                };
            } else {
                // SOLID MODE for day/night themes
                let positionLight;
                let noseMat, wingMat, fuselageMat;

                if (category === 'helicopter') {
                    // Helicopter solid model
                    fuselageMat = getPooledMaterial('phong', { color: 0xcc0000, emissive: 0x330000 });
                    const cabin = new THREE.Mesh(_sharedGeometries.solid.heliCabin, fuselageMat);
                    group.add(cabin);

                    const tailMat = getPooledMaterial('phong', { color: 0xaa0000, emissive: 0x220000 });
                    const tail = new THREE.Mesh(_sharedGeometries.solid.heliTail, tailMat);
                    tail.rotation.z = Math.PI / 2;
                    tail.position.set(0, -0.1, -1.8);
                    group.add(tail);

                    wingMat = getPooledMaterial('phong', { color: 0x333333, emissive: 0x111111 });
                    const mainRotor = new THREE.Mesh(_sharedGeometries.solid.rotor, wingMat);
                    mainRotor.position.set(0, 0.7, 0);
                    mainRotor.userData.isRotor = true;
                    group.add(mainRotor);

                    const mainRotor2 = new THREE.Mesh(_sharedGeometries.solid.rotor, wingMat);
                    mainRotor2.rotation.y = Math.PI / 2;
                    mainRotor2.position.set(0, 0.7, 0);
                    mainRotor2.userData.isRotor = true;
                    group.add(mainRotor2);

                    const tailRotor = new THREE.Mesh(_sharedGeometries.solid.tailRotor, wingMat);
                    tailRotor.position.set(0.15, 0, -2.8);
                    group.add(tailRotor);

                    noseMat = fuselageMat;
                    const lightMat = getPooledMaterial('basic', { color: 0xff0000, transparent: true });
                    positionLight = new THREE.Mesh(_sharedGeometries.solid.light, lightMat);
                    positionLight.position.set(0, 0.9, 0);
                    group.add(positionLight);
                } else if (category === 'small') {
                    // Small prop plane
                    fuselageMat = getPooledMaterial('phong', { color: 0xffffff, emissive: 0x222222 });
                    const fuselage = new THREE.Mesh(_sharedGeometries.solid.smallFuselage, fuselageMat);
                    fuselage.rotation.x = Math.PI / 2;
                    group.add(fuselage);

                    noseMat = getPooledMaterial('phong', { color: color, emissive: color, emissiveIntensity: 0.3 });
                    const nose = new THREE.Mesh(_sharedGeometries.solid.nose, noseMat);
                    nose.scale.set(0.6, 0.6, 0.6);
                    nose.rotation.x = -Math.PI / 2;
                    nose.position.z = 1.6;
                    group.add(nose);

                    wingMat = getPooledMaterial('phong', { color: 0xdddddd, emissive: 0x333333 });
                    const wings = new THREE.Mesh(_sharedGeometries.solid.smallWing, wingMat);
                    wings.position.y = 0.1;
                    group.add(wings);

                    const propMat = getPooledMaterial('phong', { color: 0x333333 });
                    const prop = new THREE.Mesh(_sharedGeometries.solid.propeller, propMat);
                    prop.position.set(0, 0, 1.8);
                    prop.userData.isProp = true;
                    group.add(prop);

                    const tailFin = new THREE.Mesh(_sharedGeometries.solid.tailFin, wingMat);
                    tailFin.scale.set(0.7, 0.5, 0.6);
                    tailFin.position.set(0, 0.3, -1.2);
                    group.add(tailFin);

                    const lightMat = getPooledMaterial('basic', { color: 0xff0000, transparent: true });
                    positionLight = new THREE.Mesh(_sharedGeometries.solid.light, lightMat);
                    positionLight.position.set(0, 0.2, -1);
                    group.add(positionLight);
                } else if (category === 'widebody') {
                    // Wide-body aircraft
                    fuselageMat = getPooledMaterial('phong', { color: 0xffffff, emissive: 0x222222 });
                    const fuselage = new THREE.Mesh(_sharedGeometries.solid.wideFuselage, fuselageMat);
                    fuselage.rotation.x = Math.PI / 2;
                    group.add(fuselage);

                    noseMat = getPooledMaterial('phong', { color: color, emissive: color, emissiveIntensity: 0.3 });
                    const nose = new THREE.Mesh(_sharedGeometries.solid.wideNose, noseMat);
                    nose.rotation.x = -Math.PI / 2;
                    nose.position.z = 3.5;
                    group.add(nose);

                    wingMat = getPooledMaterial('phong', { color: 0xcccccc, emissive: 0x333333 });
                    const wings = new THREE.Mesh(_sharedGeometries.solid.wideWing, wingMat);
                    group.add(wings);

                    const tailFin = new THREE.Mesh(_sharedGeometries.solid.tailFin, wingMat);
                    tailFin.scale.set(1.3, 1.5, 1.3);
                    tailFin.position.set(0, 0.9, -2.5);
                    group.add(tailFin);

                    const engineMat = getPooledMaterial('phong', { color: 0x444444 });
                    [-2.2, -1.1, 1.1, 2.2].forEach(xPos => {
                        const engine = new THREE.Mesh(_sharedGeometries.solid.wideEngine, engineMat);
                        engine.rotation.x = Math.PI / 2;
                        engine.position.set(xPos, -0.4, 0.3);
                        group.add(engine);
                    });

                    const lightMat = getPooledMaterial('basic', { color: 0xff0000, transparent: true });
                    positionLight = new THREE.Mesh(_sharedGeometries.solid.light, lightMat);
                    positionLight.position.set(0, 0.4, -2);
                    group.add(positionLight);
                } else if (category === 'military') {
                    // Military aircraft (angular)
                    fuselageMat = getPooledMaterial('phong', { color: 0x556655, emissive: 0x222222 });
                    const fuselage = new THREE.Mesh(_sharedGeometries.solid.milFuselage, fuselageMat);
                    group.add(fuselage);

                    noseMat = getPooledMaterial('phong', { color: 0x445544, emissive: 0x111111 });
                    const nose = new THREE.Mesh(_sharedGeometries.solid.nose, noseMat);
                    nose.scale.set(0.7, 0.5, 1.2);
                    nose.rotation.x = -Math.PI / 2;
                    nose.position.z = 2.8;
                    group.add(nose);

                    wingMat = getPooledMaterial('phong', { color: 0x556655, emissive: 0x222222 });
                    const wings = new THREE.Mesh(_sharedGeometries.solid.milWing, wingMat);
                    wings.scale.set(1.2, 1, 1);
                    group.add(wings);

                    const tail1 = new THREE.Mesh(_sharedGeometries.solid.milTail, wingMat);
                    tail1.position.set(-0.5, 0.4, -2);
                    tail1.rotation.z = 0.3;
                    group.add(tail1);

                    const tail2 = new THREE.Mesh(_sharedGeometries.solid.milTail, wingMat);
                    tail2.position.set(0.5, 0.4, -2);
                    tail2.rotation.z = -0.3;
                    group.add(tail2);

                    const lightMat = getPooledMaterial('basic', { color: 0xff0000, transparent: true });
                    positionLight = new THREE.Mesh(_sharedGeometries.solid.light, lightMat);
                    positionLight.position.set(0, 0.3, -1.8);
                    group.add(positionLight);
                } else {
                    // Default narrow-body jet or regional
                    fuselageMat = getPooledMaterial('phong', { color: 0xffffff, emissive: 0x222222 });
                    const fuselage = new THREE.Mesh(_sharedGeometries.solid.fuselage, fuselageMat);
                    fuselage.rotation.x = Math.PI / 2;
                    group.add(fuselage);

                    noseMat = getPooledMaterial('phong', { color: color, emissive: color, emissiveIntensity: 0.3 });
                    const nose = new THREE.Mesh(_sharedGeometries.solid.nose, noseMat);
                    nose.rotation.x = -Math.PI / 2;
                    nose.position.z = 2.6;
                    group.add(nose);

                    wingMat = getPooledMaterial('phong', { color: 0xcccccc, emissive: 0x333333 });
                    const wings = new THREE.Mesh(_sharedGeometries.solid.wing, wingMat);
                    group.add(wings);

                    const tailFin = new THREE.Mesh(_sharedGeometries.solid.tailFin, wingMat);
                    tailFin.position.set(0, 0.6, -1.8);
                    group.add(tailFin);

                    const hStab = new THREE.Mesh(_sharedGeometries.solid.hStab, wingMat);
                    hStab.position.set(0, 0, -1.8);
                    group.add(hStab);

                    const engineMat = getPooledMaterial('phong', { color: 0x444444 });
                    [-1.2, 1.2].forEach(xPos => {
                        const engine = new THREE.Mesh(_sharedGeometries.solid.engine, engineMat);
                        engine.rotation.x = Math.PI / 2;
                        engine.position.set(xPos, -0.3, 0.2);
                        group.add(engine);
                    });

                    const lightMat = getPooledMaterial('basic', { color: 0xff0000, transparent: true });
                    positionLight = new THREE.Mesh(_sharedGeometries.solid.light, lightMat);
                    positionLight.position.set(0, 0.3, -1.5);
                    group.add(positionLight);
                }

                // Add glow sprite (color matches altitude)
                const glowSprite = createGlowSprite(color, false);
                glowSprite.position.set(0, 0, 0);
                group.add(glowSprite);

                group.userData = {
                    ...data,
                    category: category,
                    noseMaterial: noseMat,
                    wingMaterial: wingMat,
                    fuselageMaterial: fuselageMat,
                    positionLight: positionLight,
                    glowSprite: glowSprite,
                    lightPhase: Math.random() * Math.PI * 2,
                    isWireframe: false
                };
            }

            // Trail - DO NOT add to scene yet, will be managed separately
            group.userData.trail = null;
            group.userData.trailPoints = [];
            group.userData.trailMaterial = null;

            // Altitude line - also deferred
            group.userData.altLine = null;

            // Distance for LOD calculations
            group.userData.distanceToCamera = 0;

            return group;
        }

        // Create trail line for a plane (airloom-style with smooth curves)
        function createTrailForPlane(plane) {
            if (plane.userData.trail) return; // Already has trail

            const isRetro = currentTheme === 'retro';
            const color = isRetro ? 0x00ff00 : getAltitudeColor(plane.userData.altitude || 0);

            // Use larger buffer for smooth trail with many points
            const trailGeom = new THREE.BufferGeometry();
            const maxPoints = 600; // Enough for smooth curves
            const trailPositions = new Float32Array(maxPoints * 3);
            trailGeom.setAttribute('position', new THREE.BufferAttribute(trailPositions, 3));
            trailGeom.setDrawRange(0, 0);

            const trailMat = new THREE.LineBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.8,
                depthTest: true,
                depthWrite: false,
                linewidth: trailThickness
            });

            const trail = new THREE.Line(trailGeom, trailMat);
            trail.frustumCulled = false;
            trail.renderOrder = 999; // Render after most objects
            trail.visible = trailEnabled;
            scene.add(trail);

            plane.userData.trail = trail;
            plane.userData.trailMaterial = trailMat;
        }

        // Create altitude line for a plane
        function createAltLineForPlane(plane) {
            if (plane.userData.altLine) return;

            const isRetro = currentTheme === 'retro';
            const altLineGeom = new THREE.BufferGeometry();
            const altLinePositions = new Float32Array(6);
            altLineGeom.setAttribute('position', new THREE.BufferAttribute(altLinePositions, 3));
            altLineGeom.setDrawRange(0, 0);

            const altLineMat = new THREE.LineDashedMaterial({
                color: isRetro ? 0x00ff00 : 0x888888,
                dashSize: 2,
                gapSize: 1,
                transparent: true,
                opacity: 0.4
            });

            const altLine = new THREE.Line(altLineGeom, altLineMat);
            scene.add(altLine);

            plane.userData.altLine = altLine;
        }

        async function fetchData() {
            try {
                let data;

                if (DataSource.mode === 'global') {
                    // Global mode: fetch from API providers with fallback
                    data = await DataSource.fetchGlobal(centerLat, centerLon);
                } else {
                    // Local mode: fetch from dump1090
                    const response = await fetch(DATA_URL);
                    data = await response.json();
                }

                const now = Date.now();
                const aircraft = data.aircraft || data.ac || [];

                // Normalize: ensure we have a flat array with standard fields
                const normalizedAircraft = DataSource.mode === 'global'
                    ? aircraft  // Already normalized by DataSource
                    : aircraft; // dump1090 format used as-is

                if (normalizedAircraft.length > 0) {
                    if (!centerInitialized) {
                        let sumLat = 0, sumLon = 0, count = 0;
                        normalizedAircraft.forEach(ac => {
                            if (ac.lat && ac.lon) {
                                sumLat += ac.lat;
                                sumLon += ac.lon;
                                count++;
                            }
                        });
                        if (count > 0) {
                            centerLat = sumLat / count;
                            centerLon = sumLon / count;
                            centerInitialized = true;
                            document.getElementById('center-coords').textContent =
                                `${centerLat.toFixed(2)}, ${centerLon.toFixed(2)}`;
                            loadMapTiles();
                        }
                    }

                    // Store data in buffer with timestamp
                    normalizedAircraft.forEach(ac => {
                        if (!ac.lat || !ac.lon) return;

                        const hex = ac.hex || ac.icao24 || '';
                        if (!hex) return;

                        if (!aircraftDataBuffer.has(hex)) {
                            aircraftDataBuffer.set(hex, []);
                        }

                        const buffer = aircraftDataBuffer.get(hex);
                        buffer.push({ timestamp: now, data: {...ac, hex: hex} });

                        // Keep only last 5 seconds of data (longer for global since polling is slower)
                        const bufferWindow = DataSource.mode === 'global' ? 15000 : 5000;
                        while (buffer.length > 0 && buffer[0].timestamp < now - bufferWindow) {
                            buffer.shift();
                        }
                    });

                    // Clean up old aircraft
                    const currentHexes = new Set(normalizedAircraft.map(ac => ac.hex || ac.icao24 || ''));
                    const staleThreshold = DataSource.mode === 'global'
                        ? INTERPOLATION_DELAY + GLOBAL_REFRESH_INTERVAL + 2000
                        : INTERPOLATION_DELAY + 2000;
                    for (const [hex, buffer] of aircraftDataBuffer.entries()) {
                        if (!currentHexes.has(hex) && buffer.length > 0) {
                            const lastEntry = buffer[buffer.length - 1];
                            if (now - lastEntry.timestamp > staleThreshold) {
                                aircraftDataBuffer.delete(hex);
                            }
                        }
                    }

                    document.getElementById('plane-count').textContent = normalizedAircraft.length;
                    document.getElementById('last-update').textContent = new Date().toLocaleTimeString();
                }
            } catch (error) {
                console.error('Error fetching data:', error);
            }
        }

        // Linear interpolation
        function lerp(a, b, t) {
            return a + (b - a) * t;
        }

        // Angle interpolation (handles wraparound)
        function lerpAngle(a, b, t) {
            a = ((a % 360) + 360) % 360;
            b = ((b % 360) + 360) % 360;
            let diff = b - a;
            if (diff > 180) diff -= 360;
            if (diff < -180) diff += 360;
            return a + diff * t;
        }

        // Reusable object for interpolated data to avoid GC
        const _interpolatedData = {
            hex: '', lat: 0, lon: 0, altitude: 0, track: 0, gs: 0, baro_rate: 0, flight: '', squawk: ''
        };

        // Interpolation function - called at 30fps
        function interpolateAircraft() {
            const now = Date.now();
            const targetTime = now - INTERPOLATION_DELAY;

            // Reuse cached set instead of creating new one
            _seenHexes.clear();

            let planesChanged = false;

            for (const [hex, buffer] of aircraftDataBuffer.entries()) {
                if (buffer.length === 0) continue;

                // Find data points to interpolate between
                let before = null;
                let after = null;

                for (let i = 0; i < buffer.length; i++) {
                    if (buffer[i].timestamp <= targetTime) {
                        before = buffer[i];
                    } else {
                        after = buffer[i];
                        break;
                    }
                }

                if (!before && !after) continue;
                if (!before) before = after;
                if (!after) after = before;

                _seenHexes.add(hex);

                // Calculate interpolation factor
                let t = 0;
                if (before !== after && after.timestamp !== before.timestamp) {
                    t = (targetTime - before.timestamp) / (after.timestamp - before.timestamp);
                    t = Math.max(0, Math.min(1, t));
                }

                // Interpolate data - reuse object to avoid GC
                // Note: dump1090 uses 'gs' for ground speed, 'tas' for true airspeed, 'speed' sometimes
                const beforeSpeed = before.data.gs ?? before.data.speed ?? before.data.tas;
                const afterSpeed = after.data.gs ?? after.data.speed ?? after.data.tas;
                const beforeAlt = before.data.altitude ?? before.data.alt_baro ?? before.data.alt_geom ?? 0;
                const afterAlt = after.data.altitude ?? after.data.alt_baro ?? after.data.alt_geom ?? 0;
                // Support multiple vertical rate field names
                const beforeVertRate = before.data.baro_rate ?? before.data.geom_rate ?? before.data.vert_rate ?? 0;
                const afterVertRate = after.data.baro_rate ?? after.data.geom_rate ?? after.data.vert_rate ?? 0;

                // Populate reusable object
                _interpolatedData.hex = hex;
                _interpolatedData.lat = lerp(before.data.lat, after.data.lat, t);
                _interpolatedData.lon = lerp(before.data.lon, after.data.lon, t);
                _interpolatedData.altitude = lerp(beforeAlt, afterAlt, t);
                _interpolatedData.track = lerpAngle(before.data.track || 0, after.data.track || 0, t);
                _interpolatedData.gs = (beforeSpeed !== undefined && afterSpeed !== undefined) ? lerp(beforeSpeed, afterSpeed, t) : (afterSpeed ?? beforeSpeed);
                _interpolatedData.baro_rate = lerp(beforeVertRate, afterVertRate, t);
                _interpolatedData.flight = after.data.flight || before.data.flight || '';
                _interpolatedData.squawk = after.data.squawk || before.data.squawk || '';

                let plane = airplanes.get(hex);

                if (plane) {
                    // Update existing plane
                    const pos = latLonToXZ(_interpolatedData.lat, _interpolatedData.lon);
                    const alt = _interpolatedData.altitude * altitudeScale;

                    // Store previous position for trail BEFORE updating
                    const prevX = plane.position.x;
                    const prevY = plane.position.y;
                    const prevZ = plane.position.z;

                    // Update position FIRST
                    plane.position.set(pos.x, alt, pos.z);

                    // Update heading
                    if (_interpolatedData.track !== undefined) {
                        plane.rotation.y = (-_interpolatedData.track * Math.PI / 180) + Math.PI;
                    }

                    // Mark plane as initialized after first real position update
                    if (!plane.userData.positionInitialized) {
                        plane.userData.positionInitialized = true;
                        plane.userData.initTime = now;
                    }

                    // Add trail point using lat/lon coordinates (not world coords)
                    // This ensures trails remain valid when map bounds change
                    const timeSinceInit = now - (plane.userData.initTime || now);
                    if (trailEnabled && timeSinceInit > 500) {
                        if (now - (plane.userData.lastTrailTime || 0) > 100) {
                            plane.userData.lastTrailTime = now;

                            // Store as lat/lon/alt - these are stable coordinates
                            const lastPoint = plane.userData.trailPoints[plane.userData.trailPoints.length - 1];
                            const currentLat = plane.userData.lat;
                            const currentLon = plane.userData.lon;
                            const currentAlt = plane.userData.altitude;

                            // Only add if we have valid coordinates and position changed
                            if (currentLat && currentLon) {
                                const dominated = lastPoint &&
                                    Math.abs(lastPoint.lat - currentLat) < 0.0001 &&
                                    Math.abs(lastPoint.lon - currentLon) < 0.0001;

                                if (!dominated) {
                                    plane.userData.trailPoints.push({
                                        lat: currentLat,
                                        lon: currentLon,
                                        alt: currentAlt || 0,
                                        time: now
                                    });
                                    // Keep only the max trail length (airloom-style)
                                    while (plane.userData.trailPoints.length > trailMaxLength) {
                                        plane.userData.trailPoints.shift();
                                    }
                                    // Queue trail update for batching instead of immediate update
                                    if (_trailUpdateQueue.indexOf(plane) === -1) {
                                        _trailUpdateQueue.push(plane);
                                    }
                                }
                            }
                        }
                    }

                    // Update altitude line
                    updateAltitudeLine(plane);

                    // Update colors
                    const newColor = getAltitudeColor(_interpolatedData.altitude);
                    if (plane.userData.noseMaterial) {
                        plane.userData.noseMaterial.color.setHex(newColor);
                        plane.userData.noseMaterial.emissive.setHex(newColor);
                    }
                    if (plane.userData.trailMaterial && currentTheme !== 'retro') {
                        plane.userData.trailMaterial.color.setHex(newColor);
                    }
                    // Update glow color for day/night themes (retro stays green)
                    if (plane.userData.glowSprite && currentTheme !== 'retro') {
                        plane.userData.glowSprite.material.color.setHex(newColor);
                    }

                    // Update userData without creating new object
                    plane.userData.hex = _interpolatedData.hex;
                    plane.userData.lat = _interpolatedData.lat;
                    plane.userData.lon = _interpolatedData.lon;
                    plane.userData.altitude = _interpolatedData.altitude;
                    plane.userData.track = _interpolatedData.track;
                    plane.userData.gs = _interpolatedData.gs;
                    plane.userData.baro_rate = _interpolatedData.baro_rate;
                    plane.userData.flight = _interpolatedData.flight;
                    plane.userData.squawk = _interpolatedData.squawk;
                } else {
                    // Create new plane - need to copy data since we're reusing _interpolatedData
                    const newPlaneData = {
                        hex: _interpolatedData.hex,
                        lat: _interpolatedData.lat,
                        lon: _interpolatedData.lon,
                        altitude: _interpolatedData.altitude,
                        track: _interpolatedData.track,
                        gs: _interpolatedData.gs,
                        baro_rate: _interpolatedData.baro_rate,
                        flight: _interpolatedData.flight,
                        squawk: _interpolatedData.squawk
                    };

                    plane = createAirplane(newPlaneData);
                    const pos = latLonToXZ(newPlaneData.lat, newPlaneData.lon);
                    const alt = newPlaneData.altitude * altitudeScale;

                    // Set position immediately so plane never appears at origin
                    plane.position.set(pos.x, alt, pos.z);

                    if (newPlaneData.track !== undefined) {
                        plane.rotation.y = (-newPlaneData.track * Math.PI / 180) + Math.PI;
                    }

                    // Mark as initialized with current time - trails won't record for 500ms
                    plane.userData.positionInitialized = true;
                    plane.userData.initTime = now;

                    scene.add(plane);
                    airplanes.set(hex, plane);
                    planesChanged = true;

                    // Load trail history from DB
                    loadTrailFromDb(hex, (trailData) => {
                        if (trailData && trailData.points && trailData.points.length > 0 && trailEnabled) {
                            // Restore trail points (limit to max length)
                            plane.userData.trailPoints = trailData.points.slice(-trailMaxLength);
                            updateTrail(plane);
                        }
                    });

                    // Create altitude line after plane is positioned
                    createAltLineForPlane(plane);
                    updateAltitudeLine(plane);
                }
            }

            // Remove planes no longer in data
            for (const [hex, plane] of airplanes.entries()) {
                if (!_seenHexes.has(hex)) {
                    scene.remove(plane);
                    if (plane.userData.trail) scene.remove(plane.userData.trail);
                    if (plane.userData.altLine) scene.remove(plane.userData.altLine);
                    airplanes.delete(hex);
                    planesChanged = true;
                }
            }

            // Mark cached array as dirty if planes were added/removed
            if (planesChanged) {
                _airplanesArrayDirty = true;
            }
        }

        function updateAltitudeLine(plane) {
            if (!plane.userData.altLine) {
                createAltLineForPlane(plane);
            }

            const altLine = plane.userData.altLine;
            if (!altLine) return;

            // Only draw if plane has valid position
            const absX = plane.position.x < 0 ? -plane.position.x : plane.position.x;
            const absZ = plane.position.z < 0 ? -plane.position.z : plane.position.z;
            if (absX < 0.1 && absZ < 0.1) {
                altLine.geometry.setDrawRange(0, 0);
                return;
            }

            const positions = altLine.geometry.attributes.position.array;
            positions[0] = plane.position.x;
            positions[1] = plane.position.y;
            positions[2] = plane.position.z;
            positions[3] = plane.position.x;
            positions[4] = 0;
            positions[5] = plane.position.z;

            altLine.geometry.attributes.position.needsUpdate = true;
            altLine.geometry.setDrawRange(0, 2);

            // Throttle computeLineDistances - only recompute every 500ms
            const now = Date.now();
            if (!plane.userData._lastLineDistTime || now - plane.userData._lastLineDistTime > 500) {
                plane.userData._lastLineDistTime = now;
                altLine.computeLineDistances();
            }
        }

        function updateAllAircraftPositions() {
            // Use cached array
            if (_airplanesArrayDirty) {
                _airplanesArray = Array.from(airplanes.values());
                _airplanesArrayDirty = false;
            }
            for (let i = 0, len = _airplanesArray.length; i < len; i++) {
                const plane = _airplanesArray[i];
                if (plane.userData.lat && plane.userData.lon) {
                    const pos = latLonToXZ(plane.userData.lat, plane.userData.lon);
                    const alt = (plane.userData.altitude || 0) * altitudeScale;
                    plane.position.set(pos.x, alt, pos.z);
                    updateAltitudeLine(plane);
                    // Update trail world positions when map shifts
                    if (plane.userData.trail && plane.userData.trailPoints.length >= 2) {
                        updateTrail(plane);
                    }
                }
            }
            updateLabels();
            _needsRender = true;
        }

        function updateTrail(plane) {
            const points = plane.userData.trailPoints;

            // Need at least 2 valid points to draw a trail
            if (points.length < 2) {
                if (plane.userData.trail) {
                    plane.userData.trail.geometry.setDrawRange(0, 0);
                }
                return;
            }

            // Create trail if needed
            if (!plane.userData.trail) {
                createTrailForPlane(plane);
            }

            const trail = plane.userData.trail;
            if (!trail) return;

            const positions = trail.geometry.attributes.position.array;

            // Convert lat/lon trail points to world coordinates
            const worldPoints = [];
            const maxPoints = Math.min(points.length, trailMaxLength);

            for (let i = 0; i < maxPoints; i++) {
                const pt = points[points.length - maxPoints + i];
                if (pt && pt.lat !== undefined && pt.lon !== undefined) {
                    const worldPos = latLonToXZ(pt.lat, pt.lon);
                    const alt = (pt.alt || 0) * altitudeScale;
                    worldPoints.push(new THREE.Vector3(worldPos.x, alt, worldPos.z));
                }
            }

            // Add current plane position as the final point
            if (plane.userData.lat && plane.userData.lon) {
                worldPoints.push(new THREE.Vector3(plane.position.x, plane.position.y, plane.position.z));
            }

            if (worldPoints.length < 2) {
                trail.geometry.setDrawRange(0, 0);
                return;
            }

            // Use Catmull-Rom curve for smooth interpolation (airloom-style)
            let smoothPoints;
            if (worldPoints.length >= 3) {
                try {
                    const curve = new THREE.CatmullRomCurve3(worldPoints, false, 'centripetal', 0.5);
                    // Get more points for smoother curve (2 per original point)
                    const numSmoothPoints = Math.min(worldPoints.length * 2, 500);
                    smoothPoints = curve.getPoints(numSmoothPoints);
                } catch (e) {
                    // Fallback to original points if curve fails
                    smoothPoints = worldPoints;
                }
            } else {
                smoothPoints = worldPoints;
            }

            // Fill position buffer with smooth points
            const validCount = Math.min(smoothPoints.length, 600);
            for (let i = 0; i < validCount; i++) {
                const pt = smoothPoints[i];
                const idx = i * 3;
                positions[idx] = pt.x;
                positions[idx + 1] = pt.y;
                positions[idx + 2] = pt.z;
            }

            // Update trail color based on current altitude
            if (plane.userData.trailMaterial && trailColorMode === 'altitude') {
                const isRetro = currentTheme === 'retro';
                const newColor = isRetro ? 0x00ff00 : getAltitudeColor(plane.userData.altitude || 0);
                plane.userData.trailMaterial.color.setHex(newColor);
            }

            trail.geometry.attributes.position.needsUpdate = true;
            trail.geometry.setDrawRange(0, validCount);
            _needsRender = true;

            // Save trail to DB periodically (every 10 seconds)
            if (!plane.userData.lastTrailSave || Date.now() - plane.userData.lastTrailSave > 10000) {
                plane.userData.lastTrailSave = Date.now();
                saveTrailToDb(plane.userData.hex, plane.userData.trailPoints, plane.userData.lat, plane.userData.lon);
            }
        }

        // Get vertical speed arrow character and size
        // baro_rate is in ft/min, we need to convert to m/s for sizing
        // 2 m/s = 393.7 ft/min (minimum threshold)
        // 20 m/s = 3937 ft/min (maximum size)
        function getVerticalSpeedArrow(baroRate) {
            if (baroRate === undefined || baroRate === null) return null;

            // Convert ft/min to m/s (divide by 196.85)
            const vertSpeedMs = Math.abs(baroRate) / 196.85;

            // Ignore vertical speeds below 2 m/s
            if (vertSpeedMs < 2) return null;

            // Cap at 20 m/s for sizing
            const clampedSpeed = Math.min(vertSpeedMs, 20);

            // Scale arrow size: 2 m/s -> 16px, 20 m/s -> 48px (linear)
            const arrowSize = 16 + ((clampedSpeed - 2) / 18) * 32;

            const arrow = baroRate > 0 ? '↑' : '↓';
            const color = baroRate > 0 ? '#44ff44' : '#ff6644';

            return { arrow, size: arrowSize, color };
        }

        // Get a canvas from pool or create new one
        function _getPooledCanvas() {
            if (_labelCanvasPool.length > 0) {
                return _labelCanvasPool.pop();
            }
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 80;
            return canvas;
        }

        // Return canvas to pool
        function _returnCanvasToPool(canvas) {
            if (_labelCanvasPool.length < MAX_LABEL_POOL_SIZE) {
                _labelCanvasPool.push(canvas);
            }
        }

        // Render label content to canvas
        function _renderLabelToCanvas(ctx, plane) {
            // Clear canvas
            ctx.clearRect(0, 0, 256, 80);

            if (currentTheme === 'retro') {
                ctx.fillStyle = 'rgba(0, 20, 0, 0.9)';
                ctx.strokeStyle = '#00ff00';
                ctx.lineWidth = 2;
            } else {
                ctx.fillStyle = 'rgba(0, 20, 40, 0.85)';
            }
            ctx.beginPath();
            ctx.roundRect(0, 0, 256, 80, 8);
            ctx.fill();
            if (currentTheme === 'retro') ctx.stroke();

            ctx.fillStyle = currentTheme === 'retro' ? '#00ff00' : '#00ffff';
            ctx.font = 'bold 22px monospace';
            const callsign = plane.userData.flight || plane.userData.hex || 'Unknown';
            ctx.fillText(callsign.trim(), 10, 28);

            ctx.fillStyle = currentTheme === 'retro' ? '#00cc00' : '#88ff88';
            ctx.font = '16px monospace';
            ctx.fillText(formatAltitude(plane.userData.altitude || 0), 10, 50);

            if (plane.userData.gs !== undefined && plane.userData.gs !== null) {
                ctx.fillStyle = currentTheme === 'retro' ? '#00aa00' : '#ffaa00';
                ctx.fillText(formatSpeed(plane.userData.gs), 10, 70);
            }

            // Draw vertical speed arrow on the right side
            const arrowInfo = getVerticalSpeedArrow(plane.userData.baro_rate);
            if (arrowInfo) {
                ctx.fillStyle = currentTheme === 'retro' ? '#00ff00' : arrowInfo.color;
                ctx.font = `bold ${Math.round(arrowInfo.size)}px sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(arrowInfo.arrow, 230, 40);
                ctx.textAlign = 'left';
                ctx.textBaseline = 'alphabetic';
            }
        }

        function updateLabels() {
            // Return old canvases to pool and collect sprites for reuse
            const oldSprites = [];
            for (let i = 0; i < labels.length; i++) {
                const label = labels[i];
                scene.remove(label);
                // Return canvas to pool if it exists
                if (label.material && label.material.map && label.material.map.image) {
                    _returnCanvasToPool(label.material.map.image);
                }
                oldSprites.push(label);
            }
            labels.length = 0;

            // Clear label references from planes
            if (_airplanesArrayDirty) {
                _airplanesArray = Array.from(airplanes.values());
                _airplanesArrayDirty = false;
            }
            for (let i = 0; i < _airplanesArray.length; i++) {
                _airplanesArray[i].userData.label = null;
            }

            if (!showLabels) return;

            let spriteIndex = 0;
            for (let i = 0; i < _airplanesArray.length; i++) {
                const plane = _airplanesArray[i];

                // Skip labels for distant aircraft (LOD culling)
                const dist = plane.userData.distanceToCamera || 0;
                if (dist > LOD_DISTANCE_CULL) {
                    plane.userData.label = null;
                    continue;
                }

                const canvas = _getPooledCanvas();
                const ctx = canvas.getContext('2d');

                _renderLabelToCanvas(ctx, plane);

                let sprite;
                if (spriteIndex < oldSprites.length) {
                    // Reuse existing sprite
                    sprite = oldSprites[spriteIndex];
                    sprite.material.map.image = canvas;
                    sprite.material.map.needsUpdate = true;
                } else {
                    // Create new sprite
                    const texture = new THREE.CanvasTexture(canvas);
                    const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
                    sprite = new THREE.Sprite(material);
                    sprite.scale.set(15, 4.7, 1);
                }
                spriteIndex++;

                sprite.position.copy(plane.position);
                sprite.position.y += 8;
                sprite.visible = true;

                // Scale labels based on distance
                if (dist > LOD_DISTANCE_FAR) {
                    const scale = 1 - (dist - LOD_DISTANCE_FAR) / (LOD_DISTANCE_CULL - LOD_DISTANCE_FAR) * 0.4;
                    sprite.scale.set(15 * scale, 4.7 * scale, 1);
                } else {
                    sprite.scale.set(15, 4.7, 1);
                }

                // Store reference to label on the plane for correct position updates
                plane.userData.label = sprite;

                scene.add(sprite);
                labels.push(sprite);
            }

            // Dispose unused old sprites
            for (let i = spriteIndex; i < oldSprites.length; i++) {
                const sprite = oldSprites[i];
                if (sprite.material) {
                    if (sprite.material.map) sprite.material.map.dispose();
                    sprite.material.dispose();
                }
            }
        }

        // Camera controls
        function setupControls() {
            renderer.domElement.addEventListener('mousedown', (e) => {
                isDragging = true;
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });

            renderer.domElement.addEventListener('mousemove', (e) => {
                if (!isDragging) return;

                const deltaX = e.clientX - previousMousePosition.x;
                const deltaY = e.clientY - previousMousePosition.y;

                cameraAngle += deltaX * 0.01;
                cameraHeight = Math.max(10, Math.min(300, cameraHeight - deltaY * 0.5));

                updateCameraPosition();
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });

            renderer.domElement.addEventListener('mouseup', () => isDragging = false);
            renderer.domElement.addEventListener('mouseleave', () => isDragging = false);

            renderer.domElement.addEventListener('wheel', (e) => {
                cameraDistance = Math.max(30, Math.min(500, cameraDistance + e.deltaY * 0.2));
                updateCameraPosition();
                _needsRender = true;
            });
        }

        function updateCameraPosition() {
            camera.position.x = Math.sin(cameraAngle) * cameraDistance;
            camera.position.z = Math.cos(cameraAngle) * cameraDistance;
            camera.position.y = cameraHeight;
            camera.lookAt(0, cameraHeight * 0.2, 0);
            _needsRender = true;
        }

        function resetCamera() {
            cameraAngle = 0;
            cameraHeight = 80;
            cameraDistance = 150;
            updateCameraPosition();
        }

        function cameraZoomIn() {
            cameraDistance = Math.max(30, cameraDistance - 20);
            updateCameraPosition();
        }

        function cameraZoomOut() {
            cameraDistance = Math.min(500, cameraDistance + 20);
            updateCameraPosition();
        }

        // Smooth rotation
        let rotateDirection = null;
        let rotateInterval = null;

        function startRotate(direction) {
            rotateDirection = direction;
            if (rotateInterval) clearInterval(rotateInterval);
            rotateInterval = setInterval(() => {
                if (rotateDirection === 'left') {
                    cameraAngle -= 0.02;
                } else if (rotateDirection === 'right') {
                    cameraAngle += 0.02;
                }
                updateCameraPosition();
            }, 16);
        }

        function stopRotate() {
            rotateDirection = null;
            if (rotateInterval) {
                clearInterval(rotateInterval);
                rotateInterval = null;
            }
        }

        function toggleAutoRotate() {
            autoRotate = !autoRotate;
            document.getElementById('btn-rotate').classList.toggle('active', autoRotate);
            saveSettings();
        }

        function toggleLabels() {
            showLabels = !showLabels;
            document.getElementById('btn-labels').classList.toggle('active', showLabels);
            updateLabels();
            saveSettings();
        }

        function onMouseClick(event) {
            // Reuse cached objects to avoid GC pressure
            _mouseVec.x = (event.clientX / window.innerWidth) * 2 - 1;
            _mouseVec.y = -(event.clientY / window.innerHeight) * 2 + 1;

            _raycaster.setFromCamera(_mouseVec, camera);

            // Use cached array if available
            if (_airplanesArrayDirty) {
                _airplanesArray = Array.from(airplanes.values());
                _airplanesArrayDirty = false;
            }
            const intersects = _raycaster.intersectObjects(_airplanesArray, true);

            if (intersects.length > 0) {
                let plane = intersects[0].object;
                while (plane.parent && !plane.userData.hex) {
                    plane = plane.parent;
                }
                if (plane.userData.hex) {
                    selectPlane(plane);
                }
            } else {
                deselectPlane();
            }
            _needsRender = true;
        }

        function selectPlane(plane) {
            selectedPlane = plane;
            const panel = document.getElementById('selected-plane');
            panel.style.display = 'block';

            document.getElementById('sel-callsign').textContent = plane.userData.flight || plane.userData.hex || '--';
            document.getElementById('sel-altitude').textContent = formatAltitude(plane.userData.altitude || 0);
            document.getElementById('sel-speed').textContent = (plane.userData.gs !== undefined && plane.userData.gs !== null) ? formatSpeed(plane.userData.gs) : '--';
            document.getElementById('sel-track').textContent = (plane.userData.track || '--') + '°';
            document.getElementById('sel-vertrate').textContent = plane.userData.baro_rate ? formatVertRate(plane.userData.baro_rate) : '--';
            document.getElementById('sel-squawk').textContent = plane.userData.squawk || '--';
            document.getElementById('sel-position').textContent =
                `${(plane.userData.lat || 0).toFixed(4)}°, ${(plane.userData.lon || 0).toFixed(4)}°`;

            // Fetch and display enriched aircraft information
            updateEnrichedInfo(plane);
        }

        function deselectPlane() {
            selectedPlane = null;
            followSelectedPlane = false;
            document.getElementById('selected-plane').style.display = 'none';
            document.getElementById('aircraft-enriched-info').classList.remove('visible');
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            _needsRender = true;
        }

        let time = 0;
        let lastLabelUpdate = 0;
        const INTERPOLATION_INTERVAL = 1000 / INTERPOLATION_FPS;

        // Update tile fade animations
        function updateTileFades(now) {
            let anyFading = false;
            const FADE_DURATION = 200; // ms

            for (let i = 0; i < mapTiles.length; i++) {
                const tile = mapTiles[i];
                if (!tile.material) continue;

                if (tile.userData.fadeIn) {
                    const elapsed = now - tile.userData.fadeStart;
                    const progress = Math.min(elapsed / FADE_DURATION, 1);
                    tile.material.opacity = progress;

                    if (progress >= 1) {
                        tile.userData.fadeIn = false;
                        tile.material.transparent = false;
                        tile.material.opacity = 1;
                    } else {
                        anyFading = true;
                    }
                    tile.material.needsUpdate = true;
                }

                if (tile.userData.fadeOut) {
                    const elapsed = now - tile.userData.fadeStart;
                    const progress = Math.min(elapsed / (FADE_DURATION * 0.75), 1);
                    tile.material.opacity = 1 - progress;
                    tile.material.needsUpdate = true;
                    anyFading = true;
                }
            }

            return anyFading;
        }

        // Calculate distance from camera to plane for LOD
        function updateDistances() {
            const camPos = camera.position;
            for (let i = 0, len = _airplanesArray.length; i < len; i++) {
                const plane = _airplanesArray[i];
                const dx = plane.position.x - camPos.x;
                const dy = plane.position.y - camPos.y;
                const dz = plane.position.z - camPos.z;
                plane.userData.distanceToCamera = Math.sqrt(dx * dx + dy * dy + dz * dz);
            }
        }

        function animate() {
            requestAnimationFrame(animate);

            // Skip rendering when tab is not visible to save CPU/power
            if (!_isTabVisible) return;

            const now = Date.now();
            time += 0.016;

            // Update map transitions
            const isTransitioning = updateMapTransition();
            if (isTransitioning) _needsRender = true;

            // Run interpolation at 30fps
            if (now - lastInterpolationTime >= INTERPOLATION_INTERVAL) {
                lastInterpolationTime = now;
                interpolateAircraft();
                _needsRender = true;
            }

            if (autoRotate) {
                cameraAngle += 0.002;
                updateCameraPosition();
                _needsRender = true;
            }

            // Update tile fade animations
            if (updateTileFades(now)) {
                _needsRender = true;
            }

            // Update cached array if needed
            if (_airplanesArrayDirty) {
                _airplanesArray = Array.from(airplanes.values());
                _airplanesArrayDirty = false;
            }

            // Update distances for LOD (every few frames)
            if ((now % 3) === 0) {
                updateDistances();
            }

            const needsLabelRedraw = now - lastLabelUpdate > 1000;
            const updateLabelPositions = !needsLabelRedraw && showLabels;

            // Single combined loop for lights, rotors, and label positions
            let anyLightChange = false;
            for (let i = 0, len = _airplanesArray.length; i < len; i++) {
                const plane = _airplanesArray[i];

                // Animate position lights
                if (plane.userData.positionLight) {
                    plane.userData.lightPhase += 0.08;
                    const brightness = Math.sin(plane.userData.lightPhase) > 0.7 ? 1 : 0.2;
                    const currentOpacity = plane.userData.positionLight.material.opacity;

                    // Only update if brightness changed significantly
                    if (Math.abs(currentOpacity - brightness) > 0.3) {
                        plane.userData.positionLight.material.opacity = brightness;
                        anyLightChange = true;
                    }
                }

                // Animate glow sprite (subtle pulsing synced with position lights)
                if (plane.userData.glowSprite) {
                    const glowPulse = 0.3 + 0.15 * Math.sin(plane.userData.lightPhase * 0.5);
                    const glowScale = 7 + 1.5 * Math.sin(plane.userData.lightPhase * 0.3);
                    plane.userData.glowSprite.material.opacity = glowPulse;
                    plane.userData.glowSprite.scale.set(glowScale, glowScale, 1);
                    anyLightChange = true;
                }

                // Animate rotors and propellers
                if (plane.userData.category === 'helicopter' || plane.userData.category === 'small') {
                    plane.children.forEach(child => {
                        if (child.userData && child.userData.isRotor) {
                            child.rotation.y += 0.5; // Fast rotation for helicopter rotor
                            anyLightChange = true;
                        }
                        if (child.userData && child.userData.isProp) {
                            child.rotation.z += 0.4; // Propeller rotation
                            anyLightChange = true;
                        }
                    });
                }

                // Update label positions between full redraws
                if (updateLabelPositions && plane.userData.label) {
                    // Distance-based label culling
                    const dist = plane.userData.distanceToCamera || 0;
                    if (dist > LOD_DISTANCE_CULL) {
                        plane.userData.label.visible = false;
                    } else {
                        plane.userData.label.visible = true;
                        plane.userData.label.position.x = plane.position.x;
                        plane.userData.label.position.y = plane.position.y + 8;
                        plane.userData.label.position.z = plane.position.z;

                        // Scale labels based on distance
                        if (dist > LOD_DISTANCE_FAR) {
                            const scale = 1 - (dist - LOD_DISTANCE_FAR) / (LOD_DISTANCE_CULL - LOD_DISTANCE_FAR) * 0.4;
                            plane.userData.label.scale.set(15 * scale, 4.7 * scale, 1);
                        }
                    }
                }
            }

            if (anyLightChange) _needsRender = true;

            // Update labels periodically - redraw every 1 second to update speed/altitude
            if (needsLabelRedraw) {
                lastLabelUpdate = now;
                updateLabels();
                _needsRender = true;

                if (selectedPlane && airplanes.has(selectedPlane.userData.hex)) {
                    selectPlane(airplanes.get(selectedPlane.userData.hex));
                }
            }

            // Process batched trail updates
            if (now - _lastBatchTrailUpdate >= BATCH_TRAIL_INTERVAL && _trailUpdateQueue.length > 0) {
                _lastBatchTrailUpdate = now;
                const batch = _trailUpdateQueue.splice(0, 10); // Process 10 at a time
                for (let i = 0; i < batch.length; i++) {
                    updateTrail(batch[i]);
                }
                _needsRender = true;
            }

            // Update stats panel (every 2 seconds)
            if (showStats && (now % 2000) < 100) {
                updateStatsPanel();
            }

            // Update follow mode
            updateFollowMode();

            // Render only when needed (or throttle to max fps)
            if (_needsRender || now - _renderThrottleTime > RENDER_THROTTLE_MS) {
                renderer.render(scene, camera);
                _renderThrottleTime = now;
                _needsRender = false;
            }
        }

        // ===========================================
        // KEYBOARD SHORTCUTS
        // ===========================================
        function setupKeyboardShortcuts() {
            document.addEventListener('keydown', (e) => {
                // Ignore if typing in an input
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;

                const key = e.key.toLowerCase();

                // Help overlay toggle
                if (key === '?' || (key === '/' && e.shiftKey)) {
                    toggleKeyboardHelp();
                    e.preventDefault();
                    return;
                }

                // Close help or deselect with Escape
                if (key === 'escape') {
                    if (document.getElementById('keyboard-help').classList.contains('visible')) {
                        toggleKeyboardHelp();
                    } else if (selectedPlane) {
                        deselectPlane();
                    }
                    e.preventDefault();
                    return;
                }

                // Navigation - Arrow keys for map pan
                if (key === 'arrowup') { panMap('up'); e.preventDefault(); }
                if (key === 'arrowdown') { panMap('down'); e.preventDefault(); }
                if (key === 'arrowleft') { panMap('left'); e.preventDefault(); }
                if (key === 'arrowright') { panMap('right'); e.preventDefault(); }

                // Camera zoom
                if (key === '+' || key === '=') { cameraZoomIn(); e.preventDefault(); }
                if (key === '-' || key === '_') { cameraZoomOut(); e.preventDefault(); }

                // Camera rotate
                if (key === '[') { cameraAngle -= 0.1; updateCameraPosition(); e.preventDefault(); }
                if (key === ']') { cameraAngle += 0.1; updateCameraPosition(); e.preventDefault(); }

                // Reset camera
                if (key === 'r' && !e.ctrlKey && !e.metaKey) { resetCamera(); e.preventDefault(); }

                // Map zoom with M key
                if (key === 'm') {
                    // Wait for next key
                    const handleMapZoom = (e2) => {
                        if (e2.key === '+' || e2.key === '=') mapZoomIn();
                        if (e2.key === '-' || e2.key === '_') mapZoomOut();
                        document.removeEventListener('keydown', handleMapZoom);
                    };
                    document.addEventListener('keydown', handleMapZoom, { once: true });
                    e.preventDefault();
                }

                // Toggle labels
                if (key === 'l') { toggleLabels(); e.preventDefault(); }

                // Toggle graphs
                if (key === 'g') { toggleGraphs(); e.preventDefault(); }

                // Toggle auto-rotate
                if (key === 'a') { toggleAutoRotate(); e.preventDefault(); }

                // Toggle trails
                if (key === 't' && !e.ctrlKey) { toggleTrails(); e.preventDefault(); }

                // Clear all trails
                if (key === 'c' && !e.ctrlKey && !e.metaKey) { clearAllTrails(); e.preventDefault(); }

                // Toggle stats panel
                if (key === 's') { toggleStats(); e.preventDefault(); }

                // Theme switching
                if (key === '1') { changeTheme('day'); e.preventDefault(); }
                if (key === '2') { changeTheme('night'); e.preventDefault(); }
                if (key === '3') { changeTheme('retro'); e.preventDefault(); }

                // Aircraft selection with Tab
                if (key === 'tab') {
                    e.preventDefault();
                    selectNextAircraft(e.shiftKey ? -1 : 1);
                }

                // Follow selected aircraft
                if (key === 'f' && selectedPlane) {
                    followSelectedPlane = !followSelectedPlane;
                    e.preventDefault();
                }
            });
        }

        function toggleKeyboardHelp() {
            const help = document.getElementById('keyboard-help');
            help.classList.toggle('visible');
        }

        function selectNextAircraft(direction) {
            if (_airplanesArrayDirty) {
                _airplanesArray = Array.from(airplanes.values());
                _airplanesArrayDirty = false;
            }
            if (_airplanesArray.length === 0) return;

            let currentIndex = -1;
            if (selectedPlane) {
                currentIndex = _airplanesArray.findIndex(p => p.userData.hex === selectedPlane.userData.hex);
            }

            let nextIndex = currentIndex + direction;
            if (nextIndex < 0) nextIndex = _airplanesArray.length - 1;
            if (nextIndex >= _airplanesArray.length) nextIndex = 0;

            selectPlane(_airplanesArray[nextIndex]);
        }

        // ===========================================
        // MOBILE TOUCH CONTROLS
        // ===========================================
        function setupTouchControls() {
            const canvas = renderer.domElement;

            canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
            canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
            canvas.addEventListener('touchend', handleTouchEnd, { passive: false });
        }

        function handleTouchStart(e) {
            if (e.touches.length === 2) {
                e.preventDefault();
                isTwoFingerGesture = true;

                // Calculate initial distance and angle for pinch/rotate
                const dx = e.touches[1].clientX - e.touches[0].clientX;
                const dy = e.touches[1].clientY - e.touches[0].clientY;
                touchStartDistance = Math.sqrt(dx * dx + dy * dy);
                touchStartAngle = Math.atan2(dy, dx);

                // Store center point
                lastTouchCenter = {
                    x: (e.touches[0].clientX + e.touches[1].clientX) / 2,
                    y: (e.touches[0].clientY + e.touches[1].clientY) / 2
                };
            } else if (e.touches.length === 1) {
                isTwoFingerGesture = false;
                previousMousePosition = {
                    x: e.touches[0].clientX,
                    y: e.touches[0].clientY
                };
            }
        }

        function handleTouchMove(e) {
            if (e.touches.length === 2 && isTwoFingerGesture) {
                e.preventDefault();

                const dx = e.touches[1].clientX - e.touches[0].clientX;
                const dy = e.touches[1].clientY - e.touches[0].clientY;
                const currentDistance = Math.sqrt(dx * dx + dy * dy);
                const currentAngle = Math.atan2(dy, dx);

                // Pinch to zoom
                const distanceRatio = currentDistance / touchStartDistance;
                if (Math.abs(distanceRatio - 1) > 0.01) {
                    const zoomDelta = (1 - distanceRatio) * 50;
                    cameraDistance = Math.max(30, Math.min(500, cameraDistance + zoomDelta));
                    touchStartDistance = currentDistance;
                    updateCameraPosition();
                }

                // Two-finger rotate
                const angleDelta = currentAngle - touchStartAngle;
                if (Math.abs(angleDelta) > 0.01) {
                    cameraAngle += angleDelta;
                    touchStartAngle = currentAngle;
                    updateCameraPosition();
                }

                // Two-finger pan
                const currentCenter = {
                    x: (e.touches[0].clientX + e.touches[1].clientX) / 2,
                    y: (e.touches[0].clientY + e.touches[1].clientY) / 2
                };
                const panDeltaX = currentCenter.x - lastTouchCenter.x;
                const panDeltaY = currentCenter.y - lastTouchCenter.y;

                if (Math.abs(panDeltaX) > 10) {
                    panMap(panDeltaX > 0 ? 'right' : 'left');
                    lastTouchCenter.x = currentCenter.x;
                }
                if (Math.abs(panDeltaY) > 10) {
                    panMap(panDeltaY > 0 ? 'down' : 'up');
                    lastTouchCenter.y = currentCenter.y;
                }

                _needsRender = true;
            } else if (e.touches.length === 1 && !isTwoFingerGesture) {
                // Single finger drag for camera orbit
                const deltaX = e.touches[0].clientX - previousMousePosition.x;
                const deltaY = e.touches[0].clientY - previousMousePosition.y;

                cameraAngle += deltaX * 0.01;
                cameraHeight = Math.max(10, Math.min(300, cameraHeight - deltaY * 0.5));

                updateCameraPosition();
                previousMousePosition = {
                    x: e.touches[0].clientX,
                    y: e.touches[0].clientY
                };
            }
        }

        function handleTouchEnd(e) {
            if (e.touches.length < 2) {
                isTwoFingerGesture = false;
            }
            if (e.touches.length === 1) {
                previousMousePosition = {
                    x: e.touches[0].clientX,
                    y: e.touches[0].clientY
                };
            }
        }

        // ===========================================
        // STATS PANEL FUNCTIONS (integrated in info-panel)
        // ===========================================
        window.toggleTerrain = function() {
            terrainEnabled = !terrainEnabled;
            document.getElementById('btn-terrain').classList.toggle('active', terrainEnabled);
            if (terrainEnabled) {
                TerrainSystem.loadTerrainTiles();
            } else {
                // Remove all terrain meshes
                for (let i = 0; i < terrainTiles.length; i++) {
                    scene.remove(terrainTiles[i]);
                }
                terrainTiles = [];
            }
            _needsRender = true;
        };

        window.toggleStats = function() {
            showStats = !showStats;
            const section = document.getElementById('stats-section');
            const btn = document.getElementById('btn-stats');

            if (showStats) {
                section.classList.add('visible');
                btn.classList.add('active');
                updateStatsPanel();
            } else {
                section.classList.remove('visible');
                btn.classList.remove('active');
            }
        };

        function updateStatsPanel() {
            if (!showStats) return;

            // Update unique aircraft count
            document.getElementById('stats-total-tracked').textContent = uniqueAircraftSeen.size;
            document.getElementById('stats-max-concurrent').textContent = maxConcurrentAircraft;

            // Calculate average altitude
            let totalAlt = 0, altCount = 0;
            const altBuckets = [0, 0, 0, 0, 0]; // <5k, 5-15k, 15-30k, 30-40k, >40k

            if (_airplanesArrayDirty) {
                _airplanesArray = Array.from(airplanes.values());
                _airplanesArrayDirty = false;
            }

            for (const plane of _airplanesArray) {
                const alt = plane.userData.altitude || 0;
                totalAlt += alt;
                altCount++;

                // Bucket altitude
                if (alt < 5000) altBuckets[0]++;
                else if (alt < 15000) altBuckets[1]++;
                else if (alt < 30000) altBuckets[2]++;
                else if (alt < 40000) altBuckets[3]++;
                else altBuckets[4]++;

                // Track unique aircraft
                if (plane.userData.hex) {
                    uniqueAircraftSeen.add(plane.userData.hex);
                }

                // Track aircraft types (if available)
                const flight = plane.userData.flight || '';
                if (flight) {
                    const airline = flight.substring(0, 3);
                    aircraftTypeStats.set(airline, (aircraftTypeStats.get(airline) || 0) + 1);
                }

                // Update coverage heatmap
                if (plane.userData.lat && plane.userData.lon && window.mapBounds) {
                    const bounds = window.mapBounds;
                    const normX = (plane.userData.lon - bounds.west) / (bounds.east - bounds.west);
                    const normY = (plane.userData.lat - bounds.south) / (bounds.north - bounds.south);
                    if (normX >= 0 && normX < 1 && normY >= 0 && normY < 1) {
                        const gridX = Math.floor(normX * 20);
                        const gridY = Math.floor(normY * 20);
                        const idx = gridY * 20 + gridX;
                        coverageHeatmap[idx] = Math.min(255, coverageHeatmap[idx] + 1);
                    }
                }
            }

            // Update max concurrent
            if (_airplanesArray.length > maxConcurrentAircraft) {
                maxConcurrentAircraft = _airplanesArray.length;
            }

            // Display average altitude
            const avgAlt = altCount > 0 ? Math.round(totalAlt / altCount) : 0;
            document.getElementById('stats-avg-altitude').textContent = formatAltitude(avgAlt);

            // Calculate data quality (% with position)
            let withPosition = 0;
            for (const plane of _airplanesArray) {
                if (plane.userData.lat && plane.userData.lon) withPosition++;
            }
            const quality = altCount > 0 ? Math.round((withPosition / altCount) * 100) : 0;
            document.getElementById('stats-data-quality').textContent = quality + '%';

            // Update altitude distribution bars
            const maxBucket = Math.max(...altBuckets, 1);
            for (let i = 0; i < 5; i++) {
                const pct = (altBuckets[i] / maxBucket) * 100;
                document.getElementById(`alt-bar-${i}`).style.width = pct + '%';
                document.getElementById(`alt-count-${i}`).textContent = altBuckets[i];
            }

            // Update top aircraft types/airlines
            const sortedTypes = Array.from(aircraftTypeStats.entries())
                .sort((a, b) => b[1] - a[1])
                .slice(0, 5);
            const typesHtml = sortedTypes.map(([code, count]) =>
                `<div style="display:flex;justify-content:space-between;padding:2px 0;">
                    <span>${code}</span><span style="font-weight:bold;">${count}</span>
                </div>`
            ).join('');
            document.getElementById('top-aircraft-types').innerHTML = typesHtml || '<em>No data</em>';

            // Draw coverage heatmap
            drawCoverageHeatmap();
        }

        function drawCoverageHeatmap() {
            const canvas = document.getElementById('coverage-canvas');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            const rect = canvas.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);

            const cellW = rect.width / 20;
            const cellH = rect.height / 20;

            const isRetro = currentTheme === 'retro';
            const maxVal = Math.max(...coverageHeatmap, 1);

            for (let y = 0; y < 20; y++) {
                for (let x = 0; x < 20; x++) {
                    const val = coverageHeatmap[y * 20 + x];
                    const intensity = val / maxVal;

                    if (isRetro) {
                        ctx.fillStyle = `rgba(0, ${Math.floor(255 * intensity)}, 0, ${0.2 + intensity * 0.8})`;
                    } else if (currentTheme === 'night') {
                        ctx.fillStyle = `rgba(0, ${Math.floor(180 + 75 * intensity)}, ${Math.floor(255 * intensity)}, ${0.2 + intensity * 0.8})`;
                    } else {
                        ctx.fillStyle = `rgba(0, ${Math.floor(100 + 155 * intensity)}, ${Math.floor(255 * intensity)}, ${0.2 + intensity * 0.8})`;
                    }

                    ctx.fillRect(x * cellW, (19 - y) * cellH, cellW - 1, cellH - 1);
                }
            }
        }

        // ===========================================
        // AIRCRAFT INFORMATION ENRICHMENT
        // ===========================================
        async function checkEnrichmentApiAvailability() {
            // Try to check if we have internet access and can reach external APIs
            try {
                const controller = new AbortController();
                const timeout = setTimeout(() => controller.abort(), 3000);
                const response = await fetch('https://hexdb.io/api/v1/aircraft/a00001', {
                    method: 'HEAD',
                    signal: controller.signal
                });
                clearTimeout(timeout);
                enrichmentApiAvailable = response.ok;
            } catch (e) {
                enrichmentApiAvailable = false;
            }
            console.log('Aircraft enrichment API available:', enrichmentApiAvailable);
        }

        async function fetchAircraftInfo(hex) {
            if (!hex || enrichmentApiAvailable === false) return null;

            // Check cache first
            if (aircraftInfoCache.has(hex)) {
                return aircraftInfoCache.get(hex);
            }

            try {
                // Try hexdb.io API (free, no auth required)
                const response = await fetch(`https://hexdb.io/api/v1/aircraft/${hex}`, {
                    cache: 'force-cache'
                });

                if (response.ok) {
                    const data = await response.json();
                    const info = {
                        registration: data.Registration || null,
                        manufacturer: data.Manufacturer || null,
                        type: data.Type || null,
                        model: data.ICAOTypeCode || null,
                        operator: data.RegisteredOwners || null,
                        country: data.OperatorFlagCode || null,
                        origin: null,
                        destination: null
                    };
                    aircraftInfoCache.set(hex, info);
                    return info;
                }
            } catch (e) {
                // API not available
            }

            // Cache null result to avoid repeated failed requests
            aircraftInfoCache.set(hex, null);
            return null;
        }

        // Fetch route information from ADS-B Exchange or adsbdb
        async function fetchRouteInfo(callsign, hex) {
            if (!callsign && !hex) return null;

            const cacheKey = `route-${callsign || hex}`;
            if (aircraftInfoCache.has(cacheKey)) {
                return aircraftInfoCache.get(cacheKey);
            }

            // Try adsbdb.com for callsign-based route lookup
            if (callsign) {
                try {
                    const cleanCallsign = callsign.trim().toUpperCase();
                    const response = await fetch(`https://api.adsbdb.com/v0/callsign/${cleanCallsign}`, {
                        cache: 'force-cache'
                    });

                    if (response.ok) {
                        const data = await response.json();
                        if (data.response && data.response.flightroute) {
                            const route = data.response.flightroute;
                            const routeInfo = {
                                origin: route.origin ? `${route.origin.iata_code || route.origin.icao_code} - ${route.origin.name || ''}`.trim() : null,
                                originCode: route.origin ? (route.origin.iata_code || route.origin.icao_code) : null,
                                destination: route.destination ? `${route.destination.iata_code || route.destination.icao_code} - ${route.destination.name || ''}`.trim() : null,
                                destinationCode: route.destination ? (route.destination.iata_code || route.destination.icao_code) : null,
                                airline: route.airline ? route.airline.name : null
                            };
                            aircraftInfoCache.set(cacheKey, routeInfo);
                            return routeInfo;
                        }
                    }
                } catch (e) {
                    // adsbdb not available
                }
            }

            // Try ADS-B Exchange API as fallback
            if (hex) {
                try {
                    const response = await fetch(`https://api.adsb.lol/v2/hex/${hex}`, {
                        cache: 'no-store'
                    });

                    if (response.ok) {
                        const data = await response.json();
                        if (data.ac && data.ac.length > 0) {
                            const ac = data.ac[0];
                            // adsb.lol provides route in 'r' field sometimes
                            if (ac.flight) {
                                // Try to get route from the response
                                const routeInfo = {
                                    origin: ac.dep || null,
                                    originCode: ac.dep || null,
                                    destination: ac.arr || null,
                                    destinationCode: ac.arr || null,
                                    airline: null
                                };
                                if (routeInfo.origin || routeInfo.destination) {
                                    aircraftInfoCache.set(cacheKey, routeInfo);
                                    return routeInfo;
                                }
                            }
                        }
                    }
                } catch (e) {
                    // adsb.lol not available
                }
            }

            // Cache null to avoid repeated requests
            aircraftInfoCache.set(cacheKey, null);
            return null;
        }

        async function updateEnrichedInfo(plane) {
            const enrichedPanel = document.getElementById('aircraft-enriched-info');
            const loadingEl = document.getElementById('enriched-loading');
            const dataEl = document.getElementById('enriched-data');

            if (!plane || enrichmentApiAvailable === false) {
                enrichedPanel.classList.remove('visible');
                return;
            }

            enrichedPanel.classList.add('visible');
            loadingEl.style.display = 'block';
            dataEl.style.display = 'none';

            // Fetch aircraft info and route info in parallel
            const [info, routeInfo] = await Promise.all([
                fetchAircraftInfo(plane.userData.hex),
                fetchRouteInfo(plane.userData.flight, plane.userData.hex)
            ]);

            if (info || routeInfo) {
                document.getElementById('sel-registration').textContent = (info && info.registration) || '--';
                document.getElementById('sel-aircraft-type').textContent =
                    (info && [info.manufacturer, info.type].filter(Boolean).join(' ')) || '--';
                document.getElementById('sel-operator').textContent =
                    (routeInfo && routeInfo.airline) || (info && info.operator) || '--';
                document.getElementById('sel-origin').textContent =
                    (routeInfo && routeInfo.origin) || '--';
                document.getElementById('sel-destination').textContent =
                    (routeInfo && routeInfo.destination) || '--';

                // Update external links
                const callsign = plane.userData.flight || '';
                const hex = plane.userData.hex;
                document.getElementById('link-flightaware').href =
                    callsign ? `https://flightaware.com/live/flight/${callsign.trim()}` : '#';
                document.getElementById('link-fr24').href =
                    callsign ? `https://www.flightradar24.com/${callsign.trim()}` : '#';
                document.getElementById('link-adsbx').href =
                    hex ? `https://globe.adsbexchange.com/?icao=${hex}` : '#';

                loadingEl.style.display = 'none';
                dataEl.style.display = 'block';
            } else {
                // No data available, hide enriched panel
                enrichedPanel.classList.remove('visible');
            }
        }

        // ===========================================
        // AIRCRAFT TYPE DIFFERENTIATION
        // ===========================================
        // Determine aircraft category based on available data
        function getAircraftCategory(data) {
            const flight = (data.flight || '').trim().toUpperCase();
            const alt = data.altitude || 0;
            const speed = data.gs || 0;

            // Check for helicopter patterns (low altitude, low speed, specific callsigns)
            if (alt < 3000 && speed < 150) {
                if (flight.match(/^(N\d|LIFE|MED|HELI|COAST|RESCUE)/)) {
                    return 'helicopter';
                }
            }

            // Military patterns
            if (flight.match(/^(RCH|REACH|DUKE|EVAC|SPAR|EXEC|AIR|FORCE|NAVY|ARMY|TOPCAT|HAWK)/)) {
                return 'military';
            }

            // Small aircraft (low altitude, slow speed, GA callsigns)
            if (alt < 10000 && speed < 200) {
                if (flight.match(/^N\d/) || flight === '') {
                    return 'small';
                }
            }

            // Regional jets (medium altitude, medium speed)
            if (alt < 30000 && speed < 400) {
                return 'regional';
            }

            // Wide-body indicators (heavy suffix patterns, long-haul routes)
            if (flight.match(/(UAE|QTR|SIA|CPA|BAW|DLH|AFR|KLM|ANA|JAL)/)) {
                return 'widebody';
            }

            // Default to narrow-body jet
            return 'jet';
        }

        // Extended createAirplane function is handled in original - add category info to userData
        // We'll modify the existing function to include category

        // ===========================================
        // FOLLOW AIRCRAFT FEATURE
        // ===========================================
        function updateFollowMode() {
            if (!followSelectedPlane || !selectedPlane) return;

            const plane = airplanes.get(selectedPlane.userData.hex);
            if (!plane) {
                followSelectedPlane = false;
                return;
            }

            // Center map on selected aircraft
            if (plane.userData.lat && plane.userData.lon) {
                const targetLat = plane.userData.lat;
                const targetLon = plane.userData.lon;

                // Smooth transition if not already transitioning
                if (!mapTransition.active) {
                    const distLat = Math.abs(centerLat - targetLat);
                    const distLon = Math.abs(centerLon - targetLon);

                    // Only transition if aircraft moved significantly
                    if (distLat > 0.01 || distLon > 0.01) {
                        startMapTransition(targetLat, targetLon, currentZoom);
                    }
                }
            }
        }

        // Initialize
        init();

        // Check enrichment API availability on load
        checkEnrichmentApiAvailability();

        // Set button states based on loaded settings
        document.getElementById('btn-labels').classList.toggle('active', showLabels);
        document.getElementById('btn-rotate').classList.toggle('active', autoRotate);
        document.getElementById('btn-trails').classList.toggle('active', trailEnabled);
        document.getElementById('btn-graphs').classList.toggle('active', showGraphs);
        document.getElementById('btn-stats').classList.toggle('active', showStats);

        // Initialize stats panel update interval
        setInterval(() => {
            if (showStats) updateStatsPanel();
        }, 2000);
    </script>
</body>
</html>
